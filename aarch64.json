{
  "instructions": {
    "base": {
      "ADC": {
        "authored": "Add with Carry adds two register values and the Carry flag value, and writes the\nresult to the destination register.",
        "heading": "ADC",
        "templates": {
          "NO_S": [
            "ADC  <Wd>, <Wn>, <Wm>",
            "ADC  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "ADCS": {
        "authored": "Add with Carry, setting flags, adds two register values and the Carry flag\nvalue, and writes the result to the destination register. It updates the\ncondition flags based on the result.",
        "heading": "ADCS",
        "templates": {
          "S": [
            "ADCS  <Wd>, <Wn>, <Wm>",
            "ADCS  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "ADDG": {
        "authored": "Add with Tag adds an immediate value scaled by the Tag granule to the address in\nthe source register, modifies the Logical Address Tag of the address using an\nimmediate value, and writes the result to the destination register. Tags\nspecified in GCR_EL1.Exclude are excluded from the possible outputs when\nmodifying the Logical Address Tag.",
        "heading": "ADDG",
        "templates": {
          "ADDG_64_ADDSUB_IMMTAGS": [
            "ADDG  <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>"
          ]
        }
      },
      "ADDS_addsub_ext": {
        "authored": "Add (extended register), setting flags, adds a register value and a sign or\nzero-extended register value, followed by an optional left shift amount, and\nwrites the result to the destination register. The argument that is extended\nfrom the <Rm> register can be a byte, halfword, word, or doubleword. It updates\nthe condition flags based on the result.",
        "heading": "ADDS (extended register)",
        "templates": {
          "S": [
            "ADDS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}",
            "ADDS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          ]
        }
      },
      "ADDS_addsub_imm": {
        "authored": "Add (immediate), setting flags, adds a register value and an optionally-shifted\nimmediate value, and writes the result to the destination register. It updates\nthe condition flags based on the result.",
        "heading": "ADDS (immediate)",
        "templates": {
          "S": [
            "ADDS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}",
            "ADDS  <Xd>, <Xn|SP>, #<imm>{, <shift>}"
          ]
        }
      },
      "ADDS_addsub_shift": {
        "authored": "Add (shifted register), setting flags, adds a register value and an optionally-\nshifted register value, and writes the result to the destination register. It\nupdates the condition flags based on the result.",
        "heading": "ADDS (shifted register)",
        "templates": {
          "S": [
            "ADDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "ADDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "ADD_addsub_ext": {
        "authored": "Add (extended register) adds a register value and a sign or zero-extended\nregister value, followed by an optional left shift amount, and writes the result\nto the destination register. The argument that is extended from the <Rm>\nregister can be a byte, halfword, word, or doubleword.",
        "heading": "ADD (extended register)",
        "templates": {
          "NO_S": [
            "ADD  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}",
            "ADD  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          ]
        }
      },
      "ADD_addsub_imm": {
        "authored": "Add (immediate) adds a register value and an optionally-shifted immediate value,\nand writes the result to the destination register.",
        "heading": "ADD (immediate)",
        "templates": {
          "NO_S": [
            "ADD  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}",
            "ADD  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}"
          ]
        }
      },
      "ADD_addsub_shift": {
        "authored": "Add (shifted register) adds a register value and an optionally-shifted register\nvalue, and writes the result to the destination register.",
        "heading": "ADD (shifted register)",
        "templates": {
          "NO_S": [
            "ADD  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "ADD  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "ADR": {
        "authored": "Form PC-relative address adds an immediate value to the PC value to form a PC-\nrelative address, and writes the result to the destination register.",
        "heading": "ADR",
        "templates": {
          "ADR_ONLY_PCRELADDR": [
            "ADR  <Xd>, <label>"
          ]
        }
      },
      "ADRP": {
        "authored": "Form PC-relative address to 4KB page adds an immediate value that is shifted\nleft by 12 bits, to the PC value to form a PC-relative address, with the bottom\n12 bits masked out, and writes the result to the destination register.",
        "heading": "ADRP",
        "templates": {
          "ADRP_ONLY_PCRELADDR": [
            "ADRP  <Xd>, <label>"
          ]
        }
      },
      "ANDS_log_imm": {
        "authored": "Bitwise AND (immediate), setting flags, performs a bitwise AND of a register\nvalue and an immediate value, and writes the result to the destination register.\nIt updates the condition flags based on the result.",
        "heading": "ANDS (immediate)",
        "templates": {
          "S": [
            "ANDS  <Wd>, <Wn>, #<imm>",
            "ANDS  <Xd>, <Xn>, #<imm>"
          ]
        }
      },
      "ANDS_log_shift": {
        "authored": "Bitwise AND (shifted register), setting flags, performs a bitwise AND of a\nregister value and an optionally-shifted register value, and writes the result\nto the destination register. It updates the condition flags based on the result.",
        "heading": "ANDS (shifted register)",
        "templates": {
          "S": [
            "ANDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "ANDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "AND_log_imm": {
        "authored": "Bitwise AND (immediate) performs a bitwise AND of a register value and an\nimmediate value, and writes the result to the destination register.",
        "heading": "AND (immediate)",
        "templates": {
          "NO_S": [
            "AND  <Wd|WSP>, <Wn>, #<imm>",
            "AND  <Xd|SP>, <Xn>, #<imm>"
          ]
        }
      },
      "AND_log_shift": {
        "authored": "Bitwise AND (shifted register) performs a bitwise AND of a register value and an\noptionally-shifted register value, and writes the result to the destination\nregister.",
        "heading": "AND (shifted register)",
        "templates": {
          "NO_S": [
            "AND  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "AND  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "ASRV": {
        "authored": "Arithmetic Shift Right Variable shifts a register value right by a variable\nnumber of bits, shifting in copies of its sign bit, and writes the result to the\ndestination register. The remainder obtained by dividing the second source\nregister by the data size defines the number of bits by which the first source\nregister is right-shifted.",
        "heading": "ASRV",
        "templates": {
          "GENERAL": [
            "ASRV  <Wd>, <Wn>, <Wm>",
            "ASRV  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "ASR_ASRV": {
        "authored": "Arithmetic Shift Right (register) shifts a register value right by a variable\nnumber of bits, shifting in copies of its sign bit, and writes the result to the\ndestination register. The remainder obtained by dividing the second source\nregister by the data size defines the number of bits by which the first source\nregister is right-shifted.",
        "heading": "ASR (register)",
        "templates": {
          "GENERAL": [
            "ASR  <Wd>, <Wn>, <Wm>",
            "ASR  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "ASR_SBFM": {
        "authored": "Arithmetic Shift Right (immediate) shifts a register value right by an immediate\nnumber of bits, shifting in copies of the sign bit in the upper bits and zeros\nin the lower bits, and writes the result to the destination register.",
        "heading": "ASR (immediate)",
        "templates": {
          "SIGNED_FILL": [
            "ASR  <Wd>, <Wn>, #<shift>",
            "ASR  <Xd>, <Xn>, #<shift>"
          ]
        }
      },
      "AT_SYS": {
        "authored": "Address Translate. For more information, see op0==0b01, cache maintenance, TLB\nmaintenance, and address translation instructions.",
        "heading": "AT",
        "templates": {
          "SYS_CR_SYSTEMINSTRS": [
            "AT  <at_op>, <Xt>"
          ]
        }
      },
      "AUTDA": {
        "authored": "Authenticate Data address, using key A. This instruction authenticates a data\naddress, using a modifier and key A.\n\nThe address is in the general-purpose register that is specified by <Xd>.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for AUTDA.\n  - The value zero, for AUTDZA.\n\nIf the authentication passes, the upper bits of the address are restored to\nenable subsequent use of the address. If the authentication fails, the upper\nbits are corrupted and any subsequent use of the address results in a\nTranslation fault.",
        "heading": "AUTDA, AUTDZA",
        "templates": {
          "GENERAL": [
            "AUTDA  <Xd>, <Xn|SP>",
            "AUTDZA  <Xd>"
          ]
        }
      },
      "AUTDB": {
        "authored": "Authenticate Data address, using key B. This instruction authenticates a data\naddress, using a modifier and key B.\n\nThe address is in the general-purpose register that is specified by <Xd>.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for AUTDB.\n  - The value zero, for AUTDZB.\n\nIf the authentication passes, the upper bits of the address are restored to\nenable subsequent use of the address. If the authentication fails, the upper\nbits are corrupted and any subsequent use of the address results in a\nTranslation fault.",
        "heading": "AUTDB, AUTDZB",
        "templates": {
          "GENERAL": [
            "AUTDB  <Xd>, <Xn|SP>",
            "AUTDZB  <Xd>"
          ]
        }
      },
      "AUTIA": {
        "authored": "Authenticate Instruction address, using key A. This instruction authenticates an\ninstruction address, using a modifier and key A.\n\nThe address is:\n  - In the general-purpose register that is specified by <Xd> for AUTIA and\nAUTIZA.\n  - In X17, for AUTIA1716.\n  - In X30, for AUTIASP and AUTIAZ.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for AUTIA.\n  - The value zero, for AUTIZA and AUTIAZ.\n  - In X16, for AUTIA1716.\n  - In SP, for AUTIASP.\n\nIf the authentication passes, the upper bits of the address are restored to\nenable subsequent use of the address. If the authentication fails, the upper\nbits are corrupted and any subsequent use of the address results in a\nTranslation fault.",
        "heading": "AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIZA",
        "templates": {
          "GENERAL": [
            "AUTIA  <Xd>, <Xn|SP>",
            "AUTIZA  <Xd>"
          ],
          "SYSTEM": [
            "AUTIA1716",
            "AUTIASP",
            "AUTIAZ"
          ]
        }
      },
      "AUTIB": {
        "authored": "Authenticate Instruction address, using key B. This instruction authenticates an\ninstruction address, using a modifier and key B.\n\nThe address is:\n  - In the general-purpose register that is specified by <Xd> for AUTIB and\nAUTIZB.\n  - In X17, for AUTIB1716.\n  - In X30, for AUTIBSP and AUTIBZ.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for AUTIB.\n  - The value zero, for AUTIZB and AUTIBZ.\n  - In X16, for AUTIB1716.\n  - In SP, for AUTIBSP.\n\nIf the authentication passes, the upper bits of the address are restored to\nenable subsequent use of the address. If the authentication fails, the upper\nbits are corrupted and any subsequent use of the address results in a\nTranslation fault.",
        "heading": "AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZB",
        "templates": {
          "GENERAL": [
            "AUTIB  <Xd>, <Xn|SP>",
            "AUTIZB  <Xd>"
          ],
          "SYSTEM": [
            "AUTIB1716",
            "AUTIBSP",
            "AUTIBZ"
          ]
        }
      },
      "AXFLAG": {
        "authored": "Convert floating-point condition flags from Arm to external format. This\ninstruction converts the state of the PSTATE.{N,Z,C,V} flags from a form\nrepresenting the result of an Arm floating-point scalar compare instruction to\nan alternative representation required by some software.",
        "heading": "AXFLAG",
        "templates": {
          "AXFLAG_M_PSTATE": [
            "AXFLAG"
          ]
        }
      },
      "BFC_BFM": {
        "authored": "Bitfield Clear sets a bitfield of <width> bits at bit position <lsb> of the\ndestination register to zero, leaving the other destination bits unchanged.",
        "heading": "BFC",
        "templates": {
          "NOFILL": [
            "BFC  <Wd>, #<lsb>, #<width>",
            "BFC  <Xd>, #<lsb>, #<width>"
          ]
        }
      },
      "BFI_BFM": {
        "authored": "Bitfield Insert copies a bitfield of <width> bits from the least significant\nbits of the source register to bit position <lsb> of the destination register,\nleaving the other destination bits unchanged.",
        "heading": "BFI",
        "templates": {
          "NOFILL": [
            "BFI  <Wd>, <Wn>, #<lsb>, #<width>",
            "BFI  <Xd>, <Xn>, #<lsb>, #<width>"
          ]
        }
      },
      "BFM": {
        "authored": "Bitfield Move is usually accessed via one of its aliases, which are always\npreferred for disassembly.\n\nIf <imms> is greater than or equal to <immr>, this copies a bitfield of\n(<imms>-<immr>+1) bits starting from bit position <immr> in the source register\nto the least significant bits of the destination register.\n\nIf <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from\nthe least significant bits of the source register to bit position\n(regsize-<immr>) of the destination register, where regsize is the destination\nregister size of 32 or 64 bits.\n\nIn both cases the other bits of the destination register remain unchanged.",
        "heading": "BFM",
        "templates": {
          "NOFILL": [
            "BFM  <Wd>, <Wn>, #<immr>, #<imms>",
            "BFM  <Xd>, <Xn>, #<immr>, #<imms>"
          ]
        }
      },
      "BFXIL_BFM": {
        "authored": "Bitfield Extract and Insert Low copies a bitfield of <width> bits starting from\nbit position <lsb> in the source register to the least significant bits of the\ndestination register, leaving the other destination bits unchanged.",
        "heading": "BFXIL",
        "templates": {
          "NOFILL": [
            "BFXIL  <Wd>, <Wn>, #<lsb>, #<width>",
            "BFXIL  <Xd>, <Xn>, #<lsb>, #<width>"
          ]
        }
      },
      "BICS": {
        "authored": "Bitwise Bit Clear (shifted register), setting flags, performs a bitwise AND of a\nregister value and the complement of an optionally-shifted register value, and\nwrites the result to the destination register. It updates the condition flags\nbased on the result.",
        "heading": "BICS (shifted register)",
        "templates": {
          "S": [
            "BICS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "BICS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "BIC_log_shift": {
        "authored": "Bitwise Bit Clear (shifted register) performs a bitwise AND of a register value\nand the complement of an optionally-shifted register value, and writes the\nresult to the destination register.",
        "heading": "BIC (shifted register)",
        "templates": {
          "NO_S": [
            "BIC  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "BIC  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "BL": {
        "authored": "Branch with Link branches to a PC-relative offset, setting the register X30 to\nPC+4. It provides a hint that this is a subroutine call.",
        "heading": "BL",
        "templates": {
          "BL_ONLY_BRANCH_IMM": [
            "BL  <label>"
          ]
        }
      },
      "BLR": {
        "authored": "Branch with Link to Register calls a subroutine at an address in a register,\nsetting register X30 to PC+4.",
        "heading": "BLR",
        "templates": {
          "BLR_64_BRANCH_REG": [
            "BLR  <Xn>"
          ]
        }
      },
      "BLRA": {
        "authored": "Branch with Link to Register, with pointer authentication. This instruction\nauthenticates the address in the general-purpose register that is specified by\n<Xn>, using a modifier and the specified key, and calls a subroutine at the\nauthenticated address, setting register X30 to PC+4.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xm|SP> for BLRAA and BLRAB.\n  - The value zero, for BLRAAZ and BLRABZ.\n\nKey A is used for BLRAA and BLRAAZ, and key B is used for BLRAB and BLRABZ.\n\nIf the authentication passes, the PE continues execution at the target of the\nbranch. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to the general-purpose register.",
        "heading": "BLRAA, BLRAAZ, BLRAB, BLRABZ",
        "templates": {
          "GENERAL": [
            "BLRAAZ  <Xn>",
            "BLRAA  <Xn>, <Xm|SP>",
            "BLRABZ  <Xn>",
            "BLRAB  <Xn>, <Xm|SP>"
          ]
        }
      },
      "BR": {
        "authored": "Branch to Register branches unconditionally to an address in a register, with a\nhint that this is not a subroutine return.",
        "heading": "BR",
        "templates": {
          "BR_64_BRANCH_REG": [
            "BR  <Xn>"
          ]
        }
      },
      "BRA": {
        "authored": "Branch to Register, with pointer authentication. This instruction authenticates\nthe address in the general-purpose register that is specified by <Xn>, using a\nmodifier and the specified key, and branches to the authenticated address.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xm|SP> for BRAA and BRAB.\n  - The value zero, for BRAAZ and BRABZ.\n\nKey A is used for BRAA and BRAAZ, and key B is used for BRAB and BRABZ.\n\nIf the authentication passes, the PE continues execution at the target of the\nbranch. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to the general-purpose register.",
        "heading": "BRAA, BRAAZ, BRAB, BRABZ",
        "templates": {
          "GENERAL": [
            "BRAAZ  <Xn>",
            "BRAA  <Xn>, <Xm|SP>",
            "BRABZ  <Xn>",
            "BRAB  <Xn>, <Xm|SP>"
          ]
        }
      },
      "BRK": {
        "authored": "Breakpoint instruction. A BRK instruction generates a Breakpoint Instruction\nexception. The PE records the exception in ESR_ELx, using the EC value 0x3c, and\ncaptures the value of the immediate argument in ESR_ELx.ISS.",
        "heading": "BRK",
        "templates": {
          "BRK_EX_EXCEPTION": [
            "BRK  #<imm>"
          ]
        }
      },
      "BTI": {
        "authored": "Branch Target Identification. A BTI instruction is used to guard against the\nexecution of instructions which are not the intended target of a branch.\n\nOutside of a guarded memory region, a BTI instruction executes as a NOP. Within\na guarded memory region while PSTATE.BTYPE != 0b00, a BTI instruction compatible\nwith the current value of PSTATE.BTYPE will not generate a Branch Target\nException and will allow execution of subsequent instructions within the memory\nregion.\n\nThe operand <targets> passed to a BTI instruction determines the values of\nPSTATE.BTYPE which the BTI instruction is compatible with.\n\nWithin a guarded memory region, while PSTATE.BTYPE\n\n!= 0b00, all instructions will generate a Branch Target\n\nException, other than BRK, BTI, HLT, PACIASP,\n\nand PACIBSP, which may not. See the individual instructions for details.",
        "heading": "BTI",
        "templates": {
          "BTI_HB_HINTS": [
            "BTI  {<targets>}"
          ]
        }
      },
      "B_cond": {
        "authored": "Branch conditionally to a label at a PC-relative offset, with a hint that this\nis not a subroutine call or return.",
        "heading": "B.cond",
        "templates": {
          "B_ONLY_CONDBRANCH": [
            "B.<cond>  <label>"
          ]
        }
      },
      "B_uncond": {
        "authored": "Branch causes an unconditional branch to a label at a PC-relative offset, with a\nhint that this is not a subroutine call or return.",
        "heading": "B",
        "templates": {
          "B_ONLY_BRANCH_IMM": [
            "B  <label>"
          ]
        }
      },
      "CAS": {
        "authored": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit\ndoubleword from memory, and compares it against the value held in a first\nregister. If the comparison is equal, the value in a second register is written\nto memory. If the write is performed, the read and write occur atomically such\nthat no other modification of the memory location can take place between the\nread and write.\n  - CASA and CASAL load from memory with acquire semantics.\n  - CASL and CASAL store to memory with release semantics.\n  - CAS has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors\nassociated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the register which is\ncompared and loaded, that is <Ws>, or <Xs>, is restored to the value held in the\nregister before the instruction was executed.",
        "heading": "CAS, CASA, CASAL, CASL",
        "templates": {
          "BASE_REGISTER": [
            "CAS  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASA  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASAL  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASL  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CAS  <Xs>, <Xt>, [<Xn|SP>{,#0}]",
            "CASA  <Xs>, <Xt>, [<Xn|SP>{,#0}]",
            "CASAL  <Xs>, <Xt>, [<Xn|SP>{,#0}]",
            "CASL  <Xs>, <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "CASB": {
        "authored": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it\nagainst the value held in a first register. If the comparison is equal, the\nvalue in a second register is written to memory. If the write is performed, the\nread and write occur atomically such that no other modification of the memory\nlocation can take place between the read and write.\n  - CASAB and CASALB load from memory with acquire semantics.\n  - CASLB and CASALB store to memory with release semantics.\n  - CASB has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors\nassociated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the register which is\ncompared and loaded, that is <Ws>, is restored to the values held in the\nregister before the instruction was executed.",
        "heading": "CASB, CASAB, CASALB, CASLB",
        "templates": {
          "BASE_REGISTER": [
            "CASAB  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASALB  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASB  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASLB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "CASH": {
        "authored": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and\ncompares it against the value held in a first register. If the comparison is\nequal, the value in a second register is written to memory. If the write is\nperformed, the read and write occur atomically such that no other modification\nof the memory location can take place between the read and write.\n  - CASAH and CASALH load from memory with acquire semantics.\n  - CASLH and CASALH store to memory with release semantics.\n  - CAS has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors\nassociated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the register which is\ncompared and loaded, that is <Ws>, is restored to the values held in the\nregister before the instruction was executed.",
        "heading": "CASH, CASAH, CASALH, CASLH",
        "templates": {
          "BASE_REGISTER": [
            "CASAH  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASALH  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASH  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "CASLH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "CASP": {
        "authored": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit\nwords or 64-bit doublewords from memory, and compares them against the values\nheld in the first pair of registers. If the comparison is equal, the values in\nthe second pair of registers are written to memory. If the writes are performed,\nthe reads and writes occur atomically such that no other modification of the\nmemory location can take place between the reads and writes.\n  - CASPA and CASPAL load from memory with acquire semantics.\n  - CASPL and CASPAL store to memory with release semantics.\n  - CAS has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.\n\nThe architecture permits that the data read clears any exclusive monitors\nassociated with that location, even if the compare subsequently fails.\n\nIf the instruction generates a synchronous Data Abort, the registers which are\ncompared and loaded, that is <Ws> and <W(s+1)>, or <Xs> and <X(s+1)>, are\nrestored to the values held in the registers before the instruction was\nexecuted.",
        "heading": "CASP, CASPA, CASPAL, CASPL",
        "templates": {
          "BASE_REGISTER": [
            "CASP  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]",
            "CASPA  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]",
            "CASPAL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]",
            "CASPL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]",
            "CASP  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]",
            "CASPA  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]",
            "CASPAL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]",
            "CASPL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "CBNZ": {
        "authored": "Compare and Branch on Nonzero compares the value in a register with zero, and\nconditionally branches to a label at a PC-relative offset if the comparison is\nnot equal. It provides a hint that this is not a subroutine call or return. This\ninstruction does not affect the condition flags.",
        "heading": "CBNZ",
        "templates": {
          "BR19": [
            "CBNZ  <Wt>, <label>",
            "CBNZ  <Xt>, <label>"
          ]
        }
      },
      "CBZ": {
        "authored": "Compare and Branch on Zero compares the value in a register with zero, and\nconditionally branches to a label at a PC-relative offset if the comparison is\nequal. It provides a hint that this is not a subroutine call or return. This\ninstruction does not affect condition flags.",
        "heading": "CBZ",
        "templates": {
          "BR19": [
            "CBZ  <Wt>, <label>",
            "CBZ  <Xt>, <label>"
          ]
        }
      },
      "CCMN_imm": {
        "authored": "Conditional Compare Negative (immediate) sets the value of the condition flags\nto the result of the comparison of a register value and a negated immediate\nvalue if the condition is TRUE, and an immediate value otherwise.",
        "heading": "CCMN (immediate)",
        "templates": {
          "IMM5U": [
            "CCMN  <Wn>, #<imm>, #<nzcv>, <cond>",
            "CCMN  <Xn>, #<imm>, #<nzcv>, <cond>"
          ]
        }
      },
      "CCMN_reg": {
        "authored": "Conditional Compare Negative (register) sets the value of the condition flags to\nthe result of the comparison of a register value and the inverse of another\nregister value if the condition is TRUE, and an immediate value otherwise.",
        "heading": "CCMN (register)",
        "templates": {
          "GENERAL": [
            "CCMN  <Wn>, <Wm>, #<nzcv>, <cond>",
            "CCMN  <Xn>, <Xm>, #<nzcv>, <cond>"
          ]
        }
      },
      "CCMP_imm": {
        "authored": "Conditional Compare (immediate) sets the value of the condition flags to the\nresult of the comparison of a register value and an immediate value if the\ncondition is TRUE, and an immediate value otherwise.",
        "heading": "CCMP (immediate)",
        "templates": {
          "IMM5U": [
            "CCMP  <Wn>, #<imm>, #<nzcv>, <cond>",
            "CCMP  <Xn>, #<imm>, #<nzcv>, <cond>"
          ]
        }
      },
      "CCMP_reg": {
        "authored": "Conditional Compare (register) sets the value of the condition flags to the\nresult of the comparison of two registers if the condition is TRUE, and an\nimmediate value otherwise.",
        "heading": "CCMP (register)",
        "templates": {
          "GENERAL": [
            "CCMP  <Wn>, <Wm>, #<nzcv>, <cond>",
            "CCMP  <Xn>, <Xm>, #<nzcv>, <cond>"
          ]
        }
      },
      "CFINV": {
        "authored": "Invert Carry Flag. This instruction inverts the value of the PSTATE.C flag.",
        "heading": "CFINV",
        "templates": {
          "CFINV_M_PSTATE": [
            "CFINV"
          ]
        }
      },
      "CFP_SYS": {
        "authored": "Control Flow Prediction Restriction by Context prevents control flow predictions\nthat predict execution addresses, based on information gathered from earlier\nexecution within a particular execution context, from allowing later speculative\nexecution within that context to be observable through side-channels.\n\nFor more information, see CFP RCTX, Control Flow Prediction Restriction by\nContext.",
        "heading": "CFP",
        "templates": {
          "SYS_CR_SYSTEMINSTRS": [
            "CFP  RCTX, <Xt>"
          ]
        }
      },
      "CINC_CSINC": {
        "authored": "Conditional Increment returns, in the destination register, the value of the\nsource register incremented by 1 if the condition is TRUE, and otherwise returns\nthe value of the source register.",
        "heading": "CINC",
        "templates": {
          "GENERAL": [
            "CINC  <Wd>, <Wn>, <cond>",
            "CINC  <Xd>, <Xn>, <cond>"
          ]
        }
      },
      "CINV_CSINV": {
        "authored": "Conditional Invert returns, in the destination register, the bitwise inversion\nof the value of the source register if the condition is TRUE, and otherwise\nreturns the value of the source register.",
        "heading": "CINV",
        "templates": {
          "GENERAL": [
            "CINV  <Wd>, <Wn>, <cond>",
            "CINV  <Xd>, <Xn>, <cond>"
          ]
        }
      },
      "CLREX": {
        "authored": "Clear Exclusive clears the local monitor of the executing PE.",
        "heading": "CLREX",
        "templates": {
          "CLREX_BN_BARRIERS": [
            "CLREX  {#<imm>}"
          ]
        }
      },
      "CLS_int": {
        "authored": "Count Leading Sign bits counts the number of leading bits of the source register\nthat have the same value as the most significant bit of the register, and writes\nthe result to the destination register. This count does not include the most\nsignificant bit of the source register.",
        "heading": "CLS",
        "templates": {
          "GENERAL": [
            "CLS  <Wd>, <Wn>",
            "CLS  <Xd>, <Xn>"
          ]
        }
      },
      "CLZ_int": {
        "authored": "Count Leading Zeros counts the number of binary zero bits before the first\nbinary one bit in the value of the source register, and writes the result to the\ndestination register.",
        "heading": "CLZ",
        "templates": {
          "GENERAL": [
            "CLZ  <Wd>, <Wn>",
            "CLZ  <Xd>, <Xn>"
          ]
        }
      },
      "CMN_ADDS_addsub_ext": {
        "authored": "Compare Negative (extended register) adds a register value and a sign or zero-\nextended register value, followed by an optional left shift amount. The argument\nthat is extended from the <Rm> register can be a byte, halfword, word, or\ndoubleword. It updates the condition flags based on the result, and discards the\nresult.",
        "heading": "CMN (extended register)",
        "templates": {
          "S": [
            "CMN  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}",
            "CMN  <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          ]
        }
      },
      "CMN_ADDS_addsub_imm": {
        "authored": "Compare Negative (immediate) adds a register value and an optionally-shifted\nimmediate value. It updates the condition flags based on the result, and\ndiscards the result.",
        "heading": "CMN (immediate)",
        "templates": {
          "S": [
            "CMN  <Wn|WSP>, #<imm>{, <shift>}",
            "CMN  <Xn|SP>, #<imm>{, <shift>}"
          ]
        }
      },
      "CMN_ADDS_addsub_shift": {
        "authored": "Compare Negative (shifted register) adds a register value and an optionally-\nshifted register value. It updates the condition flags based on the result, and\ndiscards the result.",
        "heading": "CMN (shifted register)",
        "templates": {
          "S": [
            "CMN  <Wn>, <Wm>{, <shift> #<amount>}",
            "CMN  <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "CMPP_SUBPS": {
        "authored": "Compare with Tag subtracts the 56-bit address held in the second source register\nfrom the 56-bit address held in the first source register, updates the condition\nflags based on the result of the subtraction, and discards the result.",
        "heading": "CMPP",
        "templates": {
          "SUBPS_64S_DP_2SRC": [
            "CMPP  <Xn|SP>, <Xm|SP>"
          ]
        }
      },
      "CMP_SUBS_addsub_ext": {
        "authored": "Compare (extended register) subtracts a sign or zero-extended register value,\nfollowed by an optional left shift amount, from a register value. The argument\nthat is extended from the <Rm> register can be a byte, halfword, word, or\ndoubleword. It updates the condition flags based on the result, and discards the\nresult.",
        "heading": "CMP (extended register)",
        "templates": {
          "S": [
            "CMP  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}",
            "CMP  <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          ]
        }
      },
      "CMP_SUBS_addsub_imm": {
        "authored": "Compare (immediate) subtracts an optionally-shifted immediate value from a\nregister value. It updates the condition flags based on the result, and discards\nthe result.",
        "heading": "CMP (immediate)",
        "templates": {
          "S": [
            "CMP  <Wn|WSP>, #<imm>{, <shift>}",
            "CMP  <Xn|SP>, #<imm>{, <shift>}"
          ]
        }
      },
      "CMP_SUBS_addsub_shift": {
        "authored": "Compare (shifted register) subtracts an optionally-shifted register value from a\nregister value. It updates the condition flags based on the result, and discards\nthe result.",
        "heading": "CMP (shifted register)",
        "templates": {
          "S": [
            "CMP  <Wn>, <Wm>{, <shift> #<amount>}",
            "CMP  <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "CNEG_CSNEG": {
        "authored": "Conditional Negate returns, in the destination register, the negated value of\nthe source register if the condition is TRUE, and otherwise returns the value of\nthe source register.",
        "heading": "CNEG",
        "templates": {
          "GENERAL": [
            "CNEG  <Wd>, <Wn>, <cond>",
            "CNEG  <Xd>, <Xn>, <cond>"
          ]
        }
      },
      "CPP_SYS": {
        "authored": "Cache Prefetch Prediction Restriction by Context prevents cache allocation\npredictions, based on information gathered from earlier execution within a\nparticular execution context, from allowing later speculative execution within\nthat context to be observable through side-channels.\n\nFor more information, see CPP RCTX, Cache Prefetch Prediction Restriction by\nContext.",
        "heading": "CPP",
        "templates": {
          "SYS_CR_SYSTEMINSTRS": [
            "CPP  RCTX, <Xt>"
          ]
        }
      },
      "CRC32": {
        "authored": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value\nheld in a general-purpose register. It takes an input CRC value in the first\nsource operand, performs a CRC on the input value in the second source operand,\nand returns the output CRC value. The second source operand can be 8, 16, 32, or\n64 bits. To align with common usage, the bit order of the values is reversed as\npart of the operation, and the polynomial 0x04C11DB7 is used for the CRC\ncalculation.\n\nIn Armv8-A, this is an optional instruction, and in Armv8.1 it is mandatory for\nall implementations to implement it.\n\nID_AA64ISAR0_EL1.CRC32 indicates whether this instruction is supported.",
        "heading": "CRC32B, CRC32H, CRC32W, CRC32X",
        "templates": {
          "CRC": [
            "CRC32B  <Wd>, <Wn>, <Wm>",
            "CRC32H  <Wd>, <Wn>, <Wm>",
            "CRC32W  <Wd>, <Wn>, <Wm>",
            "CRC32X  <Wd>, <Wn>, <Xm>"
          ]
        }
      },
      "CRC32C": {
        "authored": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value\nheld in a general-purpose register. It takes an input CRC value in the first\nsource operand, performs a CRC on the input value in the second source operand,\nand returns the output CRC value. The second source operand can be 8, 16, 32, or\n64 bits. To align with common usage, the bit order of the values is reversed as\npart of the operation, and the polynomial 0x1EDC6F41 is used for the CRC\ncalculation.\n\nIn Armv8-A, this is an optional instruction, and in Armv8.1 it is mandatory for\nall implementations to implement it.\n\nID_AA64ISAR0_EL1.CRC32 indicates whether this instruction is supported.",
        "heading": "CRC32CB, CRC32CH, CRC32CW, CRC32CX",
        "templates": {
          "CRC": [
            "CRC32CB  <Wd>, <Wn>, <Wm>",
            "CRC32CH  <Wd>, <Wn>, <Wm>",
            "CRC32CW  <Wd>, <Wn>, <Wm>",
            "CRC32CX  <Wd>, <Wn>, <Xm>"
          ]
        }
      },
      "CSDB": {
        "authored": "Consumption of Speculative Data Barrier is a memory barrier that controls\nspeculative execution and data value prediction.\n\nNo instruction other than branch instructions appearing in program order after\nthe CSDB can be speculatively executed using the results of any:\n  - Data value predictions of any instructions.\n  - PSTATE.{N,Z,C,V} predictions of any instructions other than conditional\nbranch instructions appearing in program order before the CSDB that have not\nbeen architecturally resolved.\n  - Predictions of SVE predication state for any SVE instructions.\n\nFor purposes of the definition of CSDB, PSTATE.{N,Z,C,V} is not considered a\ndata value. This definition permits:\n  - Control flow speculation before and after the CSDB.\n  - Speculative execution of conditional data processing instructions after the\nCSDB, unless they use the results of data value or PSTATE.{N,Z,C,V} predictions\nof instructions appearing in program order before the CSDB that have not been\narchitecturally resolved.",
        "heading": "CSDB",
        "templates": {
          "CSDB_HI_HINTS": [
            "CSDB"
          ]
        }
      },
      "CSEL": {
        "authored": "Conditional Select returns, in the destination register, the value of the first\nsource register if the condition is TRUE, and otherwise returns the value of the\nsecond source register.",
        "heading": "CSEL",
        "templates": {
          "GENERAL": [
            "CSEL  <Wd>, <Wn>, <Wm>, <cond>",
            "CSEL  <Xd>, <Xn>, <Xm>, <cond>"
          ]
        }
      },
      "CSETM_CSINV": {
        "authored": "Conditional Set Mask sets all bits of the destination register to 1 if the\ncondition is TRUE, and otherwise sets all bits to 0.",
        "heading": "CSETM",
        "templates": {
          "GENERAL": [
            "CSETM  <Wd>, <cond>",
            "CSETM  <Xd>, <cond>"
          ]
        }
      },
      "CSET_CSINC": {
        "authored": "Conditional Set sets the destination register to 1 if the condition is TRUE, and\notherwise sets it to 0.",
        "heading": "CSET",
        "templates": {
          "GENERAL": [
            "CSET  <Wd>, <cond>",
            "CSET  <Xd>, <cond>"
          ]
        }
      },
      "CSINC": {
        "authored": "Conditional Select Increment returns, in the destination register, the value of\nthe first source register if the condition is TRUE, and otherwise returns the\nvalue of the second source register incremented by 1.",
        "heading": "CSINC",
        "templates": {
          "GENERAL": [
            "CSINC  <Wd>, <Wn>, <Wm>, <cond>",
            "CSINC  <Xd>, <Xn>, <Xm>, <cond>"
          ]
        }
      },
      "CSINV": {
        "authored": "Conditional Select Invert returns, in the destination register, the value of the\nfirst source register if the condition is TRUE, and otherwise returns the\nbitwise inversion value of the second source register.",
        "heading": "CSINV",
        "templates": {
          "GENERAL": [
            "CSINV  <Wd>, <Wn>, <Wm>, <cond>",
            "CSINV  <Xd>, <Xn>, <Xm>, <cond>"
          ]
        }
      },
      "CSNEG": {
        "authored": "Conditional Select Negation returns, in the destination register, the value of\nthe first source register if the condition is TRUE, and otherwise returns the\nnegated value of the second source register.",
        "heading": "CSNEG",
        "templates": {
          "GENERAL": [
            "CSNEG  <Wd>, <Wn>, <Wm>, <cond>",
            "CSNEG  <Xd>, <Xn>, <Xm>, <cond>"
          ]
        }
      },
      "DCPS1": {
        "authored": "Debug Change PE State to EL1, when executed in Debug state:\n  - If executed at EL0 changes the current Exception level and SP to EL1 using\nSP_EL1.\n  - Otherwise, if executed at ELx, selects SP_ELx.\n\nThe target exception level of a DCPS1 instruction is:\n  - EL1 if the instruction is executed at EL0.\n  - Otherwise, the Exception level at which the instruction is executed.\n\nWhen the target Exception level of a DCPS1 instruction is ELx, on executing this\ninstruction:\n  - ELR_ELx becomes unknown.\n  - SPSR_ELx becomes unknown.\n  - ESR_ELx becomes unknown.\n  - DLR_EL0 and DSPSR_EL0 become unknown.\n  - The endianness is set according to SCTLR_ELx.EE.\n\nThis instruction is undefined at EL0 in Non-secure state if EL2 is implemented\nand HCR_EL2.TGE == 1.\n\nThis instruction is always undefined in Non-debug state.\n\nFor more information on the operation of the DCPSn instructions, see DCPS.",
        "heading": "DCPS1",
        "templates": {
          "DCPS1_DC_EXCEPTION": [
            "DCPS1  {#<imm>}"
          ]
        }
      },
      "DCPS2": {
        "authored": "Debug Change PE State to EL2, when executed in Debug state:\n  - If executed at EL0 or EL1 changes the current Exception level and SP to EL2\nusing SP_EL2.\n  - Otherwise, if executed at ELx, selects SP_ELx.\n\nThe target exception level of a DCPS2 instruction is:\n  - EL2 if the instruction is executed at an exception level that is not EL3.\n  - EL3 if the instruction is executed at EL3.\n\nWhen the target Exception level of a DCPS2 instruction is ELx, on executing this\ninstruction:\n  - ELR_ELx becomes unknown.\n  - SPSR_ELx becomes unknown.\n  - ESR_ELx becomes unknown.\n  - DLR_EL0 and DSPSR_EL0 become unknown.\n  - The endianness is set according to SCTLR_ELx.EE.\n\nThis instruction is undefined at the following exception levels:\n  - All exception levels if EL2 is not implemented.\n  - At EL0 and EL1 if EL2 is disabled in the current Security state.\n\nThis instruction is always undefined in Non-debug state.\n\nFor more information on the operation of the DCPSn instructions, see DCPS.",
        "heading": "DCPS2",
        "templates": {
          "DCPS2_DC_EXCEPTION": [
            "DCPS2  {#<imm>}"
          ]
        }
      },
      "DCPS3": {
        "authored": "Debug Change PE State to EL3, when executed in Debug state:\n  - If executed at EL3 selects SP_EL3.\n  - Otherwise, changes the current Exception level and SP to EL3 using SP_EL3.\n\nThe target exception level of a DCPS3 instruction is EL3.\n\nOn executing a DCPS3 instruction:\n  - ELR_EL3 becomes unknown.\n  - SPSR_EL3 becomes unknown.\n  - ESR_EL3 becomes unknown.\n  - DLR_EL0 and DSPSR_EL0 become unknown.\n  - The endianness is set according to SCTLR_EL3.EE.\n\nThis instruction is undefined at all exception levels if either:\n  - EDSCR.SDD == 1.\n  - EL3 is not implemented.\n\nThis instruction is always undefined in Non-debug state.\n\nFor more information on the operation of the DCPSn instructions, see DCPS.",
        "heading": "DCPS3",
        "templates": {
          "DCPS3_DC_EXCEPTION": [
            "DCPS3  {#<imm>}"
          ]
        }
      },
      "DC_SYS": {
        "authored": "Data Cache operation. For more information, see op0==0b01, cache maintenance,\nTLB maintenance, and address translation instructions.",
        "heading": "DC",
        "templates": {
          "SYS_CR_SYSTEMINSTRS": [
            "DC  <dc_op>, <Xt>"
          ]
        }
      },
      "DGH": {
        "authored": "DGH is a hint instruction. A DGH instruction is not expected to be performance\noptimal to merge memory accesses with Normal Non-cacheable or Device-GRE\nattributes appearing in program order before the hint instruction with any\nmemory accesses appearing after the hint instruction into a single memory\ntransaction on an interconnect.",
        "heading": "DGH",
        "templates": {
          "DGH_HI_HINTS": [
            "DGH"
          ]
        }
      },
      "DMB": {
        "authored": "Data Memory Barrier is a memory barrier that ensures the ordering of\nobservations of memory accesses, see Data Memory Barrier.",
        "heading": "DMB",
        "templates": {
          "DMB_BO_BARRIERS": [
            "DMB  <option>|#<imm>"
          ]
        }
      },
      "DRPS": {
        "authored": null,
        "heading": "DRPS",
        "templates": {
          "DRPS_64E_BRANCH_REG": [
            "DRPS"
          ]
        }
      },
      "DSB": {
        "authored": "Data Synchronization Barrier is a memory barrier that ensures the completion of\nmemory accesses, see Data Synchronization Barrier.",
        "heading": "DSB",
        "templates": {
          "DSB_BO_BARRIERS": [
            "DSB  <option>|#<imm>"
          ]
        }
      },
      "DVP_SYS": {
        "authored": "Data Value Prediction Restriction by Context prevents data value predictions,\nbased on information gathered from earlier execution within an particular\nexecution context, from allowing later speculative execution within that context\nto be observable through side-channels.\n\nFor more information, see DVP RCTX, Data Value Prediction Restriction by\nContext.",
        "heading": "DVP",
        "templates": {
          "SYS_CR_SYSTEMINSTRS": [
            "DVP  RCTX, <Xt>"
          ]
        }
      },
      "EON": {
        "authored": "Bitwise Exclusive OR NOT (shifted register) performs a bitwise Exclusive OR NOT\nof a register value and an optionally-shifted register value, and writes the\nresult to the destination register.",
        "heading": "EON (shifted register)",
        "templates": {
          "NO_S": [
            "EON  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "EON  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "EOR_log_imm": {
        "authored": "Bitwise Exclusive OR (immediate) performs a bitwise Exclusive OR of a register\nvalue and an immediate value, and writes the result to the destination register.",
        "heading": "EOR (immediate)",
        "templates": {
          "NO_S": [
            "EOR  <Wd|WSP>, <Wn>, #<imm>",
            "EOR  <Xd|SP>, <Xn>, #<imm>"
          ]
        }
      },
      "EOR_log_shift": {
        "authored": "Bitwise Exclusive OR (shifted register) performs a bitwise Exclusive OR of a\nregister value and an optionally-shifted register value, and writes the result\nto the destination register.",
        "heading": "EOR (shifted register)",
        "templates": {
          "GENERAL": [
            "EOR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "EOR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "ERET": {
        "authored": "Exception Return using the ELR and SPSR for the current Exception level. When\nexecuted, the PE restores PSTATE from the SPSR, and branches to the address held\nin the ELR.\n\nThe PE checks the SPSR for the current Exception level for an illegal return\nevent. See Illegal return events from AArch64 state.\n\nERET is undefined at EL0.",
        "heading": "ERET",
        "templates": {
          "ERET_64E_BRANCH_REG": [
            "ERET"
          ]
        }
      },
      "ERETA": {
        "authored": "Exception Return, with pointer authentication. This instruction authenticates\nthe address in ELR, using SP as the modifier and the specified key, the PE\nrestores PSTATE from the SPSR for the current Exception level, and branches to\nthe authenticated address.\n\nKey A is used for ERETAA, and key B is used for ERETAB.\n\nIf the authentication passes, the PE continues execution at the target of the\nbranch. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to ELR.\n\nThe PE checks the SPSR for the current Exception level for an illegal return\nevent. See Illegal return events from AArch64 state.\n\nERETAA and ERETAB are undefined at EL0.",
        "heading": "ERETAA, ERETAB",
        "templates": {
          "GENERAL": [
            "ERETAA",
            "ERETAB"
          ]
        }
      },
      "ESB": {
        "authored": "Error Synchronization Barrier is an error synchronization event that might also\nupdate DISR_EL1 and VDISR_EL2.\n\nThis instruction can be used at all Exception levels and in Debug state.\n\nIn Debug state, this instruction behaves as if SError interrupts are masked at\nall Exception levels. See Error Synchronization Barrier in the Arm(R)\nReliability, Availability, and Serviceability (RAS) Specification, Armv8, for\nArmv8-A architecture profile.\n\nIf the RAS Extension is not implemented, this instruction executes as a NOP.",
        "heading": "ESB",
        "templates": {
          "ESB_HI_HINTS": [
            "ESB"
          ]
        }
      },
      "EXTR": {
        "authored": "Extract register extracts a register from a pair of registers.",
        "heading": "EXTR",
        "templates": {
          "GENERAL": [
            "EXTR  <Wd>, <Wn>, <Wm>, #<lsb>",
            "EXTR  <Xd>, <Xn>, <Xm>, #<lsb>"
          ]
        }
      },
      "GMI": {
        "authored": "Tag Mask Insert inserts the tag in the first source register into the excluded\nset specified in the second source register, writing the new excluded set to the\ndestination register.",
        "heading": "GMI",
        "templates": {
          "GMI_64G_DP_2SRC": [
            "GMI  <Xd>, <Xn|SP>, <Xm>"
          ]
        }
      },
      "HINT": {
        "authored": "Hint instruction is for the instruction set space that is reserved for\narchitectural hint instructions.\n\nSome encodings described here are not allocated in this revision of the\narchitecture, and behave as NOPs. These encodings might be allocated to other\nhint functionality in future revisions of the architecture and therefore must\nnot be used by software.",
        "heading": "HINT",
        "templates": {
          "HINT_HM_HINTS": [
            "HINT  #<imm>"
          ]
        }
      },
      "HLT": {
        "authored": "Halt instruction. A HLTinstruction can generate a Halt Instruction debug event,\nwhich causes entry into Debug state.",
        "heading": "HLT",
        "templates": {
          "HLT_EX_EXCEPTION": [
            "HLT  #<imm>"
          ]
        }
      },
      "HVC": {
        "authored": "Hypervisor Call causes an exception to EL2. Non-secure software executing at EL1\ncan use this instruction to call the hypervisor to request a service.\n\nThe HVC instruction is undefined:\n  - At EL0.\n  - At EL1 if EL2 is not enabled in the current Security state.\n  - When SCR_EL3.HCE is set to 0.\n\nOn executing an HVC instruction, the PE records the exception as a Hypervisor\nCall exception in ESR_ELx, using the EC value 0x16, and the value of the\nimmediate argument.",
        "heading": "HVC",
        "templates": {
          "HVC_EX_EXCEPTION": [
            "HVC  #<imm>"
          ]
        }
      },
      "IC_SYS": {
        "authored": "Instruction Cache operation. For more information, see op0==0b01, cache\nmaintenance, TLB maintenance, and address translation instructions.",
        "heading": "IC",
        "templates": {
          "SYS_CR_SYSTEMINSTRS": [
            "IC  <ic_op>{, <Xt>}"
          ]
        }
      },
      "IRG": {
        "authored": "Insert Random Tag inserts a random Logical Address Tag into the address in the\nfirst source register, and writes the result to the destination register. Any\ntags specified in the optional second source register or in GCR_EL1.Exclude are\nexcluded from the selection of the random Logical Address Tag.",
        "heading": "IRG",
        "templates": {
          "IRG_64I_DP_2SRC": [
            "IRG  <Xd|SP>, <Xn|SP>{, <Xm>}"
          ]
        }
      },
      "ISB": {
        "authored": "Instruction Synchronization Barrier flushes the pipeline in the PE and is a\ncontext synchronization event. For more information, see Instruction\nSynchronization Barrier (ISB).",
        "heading": "ISB",
        "templates": {
          "ISB_BI_BARRIERS": [
            "ISB  {<option>|#<imm>}"
          ]
        }
      },
      "LDADD": {
        "authored": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or\n64-bit doubleword from memory, adds the value held in a register to it, and\nstores the result back to memory. The value initially loaded from memory is\nreturned in the destination register.\n  - If the destination register is not one of WZR or XZR, LDADDA and LDADDAL\nload from memory with acquire semantics.\n  - LDADDL and LDADDAL store to memory with release semantics.\n  - LDADD has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDADD, LDADDA, LDADDAL, LDADDL",
        "templates": {
          "GENERAL": [
            "LDADD  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADD  <Xs>, <Xt>, [<Xn|SP>]",
            "LDADDA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDADDAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDADDL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDADDB": {
        "authored": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds\nthe value held in a register to it, and stores the result back to memory. The\nvalue initially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDADDAB and LDADDALB load from\nmemory with acquire semantics.\n  - LDADDLB and LDADDALB store to memory with release semantics.\n  - LDADDB has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDADDB, LDADDAB, LDADDALB, LDADDLB",
        "templates": {
          "GENERAL": [
            "LDADDAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDADDH": {
        "authored": "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory,\nadds the value held in a register to it, and stores the result back to memory.\nThe value initially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDADDAH and LDADDALH load from\nmemory with acquire semantics.\n  - LDADDLH and LDADDALH store to memory with release semantics.\n  - LDADDH has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDADDH, LDADDAH, LDADDALH, LDADDLH",
        "templates": {
          "GENERAL": [
            "LDADDAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDADDLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDAPR": {
        "authored": "Load-Acquire RCpc Register derives an address from a base register value, loads\na 32-bit word or 64-bit doubleword from the derived address in memory, and\nwrites it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPR",
        "templates": {
          "GENERAL": [
            "LDAPR  <Wt>, [<Xn|SP> {,#0}]",
            "LDAPR  <Xt>, [<Xn|SP> {,#0}]"
          ]
        }
      },
      "LDAPRB": {
        "authored": "Load-Acquire RCpc Register Byte derives an address from a base register value,\nloads a byte from the derived address in memory, zero-extends it and writes it\nto a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPRB",
        "templates": {
          "LDAPRB_32L_MEMOP": [
            "LDAPRB  <Wt>, [<Xn|SP> {,#0}]"
          ]
        }
      },
      "LDAPRH": {
        "authored": "Load-Acquire RCpc Register Halfword derives an address from a base register\nvalue, loads a halfword from the derived address in memory, zero-extends it and\nwrites it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPRH",
        "templates": {
          "LDAPRH_32L_MEMOP": [
            "LDAPRH  <Wt>, [<Xn|SP> {,#0}]"
          ]
        }
      },
      "LDAPURB": {
        "authored": "Load-Acquire RCpc Register Byte (unscaled) calculates an address from a base\nregister and an immediate offset, loads a byte from memory, zero-extends it, and\nwrites it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPURB",
        "templates": {
          "LDAPURB_32_LDAPSTL_UNSCALED": [
            "LDAPURB  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDAPURH": {
        "authored": "Load-Acquire RCpc Register Halfword (unscaled) calculates an address from a base\nregister and an immediate offset, loads a halfword from memory, zero-extends it,\nand writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPURH",
        "templates": {
          "LDAPURH_32_LDAPSTL_UNSCALED": [
            "LDAPURH  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDAPURSB": {
        "authored": "Load-Acquire RCpc Register Signed Byte (unscaled) calculates an address from a\nbase register and an immediate offset, loads a signed byte from memory, sign-\nextends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPURSB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDAPURSB  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDAPURSB  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDAPURSH": {
        "authored": "Load-Acquire RCpc Register Signed Halfword (unscaled) calculates an address from\na base register and an immediate offset, loads a signed halfword from memory,\nsign-extends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPURSH",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDAPURSH  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDAPURSH  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDAPURSW": {
        "authored": "Load-Acquire RCpc Register Signed Word (unscaled) calculates an address from a\nbase register and an immediate offset, loads a signed word from memory, sign-\nextends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPURSW",
        "templates": {
          "LDAPURSW_64_LDAPSTL_UNSCALED": [
            "LDAPURSW  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDAPUR_gen": {
        "authored": "Load-Acquire RCpc Register (unscaled) calculates an address from a base register\nand an immediate offset, loads a 32-bit word or 64-bit doubleword from memory,\nzero-extends it, and writes it to a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release, except that:\n  - There is no ordering requirement, separate from the requirements of a Load-\nAcquirePC or a Store-Release, created by having a Store-Release followed by a\nLoad-AcquirePC instruction.\n  - The reading of a value written by a Store-Release by a Load-AcquirePC\ninstruction by the same observer does not make the write of the Store-Release\nglobally observed.\n\nThis difference in memory ordering is not described in the pseudocode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDAPUR",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDAPUR  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDAPUR  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDAR": {
        "authored": "Load-Acquire Register derives an address from a base register value, loads a\n32-bit word or 64-bit doubleword from memory, and writes it to a register. The\ninstruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release. For information about memory accesses, see Load/Store addressing\nmodes.\n\nFor this instruction, if the destination is WZR/ZXR, it is impossible for\nsoftware to observe the presence of the acquire semantic other than its effect\non the arrival at endpoints.",
        "heading": "LDAR",
        "templates": {
          "BASE_REGISTER": [
            "LDAR  <Wt>, [<Xn|SP>{,#0}]",
            "LDAR  <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDARB": {
        "authored": "Load-Acquire Register Byte derives an address from a base register value, loads\na byte from memory, zero-extends it and writes it to a register. The instruction\nalso has memory ordering semantics as described in Load-Acquire, Store-Release.\nFor information about memory accesses, see Load/Store addressing modes.\n\nFor this instruction, if the destination is WZR/ZXR, it is impossible for\nsoftware to observe the presence of the acquire semantic other than its effect\non the arrival at endpoints.",
        "heading": "LDARB",
        "templates": {
          "LDARB_LR32_LDSTEXCL": [
            "LDARB  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDARH": {
        "authored": "Load-Acquire Register Halfword derives an address from a base register value,\nloads a halfword from memory, zero-extends it, and writes it to a register. The\ninstruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release. For information about memory accesses, see Load/Store addressing\nmodes.\n\nFor this instruction, if the destination is WZR/ZXR, it is impossible for\nsoftware to observe the presence of the acquire semantic other than its effect\non the arrival at endpoints.",
        "heading": "LDARH",
        "templates": {
          "LDARH_LR32_LDSTEXCL": [
            "LDARH  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDAXP": {
        "authored": "Load-Acquire Exclusive Pair of Registers derives an address from a base register\nvalue, loads two 32-bit words or two 64-bit doublewords from memory, and writes\nthem to two registers. A 32-bit pair requires the address to be doubleword\naligned and is single-copy atomic at doubleword granularity. A 64-bit pair\nrequires the address to be quadword aligned and is single-copy atomic for each\ndoubleword at doubleword granularity. The PE marks the physical address being\naccessed as an exclusive access. This exclusive access mark is checked by Store\nExclusive instructions. See Synchronization and semaphores. The instruction also\nhas memory ordering semantics as described in Load-Acquire, Store-Release. For\ninformation about memory accesses see Load/Store addressing modes.",
        "heading": "LDAXP",
        "templates": {
          "BASE_REGISTER": [
            "LDAXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]",
            "LDAXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDAXR": {
        "authored": "Load-Acquire Exclusive Register derives an address from a base register value,\nloads a 32-bit word or 64-bit doubleword from memory, and writes it to a\nregister. The memory access is atomic. The PE marks the physical address being\naccessed as an exclusive access. This exclusive access mark is checked by Store\nExclusive instructions. See Synchronization and semaphores. The instruction also\nhas memory ordering semantics as described in Load-Acquire, Store-Release. For\ninformation about memory accesses see Load/Store addressing modes.",
        "heading": "LDAXR",
        "templates": {
          "BASE_REGISTER": [
            "LDAXR  <Wt>, [<Xn|SP>{,#0}]",
            "LDAXR  <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDAXRB": {
        "authored": "Load-Acquire Exclusive Register Byte derives an address from a base register\nvalue, loads a byte from memory, zero-extends it and writes it to a register.\nThe memory access is atomic. The PE marks the physical address being accessed as\nan exclusive access. This exclusive access mark is checked by Store Exclusive\ninstructions. See Synchronization and semaphores. The instruction also has\nmemory ordering semantics as described in Load-Acquire, Store-Release. For\ninformation about memory accesses see Load/Store addressing modes.",
        "heading": "LDAXRB",
        "templates": {
          "LDAXRB_LR32_LDSTEXCL": [
            "LDAXRB  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDAXRH": {
        "authored": "Load-Acquire Exclusive Register Halfword derives an address from a base register\nvalue, loads a halfword from memory, zero-extends it and writes it to a\nregister. The memory access is atomic. The PE marks the physical address being\naccessed as an exclusive access. This exclusive access mark is checked by Store\nExclusive instructions. See Synchronization and semaphores. The instruction also\nhas memory ordering semantics as described in Load-Acquire, Store-Release. For\ninformation about memory accesses see Load/Store addressing modes.",
        "heading": "LDAXRH",
        "templates": {
          "LDAXRH_LR32_LDSTEXCL": [
            "LDAXRH  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDCLR": {
        "authored": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word\nor 64-bit doubleword from memory, performs a bitwise AND with the complement of\nthe value held in a register on it, and stores the result back to memory. The\nvalue initially loaded from memory is returned in the destination register.\n  - If the destination register is not one of WZR or XZR, LDCLRA and LDCLRAL\nload from memory with acquire semantics.\n  - LDCLRL and LDCLRAL store to memory with release semantics.\n  - LDCLR has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDCLR, LDCLRA, LDCLRAL, LDCLRL",
        "templates": {
          "GENERAL": [
            "LDCLR  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLR  <Xs>, <Xt>, [<Xn|SP>]",
            "LDCLRA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDCLRAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDCLRL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDCLRB": {
        "authored": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory,\nperforms a bitwise AND with the complement of the value held in a register on\nit, and stores the result back to memory. The value initially loaded from memory\nis returned in the destination register.\n  - If the destination register is not WZR, LDCLRAB and LDCLRALB load from\nmemory with acquire semantics.\n  - LDCLRLB and LDCLRALB store to memory with release semantics.\n  - LDCLRB has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB",
        "templates": {
          "GENERAL": [
            "LDCLRAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDCLRH": {
        "authored": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from\nmemory, performs a bitwise AND with the complement of the value held in a\nregister on it, and stores the result back to memory. The value initially loaded\nfrom memory is returned in the destination register.\n  - If the destination register is not WZR, LDCLRAH and LDCLRALH load from\nmemory with acquire semantics.\n  - LDCLRLH and LDCLRALH store to memory with release semantics.\n  - LDCLRH has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH",
        "templates": {
          "GENERAL": [
            "LDCLRAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDCLRLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDEOR": {
        "authored": "Atomic exclusive OR on word or doubleword in memory atomically loads a 32-bit\nword or 64-bit doubleword from memory, performs an exclusive OR with the value\nheld in a register on it, and stores the result back to memory. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not one of WZR or XZR, LDEORA and LDEORAL\nload from memory with acquire semantics.\n  - LDEORL and LDEORAL store to memory with release semantics.\n  - LDEOR has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDEOR, LDEORA, LDEORAL, LDEORL",
        "templates": {
          "GENERAL": [
            "LDEOR  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEOR  <Xs>, <Xt>, [<Xn|SP>]",
            "LDEORA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDEORAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDEORL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDEORB": {
        "authored": "Atomic exclusive OR on byte in memory atomically loads an 8-bit byte from\nmemory, performs an exclusive OR with the value held in a register on it, and\nstores the result back to memory. The value initially loaded from memory is\nreturned in the destination register.\n  - If the destination register is not WZR, LDEORAB and LDEORALB load from\nmemory with acquire semantics.\n  - LDEORLB and LDEORALB store to memory with release semantics.\n  - LDEORB has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDEORB, LDEORAB, LDEORALB, LDEORLB",
        "templates": {
          "GENERAL": [
            "LDEORAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDEORH": {
        "authored": "Atomic exclusive OR on halfword in memory atomically loads a 16-bit halfword\nfrom memory, performs an exclusive OR with the value held in a register on it,\nand stores the result back to memory. The value initially loaded from memory is\nreturned in the destination register.\n  - If the destination register is not WZR, LDEORAH and LDEORALH load from\nmemory with acquire semantics.\n  - LDEORLH and LDEORALH store to memory with release semantics.\n  - LDEORH has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDEORH, LDEORAH, LDEORALH, LDEORLH",
        "templates": {
          "GENERAL": [
            "LDEORAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDEORLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDG": {
        "authored": "Load Allocation Tag loads an Allocation Tag from a memory address, generates a\nLogical Address Tag from the Allocation Tag and merges it into the destination\nregister. The address used for the load is calculated from the base register and\nan immediate signed offset scaled by the Tag granule.",
        "heading": "LDG",
        "templates": {
          "LDG_64LOFFSET_LDSTTAGS": [
            "LDG  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDGM": {
        "authored": "Load Tag Multiple reads a naturally aligned block of N Allocation Tags, where\nthe size of N is identified in GMID_EL1.BS, and writes the Allocation Tag read\nfrom address A to the destination register at 4*A<7:4>+3:4*A<7:4>. Bits of the\ndestination register not written with an Allocation Tag are set to 0.\n\nThis instruction is undefined at EL0.\n\nThis instruction generates an Unchecked access.\n\nIf ID_AA64PFR1_EL1.MTE != 0b0010, this instruction is undefined.",
        "heading": "LDGM",
        "templates": {
          "LDGM_64BULK_LDSTTAGS": [
            "LDGM  <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDLAR": {
        "authored": "Load LOAcquire Register loads a 32-bit word or 64-bit doubleword from memory,\nand writes it to a register. The instruction also has memory ordering semantics\nas described in Load LOAcquire, Store LORelease. For information about memory\naccesses, see Load/Store addressing modes.\n\nFor this instruction, if the destination is WZR/ZXR, it is impossible for\nsoftware to observe the presence of the acquire semantic other than its effect\non the arrival at endpoints.",
        "heading": "LDLAR",
        "templates": {
          "BASE_REGISTER": [
            "LDLAR  <Wt>, [<Xn|SP>{,#0}]",
            "LDLAR  <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDLARB": {
        "authored": "Load LOAcquire Register Byte loads a byte from memory, zero-extends it and\nwrites it to a register. The instruction also has memory ordering semantics as\ndescribed in Load LOAcquire, Store LORelease. For information about memory\naccesses, see Load/Store addressing modes.\n\nFor this instruction, if the destination is WZR/ZXR, it is impossible for\nsoftware to observe the presence of the acquire semantic other than its effect\non the arrival at endpoints.",
        "heading": "LDLARB",
        "templates": {
          "LDLARB_LR32_LDSTEXCL": [
            "LDLARB  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDLARH": {
        "authored": "Load LOAcquire Register Halfword loads a halfword from memory, zero-extends it,\nand writes it to a register. The instruction also has memory ordering semantics\nas described in Load LOAcquire, Store LORelease. For information about memory\naccesses, see Load/Store addressing modes.\n\nFor this instruction, if the destination is WZR/ZXR, it is impossible for\nsoftware to observe the presence of the acquire semantic other than its effect\non the arrival at endpoints.",
        "heading": "LDLARH",
        "templates": {
          "LDLARH_LR32_LDSTEXCL": [
            "LDLARH  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDNP_gen": {
        "authored": "Load Pair of Registers, with non-temporal hint, calculates an address from a\nbase register value and an immediate offset, loads two 32-bit words or two\n64-bit doublewords from memory, and writes them to two registers.\n\nFor information about memory accesses, see Load/Store addressing modes. For\ninformation about Non-temporal pair instructions, see Load/Store Non-temporal\npair.",
        "heading": "LDNP",
        "templates": {
          "SIGNED_SCALED_OFFSET": [
            "LDNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]",
            "LDNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "LDPSW": {
        "authored": "Load Pair of Registers Signed Word calculates an address from a base register\nvalue and an immediate offset, loads two 32-bit words from memory, sign-extends\nthem, and writes them to two registers. For information about memory accesses,\nsee Load/Store addressing modes.",
        "heading": "LDPSW",
        "templates": {
          "LDPSW_64_LDSTPAIR_OFF": [
            "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          ],
          "LDPSW_64_LDSTPAIR_POST": [
            "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
          ],
          "LDPSW_64_LDSTPAIR_PRE": [
            "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
          ]
        }
      },
      "LDP_gen": {
        "authored": "Load Pair of Registers calculates an address from a base register value and an\nimmediate offset, loads two 32-bit words or two 64-bit doublewords from memory,\nand writes them to two registers. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "LDP",
        "templates": {
          "POST_INDEXED": [
            "LDP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>",
            "LDP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
          ],
          "PRE_INDEXED": [
            "LDP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!",
            "LDP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "LDP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]",
            "LDP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "LDRA": {
        "authored": "Load Register, with pointer authentication. This instruction authenticates an\naddress from a base register using a modifier of zero and the specified key,\nadds an immediate offset to the authenticated address, and loads a 64-bit\ndoubleword from memory at this resulting address into a register.\n\nKey A is used for LDRAA, and key B is used for LDRAB.\n\nIf the authentication passes, the PE behaves the same as for an LDR instruction.\nIf the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to the base register, unless the\npre-indexed variant of the instruction is used. In this case, the address that\nis written back to the base register does not include the pointer authentication\ncode.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDRAA, LDRAB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]",
            "LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]!",
            "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]",
            "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]!"
          ]
        }
      },
      "LDRB_imm": {
        "authored": "Load Register Byte (immediate) loads a byte from memory, zero-extends it, and\nwrites the result to a register. The address that is used for the load is\ncalculated from a base register and an immediate offset. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDRB (immediate)",
        "templates": {
          "LDRB_32_LDST_IMMPOST": [
            "LDRB  <Wt>, [<Xn|SP>], #<simm>"
          ],
          "LDRB_32_LDST_IMMPRE": [
            "LDRB  <Wt>, [<Xn|SP>, #<simm>]!"
          ],
          "LDRB_32_LDST_POS": [
            "LDRB  <Wt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDRB_reg": {
        "authored": "Load Register Byte (register) calculates an address from a base register value\nand an offset register value, loads a byte from memory, zero-extends it, and\nwrites it to a register. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "LDRB (register)",
        "templates": {
          "32": [
            "LDRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]",
            "LDRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
          ]
        }
      },
      "LDRH_imm": {
        "authored": "Load Register Halfword (immediate) loads a halfword from memory, zero-extends\nit, and writes the result to a register. The address that is used for the load\nis calculated from a base register and an immediate offset. For information\nabout memory accesses, see Load/Store addressing modes.",
        "heading": "LDRH (immediate)",
        "templates": {
          "LDRH_32_LDST_IMMPOST": [
            "LDRH  <Wt>, [<Xn|SP>], #<simm>"
          ],
          "LDRH_32_LDST_IMMPRE": [
            "LDRH  <Wt>, [<Xn|SP>, #<simm>]!"
          ],
          "LDRH_32_LDST_POS": [
            "LDRH  <Wt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDRH_reg": {
        "authored": "Load Register Halfword (register) calculates an address from a base register\nvalue and an offset register value, loads a halfword from memory, zero-extends\nit, and writes it to a register. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "LDRH (register)",
        "templates": {
          "LDRH_32_LDST_REGOFF": [
            "LDRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "LDRSB_imm": {
        "authored": "Load Register Signed Byte (immediate) loads a byte from memory, sign-extends it\nto either 32 bits or 64 bits, and writes the result to a register. The address\nthat is used for the load is calculated from a base register and an immediate\noffset. For information about memory accesses, see Load/Store addressing modes.",
        "heading": "LDRSB (immediate)",
        "templates": {
          "POST_INDEXED": [
            "LDRSB  <Wt>, [<Xn|SP>], #<simm>",
            "LDRSB  <Xt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "LDRSB  <Wt>, [<Xn|SP>, #<simm>]!",
            "LDRSB  <Xt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "LDRSB  <Wt>, [<Xn|SP>{, #<pimm>}]",
            "LDRSB  <Xt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDRSB_reg": {
        "authored": "Load Register Signed Byte (register) calculates an address from a base register\nvalue and an offset register value, loads a byte from memory, sign-extends it,\nand writes it to a register. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "LDRSB (register)",
        "templates": {
          "GENERAL": [
            "LDRSB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]",
            "LDRSB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]",
            "LDRSB  <Xt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]",
            "LDRSB  <Xt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
          ]
        }
      },
      "LDRSH_imm": {
        "authored": "Load Register Signed Halfword (immediate) loads a halfword from memory, sign-\nextends it to 32 bits or 64 bits, and writes the result to a register. The\naddress that is used for the load is calculated from a base register and an\nimmediate offset. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "LDRSH (immediate)",
        "templates": {
          "POST_INDEXED": [
            "LDRSH  <Wt>, [<Xn|SP>], #<simm>",
            "LDRSH  <Xt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "LDRSH  <Wt>, [<Xn|SP>, #<simm>]!",
            "LDRSH  <Xt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "LDRSH  <Wt>, [<Xn|SP>{, #<pimm>}]",
            "LDRSH  <Xt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDRSH_reg": {
        "authored": "Load Register Signed Halfword (register) calculates an address from a base\nregister value and an offset register value, loads a halfword from memory, sign-\nextends it, and writes it to a register. For information about memory accesses\nsee Load/Store addressing modes.",
        "heading": "LDRSH (register)",
        "templates": {
          "GENERAL": [
            "LDRSH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "LDRSH  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "LDRSW_imm": {
        "authored": "Load Register Signed Word (immediate) loads a word from memory, sign-extends it\nto 64 bits, and writes the result to a register. The address that is used for\nthe load is calculated from a base register and an immediate offset. For\ninformation about memory accesses, see Load/Store addressing modes.",
        "heading": "LDRSW (immediate)",
        "templates": {
          "LDRSW_64_LDST_IMMPOST": [
            "LDRSW  <Xt>, [<Xn|SP>], #<simm>"
          ],
          "LDRSW_64_LDST_IMMPRE": [
            "LDRSW  <Xt>, [<Xn|SP>, #<simm>]!"
          ],
          "LDRSW_64_LDST_POS": [
            "LDRSW  <Xt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDRSW_lit": {
        "authored": "Load Register Signed Word (literal) calculates an address from the PC value and\nan immediate offset, loads a word from memory, and writes it to a register. For\ninformation about memory accesses, see Load/Store addressing modes.",
        "heading": "LDRSW (literal)",
        "templates": {
          "LDRSW_64_LOADLIT": [
            "LDRSW  <Xt>, <label>"
          ]
        }
      },
      "LDRSW_reg": {
        "authored": "Load Register Signed Word (register) calculates an address from a base register\nvalue and an offset register value, loads a word from memory, sign-extends it to\nform a 64-bit value, and writes it to a register. The offset register value can\nbe shifted left by 0 or 2 bits. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "LDRSW (register)",
        "templates": {
          "LDRSW_64_LDST_REGOFF": [
            "LDRSW  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "LDR_imm_gen": {
        "authored": "Load Register (immediate) loads a word or doubleword from memory and writes it\nto a register. The address that is used for the load is calculated from a base\nregister and an immediate offset. For information about memory accesses, see\nLoad/Store addressing modes. The Unsigned offset variant scales the immediate\noffset value by the size of the value accessed before adding it to the base\nregister value.",
        "heading": "LDR (immediate)",
        "templates": {
          "POST_INDEXED": [
            "LDR  <Wt>, [<Xn|SP>], #<simm>",
            "LDR  <Xt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "LDR  <Wt>, [<Xn|SP>, #<simm>]!",
            "LDR  <Xt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "LDR  <Wt>, [<Xn|SP>{, #<pimm>}]",
            "LDR  <Xt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDR_lit_gen": {
        "authored": "Load Register (literal) calculates an address from the PC value and an immediate\noffset, loads a word from memory, and writes it to a register. For information\nabout memory accesses, see Load/Store addressing modes.",
        "heading": "LDR (literal)",
        "templates": {
          "LITERAL": [
            "LDR  <Wt>, <label>",
            "LDR  <Xt>, <label>"
          ]
        }
      },
      "LDR_reg_gen": {
        "authored": "Load Register (register) calculates an address from a base register value and an\noffset register value, loads a word from memory, and writes it to a register.\nThe offset register value can optionally be shifted and extended. For\ninformation about memory accesses, see Load/Store addressing modes.",
        "heading": "LDR (register)",
        "templates": {
          "GENERAL": [
            "LDR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "LDR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "LDSET": {
        "authored": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or\n64-bit doubleword from memory, performs a bitwise OR with the value held in a\nregister on it, and stores the result back to memory. The value initially loaded\nfrom memory is returned in the destination register.\n  - If the destination register is not one of WZR or XZR, LDSETA and LDSETAL\nload from memory with acquire semantics.\n  - LDSETL and LDSETAL store to memory with release semantics.\n  - LDSET has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSET, LDSETA, LDSETAL, LDSETL",
        "templates": {
          "GENERAL": [
            "LDSET  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSET  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSETA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSETAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSETL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSETB": {
        "authored": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory,\nperforms a bitwise OR with the value held in a register on it, and stores the\nresult back to memory. The value initially loaded from memory is returned in the\ndestination register.\n  - If the destination register is not WZR, LDSETAB and LDSETALB load from\nmemory with acquire semantics.\n  - LDSETLB and LDSETALB store to memory with release semantics.\n  - LDSETB has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSETB, LDSETAB, LDSETALB, LDSETLB",
        "templates": {
          "GENERAL": [
            "LDSETAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSETH": {
        "authored": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from\nmemory, performs a bitwise OR with the value held in a register on it, and\nstores the result back to memory. The value initially loaded from memory is\nreturned in the destination register.\n  - If the destination register is not WZR, LDSETAH and LDSETALH load from\nmemory with acquire semantics.\n  - LDSETLH and LDSETALH store to memory with release semantics.\n  - LDSETH has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSETH, LDSETAH, LDSETALH, LDSETLH",
        "templates": {
          "GENERAL": [
            "LDSETAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSETLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSMAX": {
        "authored": "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit\nword or 64-bit doubleword from memory, compares it against the value held in a\nregister, and stores the larger value back to memory, treating the values as\nsigned numbers. The value initially loaded from memory is returned in the\ndestination register.\n  - If the destination register is not one of WZR or XZR, LDSMAXA and LDSMAXAL\nload from memory with acquire semantics.\n  - LDSMAXL and LDSMAXAL store to memory with release semantics.\n  - LDSMAX has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL",
        "templates": {
          "GENERAL": [
            "LDSMAX  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAX  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSMAXA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSMAXAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSMAXL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSMAXB": {
        "authored": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from\nmemory, compares it against the value held in a register, and stores the larger\nvalue back to memory, treating the values as signed numbers. The value initially\nloaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDSMAXAB and LDSMAXALB load from\nmemory with acquire semantics.\n  - LDSMAXLB and LDSMAXALB store to memory with release semantics.\n  - LDSMAXB has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB",
        "templates": {
          "GENERAL": [
            "LDSMAXAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSMAXH": {
        "authored": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword\nfrom memory, compares it against the value held in a register, and stores the\nlarger value back to memory, treating the values as signed numbers. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDSMAXAH and LDSMAXALH load from\nmemory with acquire semantics.\n  - LDSMAXLH and LDSMAXALH store to memory with release semantics.\n  - LDSMAXH has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH",
        "templates": {
          "GENERAL": [
            "LDSMAXAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMAXLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSMIN": {
        "authored": "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit\nword or 64-bit doubleword from memory, compares it against the value held in a\nregister, and stores the smaller value back to memory, treating the values as\nsigned numbers. The value initially loaded from memory is returned in the\ndestination register.\n  - If the destination register is not one of WZR or XZR, LDSMINA and LDSMINAL\nload from memory with acquire semantics.\n  - LDSMINL and LDSMINAL store to memory with release semantics.\n  - LDSMIN has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSMIN, LDSMINA, LDSMINAL, LDSMINL",
        "templates": {
          "GENERAL": [
            "LDSMIN  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMIN  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSMINA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSMINAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDSMINL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSMINB": {
        "authored": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from\nmemory, compares it against the value held in a register, and stores the smaller\nvalue back to memory, treating the values as signed numbers. The value initially\nloaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDSMINAB and LDSMINALB load from\nmemory with acquire semantics.\n  - LDSMINLB and LDSMINALB store to memory with release semantics.\n  - LDSMINB has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB",
        "templates": {
          "GENERAL": [
            "LDSMINAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDSMINH": {
        "authored": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword\nfrom memory, compares it against the value held in a register, and stores the\nsmaller value back to memory, treating the values as signed numbers. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDSMINAH and LDSMINALH load from\nmemory with acquire semantics.\n  - LDSMINLH and LDSMINALH store to memory with release semantics.\n  - LDSMINH has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH",
        "templates": {
          "GENERAL": [
            "LDSMINAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDSMINLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDTR": {
        "authored": "Load Register (unprivileged) loads a word or doubleword from memory, and writes\nit to a register. The address that is used for the load is calculated from a\nbase register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDTR",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDTR  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDTR  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDTRB": {
        "authored": "Load Register Byte (unprivileged) loads a byte from memory, zero-extends it, and\nwrites the result to a register. The address that is used for the load is\ncalculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDTRB",
        "templates": {
          "LDTRB_32_LDST_UNPRIV": [
            "LDTRB  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDTRH": {
        "authored": "Load Register Halfword (unprivileged) loads a halfword from memory, zero-extends\nit, and writes the result to a register. The address that is used for the load\nis calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDTRH",
        "templates": {
          "LDTRH_32_LDST_UNPRIV": [
            "LDTRH  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDTRSB": {
        "authored": "Load Register Signed Byte (unprivileged) loads a byte from memory, sign-extends\nit to 32 bits or 64 bits, and writes the result to a register. The address that\nis used for the load is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDTRSB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDTRSB  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDTRSB  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDTRSH": {
        "authored": "Load Register Signed Halfword (unprivileged) loads a halfword from memory, sign-\nextends it to 32 bits or 64 bits, and writes the result to a register. The\naddress that is used for the load is calculated from a base register and an\nimmediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDTRSH",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDTRSH  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDTRSH  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDTRSW": {
        "authored": "Load Register Signed Word (unprivileged) loads a word from memory, sign-extends\nit to 64 bits, and writes the result to a register. The address that is used for\nthe load is calculated from a base register and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "LDTRSW",
        "templates": {
          "LDTRSW_64_LDST_UNPRIV": [
            "LDTRSW  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDUMAX": {
        "authored": "Atomic unsigned maximum on word or doubleword in memory atomically loads a\n32-bit word or 64-bit doubleword from memory, compares it against the value held\nin a register, and stores the larger value back to memory, treating the values\nas unsigned numbers. The value initially loaded from memory is returned in the\ndestination register.\n  - If the destination register is not one of WZR or XZR, LDUMAXA and LDUMAXAL\nload from memory with acquire semantics.\n  - LDUMAXL and LDUMAXAL store to memory with release semantics.\n  - LDUMAX has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL",
        "templates": {
          "GENERAL": [
            "LDUMAX  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAX  <Xs>, <Xt>, [<Xn|SP>]",
            "LDUMAXA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDUMAXAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDUMAXL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDUMAXB": {
        "authored": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from\nmemory, compares it against the value held in a register, and stores the larger\nvalue back to memory, treating the values as unsigned numbers. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDUMAXAB and LDUMAXALB load from\nmemory with acquire semantics.\n  - LDUMAXLB and LDUMAXALB store to memory with release semantics.\n  - LDUMAXB has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB",
        "templates": {
          "GENERAL": [
            "LDUMAXAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDUMAXH": {
        "authored": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword\nfrom memory, compares it against the value held in a register, and stores the\nlarger value back to memory, treating the values as unsigned numbers. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDUMAXAH and LDUMAXALH load from\nmemory with acquire semantics.\n  - LDUMAXLH and LDUMAXALH store to memory with release semantics.\n  - LDUMAXH has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH",
        "templates": {
          "GENERAL": [
            "LDUMAXAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMAXLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDUMIN": {
        "authored": "Atomic unsigned minimum on word or doubleword in memory atomically loads a\n32-bit word or 64-bit doubleword from memory, compares it against the value held\nin a register, and stores the smaller value back to memory, treating the values\nas unsigned numbers. The value initially loaded from memory is returned in the\ndestination register.\n  - If the destination register is not one of WZR or XZR, LDUMINA and LDUMINAL\nload from memory with acquire semantics.\n  - LDUMINL and LDUMINAL store to memory with release semantics.\n  - LDUMIN has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDUMIN, LDUMINA, LDUMINAL, LDUMINL",
        "templates": {
          "GENERAL": [
            "LDUMIN  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINA  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINAL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINL  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMIN  <Xs>, <Xt>, [<Xn|SP>]",
            "LDUMINA  <Xs>, <Xt>, [<Xn|SP>]",
            "LDUMINAL  <Xs>, <Xt>, [<Xn|SP>]",
            "LDUMINL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "LDUMINB": {
        "authored": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from\nmemory, compares it against the value held in a register, and stores the smaller\nvalue back to memory, treating the values as unsigned numbers. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDUMINAB and LDUMINALB load from\nmemory with acquire semantics.\n  - LDUMINLB and LDUMINALB store to memory with release semantics.\n  - LDUMINB has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB",
        "templates": {
          "GENERAL": [
            "LDUMINAB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINALB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINB  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDUMINH": {
        "authored": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword\nfrom memory, compares it against the value held in a register, and stores the\nsmaller value back to memory, treating the values as unsigned numbers. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, LDUMINAH and LDUMINALH load from\nmemory with acquire semantics.\n  - LDUMINLH and LDUMINALH store to memory with release semantics.\n  - LDUMINH has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH",
        "templates": {
          "GENERAL": [
            "LDUMINAH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINALH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINH  <Ws>, <Wt>, [<Xn|SP>]",
            "LDUMINLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "LDURB": {
        "authored": "Load Register Byte (unscaled) calculates an address from a base register and an\nimmediate offset, loads a byte from memory, zero-extends it, and writes it to a\nregister. For information about memory accesses, see Load/Store addressing\nmodes.",
        "heading": "LDURB",
        "templates": {
          "LDURB_32_LDST_UNSCALED": [
            "LDURB  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDURH": {
        "authored": "Load Register Halfword (unscaled) calculates an address from a base register and\nan immediate offset, loads a halfword from memory, zero-extends it, and writes\nit to a register. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "LDURH",
        "templates": {
          "LDURH_32_LDST_UNSCALED": [
            "LDURH  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDURSB": {
        "authored": "Load Register Signed Byte (unscaled) calculates an address from a base register\nand an immediate offset, loads a signed byte from memory, sign-extends it, and\nwrites it to a register. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "LDURSB",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDURSB  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDURSB  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDURSH": {
        "authored": "Load Register Signed Halfword (unscaled) calculates an address from a base\nregister and an immediate offset, loads a signed halfword from memory, sign-\nextends it, and writes it to a register. For information about memory accesses,\nsee Load/Store addressing modes.",
        "heading": "LDURSH",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDURSH  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDURSH  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDURSW": {
        "authored": "Load Register Signed Word (unscaled) calculates an address from a base register\nand an immediate offset, loads a signed word from memory, sign-extends it, and\nwrites it to a register. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "LDURSW",
        "templates": {
          "LDURSW_64_LDST_UNSCALED": [
            "LDURSW  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDUR_gen": {
        "authored": "Load Register (unscaled) calculates an address from a base register and an\nimmediate offset, loads a 32-bit word or 64-bit doubleword from memory, zero-\nextends it, and writes it to a register. For information about memory accesses,\nsee Load/Store addressing modes.",
        "heading": "LDUR",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDUR  <Wt>, [<Xn|SP>{, #<simm>}]",
            "LDUR  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "LDXP": {
        "authored": "Load Exclusive Pair of Registers derives an address from a base register value,\nloads two 32-bit words or two 64-bit doublewords from memory, and writes them to\ntwo registers. A 32-bit pair requires the address to be doubleword aligned and\nis single-copy atomic at doubleword granularity. A 64-bit pair requires the\naddress to be quadword aligned and is single-copy atomic for each doubleword at\ndoubleword granularity. The PE marks the physical address being accessed as an\nexclusive access. This exclusive access mark is checked by Store Exclusive\ninstructions. See Synchronization and semaphores. For information about memory\naccesses see Load/Store addressing modes.",
        "heading": "LDXP",
        "templates": {
          "BASE_REGISTER": [
            "LDXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]",
            "LDXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDXR": {
        "authored": "Load Exclusive Register derives an address from a base register value, loads a\n32-bit word or a 64-bit doubleword from memory, and writes it to a register. The\nmemory access is atomic. The PE marks the physical address being accessed as an\nexclusive access. This exclusive access mark is checked by Store Exclusive\ninstructions. See Synchronization and semaphores. For information about memory\naccesses see Load/Store addressing modes.",
        "heading": "LDXR",
        "templates": {
          "BASE_REGISTER": [
            "LDXR  <Wt>, [<Xn|SP>{,#0}]",
            "LDXR  <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDXRB": {
        "authored": "Load Exclusive Register Byte derives an address from a base register value,\nloads a byte from memory, zero-extends it and writes it to a register. The\nmemory access is atomic. The PE marks the physical address being accessed as an\nexclusive access. This exclusive access mark is checked by Store Exclusive\ninstructions. See Synchronization and semaphores. For information about memory\naccesses see Load/Store addressing modes.",
        "heading": "LDXRB",
        "templates": {
          "LDXRB_LR32_LDSTEXCL": [
            "LDXRB  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LDXRH": {
        "authored": "Load Exclusive Register Halfword derives an address from a base register value,\nloads a halfword from memory, zero-extends it and writes it to a register. The\nmemory access is atomic. The PE marks the physical address being accessed as an\nexclusive access. This exclusive access mark is checked by Store Exclusive\ninstructions. See Synchronization and semaphores. For information about memory\naccesses see Load/Store addressing modes.",
        "heading": "LDXRH",
        "templates": {
          "LDXRH_LR32_LDSTEXCL": [
            "LDXRH  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "LSLV": {
        "authored": "Logical Shift Left Variable shifts a register value left by a variable number of\nbits, shifting in zeros, and writes the result to the destination register. The\nremainder obtained by dividing the second source register by the data size\ndefines the number of bits by which the first source register is left-shifted.",
        "heading": "LSLV",
        "templates": {
          "GENERAL": [
            "LSLV  <Wd>, <Wn>, <Wm>",
            "LSLV  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "LSL_LSLV": {
        "authored": "Logical Shift Left (register) shifts a register value left by a variable number\nof bits, shifting in zeros, and writes the result to the destination register.\nThe remainder obtained by dividing the second source register by the data size\ndefines the number of bits by which the first source register is left-shifted.",
        "heading": "LSL (register)",
        "templates": {
          "GENERAL": [
            "LSL  <Wd>, <Wn>, <Wm>",
            "LSL  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "LSL_UBFM": {
        "authored": "Logical Shift Left (immediate) shifts a register value left by an immediate\nnumber of bits, shifting in zeros, and writes the result to the destination\nregister.",
        "heading": "LSL (immediate)",
        "templates": {
          "ZERO_FILL": [
            "LSL  <Wd>, <Wn>, #<shift>",
            "LSL  <Xd>, <Xn>, #<shift>"
          ]
        }
      },
      "LSRV": {
        "authored": "Logical Shift Right Variable shifts a register value right by a variable number\nof bits, shifting in zeros, and writes the result to the destination register.\nThe remainder obtained by dividing the second source register by the data size\ndefines the number of bits by which the first source register is right-shifted.",
        "heading": "LSRV",
        "templates": {
          "GENERAL": [
            "LSRV  <Wd>, <Wn>, <Wm>",
            "LSRV  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "LSR_LSRV": {
        "authored": "Logical Shift Right (register) shifts a register value right by a variable\nnumber of bits, shifting in zeros, and writes the result to the destination\nregister. The remainder obtained by dividing the second source register by the\ndata size defines the number of bits by which the first source register is\nright-shifted.",
        "heading": "LSR (register)",
        "templates": {
          "GENERAL": [
            "LSR  <Wd>, <Wn>, <Wm>",
            "LSR  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "LSR_UBFM": {
        "authored": "Logical Shift Right (immediate) shifts a register value right by an immediate\nnumber of bits, shifting in zeros, and writes the result to the destination\nregister.",
        "heading": "LSR (immediate)",
        "templates": {
          "ZERO_FILL": [
            "LSR  <Wd>, <Wn>, #<shift>",
            "LSR  <Xd>, <Xn>, #<shift>"
          ]
        }
      },
      "MADD": {
        "authored": "Multiply-Add multiplies two register values, adds a third register value, and\nwrites the result to the destination register.",
        "heading": "MADD",
        "templates": {
          "GENERAL": [
            "MADD  <Wd>, <Wn>, <Wm>, <Wa>",
            "MADD  <Xd>, <Xn>, <Xm>, <Xa>"
          ]
        }
      },
      "MNEG_MSUB": {
        "authored": "Multiply-Negate multiplies two register values, negates the product, and writes\nthe result to the destination register.",
        "heading": "MNEG",
        "templates": {
          "GENERAL": [
            "MNEG  <Wd>, <Wn>, <Wm>",
            "MNEG  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "MOVK": {
        "authored": "Move wide with keep moves an optionally-shifted 16-bit immediate value into a\nregister, keeping other bits unchanged.",
        "heading": "MOVK",
        "templates": {
          "IMM18_PACKED": [
            "MOVK  <Wd>, #<imm>{, LSL #<shift>}",
            "MOVK  <Xd>, #<imm>{, LSL #<shift>}"
          ]
        }
      },
      "MOVN": {
        "authored": "Move wide with NOT moves the inverse of an optionally-shifted 16-bit immediate\nvalue to a register.",
        "heading": "MOVN",
        "templates": {
          "IMM18_PACKED": [
            "MOVN  <Wd>, #<imm>{, LSL #<shift>}",
            "MOVN  <Xd>, #<imm>{, LSL #<shift>}"
          ]
        }
      },
      "MOVZ": {
        "authored": "Move wide with zero moves an optionally-shifted 16-bit immediate value to a\nregister.",
        "heading": "MOVZ",
        "templates": {
          "IMM18_PACKED": [
            "MOVZ  <Wd>, #<imm>{, LSL #<shift>}",
            "MOVZ  <Xd>, #<imm>{, LSL #<shift>}"
          ]
        }
      },
      "MOV_ADD_addsub_imm": {
        "authored": null,
        "heading": "MOV (to/from SP)",
        "templates": {
          "NO_S": [
            "MOV  <Wd|WSP>, <Wn|WSP>",
            "MOV  <Xd|SP>, <Xn|SP>"
          ]
        }
      },
      "MOV_MOVN": {
        "authored": "Move (inverted wide immediate) moves an inverted 16-bit immediate value to a\nregister.",
        "heading": "MOV (inverted wide immediate)",
        "templates": {
          "IMM18_PACKED": [
            "MOV  <Wd>, #<imm>",
            "MOV  <Xd>, #<imm>"
          ]
        }
      },
      "MOV_MOVZ": {
        "authored": "Move (wide immediate) moves a 16-bit immediate value to a register.",
        "heading": "MOV (wide immediate)",
        "templates": {
          "IMM18_PACKED": [
            "MOV  <Wd>, #<imm>",
            "MOV  <Xd>, #<imm>"
          ]
        }
      },
      "MOV_ORR_log_imm": {
        "authored": "Move (bitmask immediate) writes a bitmask immediate value to a register.",
        "heading": "MOV (bitmask immediate)",
        "templates": {
          "NO_S": [
            "MOV  <Wd|WSP>, #<imm>",
            "MOV  <Xd|SP>, #<imm>"
          ]
        }
      },
      "MOV_ORR_log_shift": {
        "authored": "Move (register) copies the value in a source register to the destination\nregister.",
        "heading": "MOV (register)",
        "templates": {
          "NO_S": [
            "MOV  <Wd>, <Wm>",
            "MOV  <Xd>, <Xm>"
          ]
        }
      },
      "MRS": {
        "authored": "Move System Register allows the PE to read an AArch64 System register into a\ngeneral-purpose register.",
        "heading": "MRS",
        "templates": {
          "MRS_RS_SYSTEMMOVE": [
            "MRS  <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)"
          ]
        }
      },
      "MSR_imm": {
        "authored": "Move immediate value to Special Register moves an immediate value to selected\nbits of the PSTATE. For more information, see Process state, PSTATE.\n\nThe bits that can be written by this instruction are:\n  - PSTATE.D, PSTATE.A, PSTATE.I, PSTATE.F, and PSTATE.SP.\n  - If ARMv8.0-SSBS is implemented, PSTATE.SSBS.\n  - If ARMv8.1-PAN is implemented, PSTATE.PAN.\n  - If ARMv8.2-UAO is implemented, PSTATE.UAO.\n  - If ARMv8.4-DIT is implemented, PSTATE.DIT.\n  - If ARMv8.5-MemTag is implemented, PSTATE.TCO.",
        "heading": "MSR (immediate)",
        "templates": {
          "MSR_SI_PSTATE": [
            "MSR  <pstatefield>, #<imm>"
          ]
        }
      },
      "MSR_reg": {
        "authored": "Move general-purpose register to System Register allows the PE to write an\nAArch64 System register from a general-purpose register.",
        "heading": "MSR (register)",
        "templates": {
          "MSR_SR_SYSTEMMOVE": [
            "MSR  (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>), <Xt>"
          ]
        }
      },
      "MSUB": {
        "authored": "Multiply-Subtract multiplies two register values, subtracts the product from a\nthird register value, and writes the result to the destination register.",
        "heading": "MSUB",
        "templates": {
          "GENERAL": [
            "MSUB  <Wd>, <Wn>, <Wm>, <Wa>",
            "MSUB  <Xd>, <Xn>, <Xm>, <Xa>"
          ]
        }
      },
      "MUL_MADD": {
        "authored": null,
        "heading": "MUL",
        "templates": {
          "GENERAL": [
            "MUL  <Wd>, <Wn>, <Wm>",
            "MUL  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "MVN_ORN_log_shift": {
        "authored": "Bitwise NOT writes the bitwise inverse of a register value to the destination\nregister.",
        "heading": "MVN",
        "templates": {
          "NO_S": [
            "MVN  <Wd>, <Wm>{, <shift> #<amount>}",
            "MVN  <Xd>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "NEGS_SUBS_addsub_shift": {
        "authored": "Negate, setting flags, negates an optionally-shifted register value, and writes\nthe result to the destination register. It updates the condition flags based on\nthe result.",
        "heading": "NEGS",
        "templates": {
          "S": [
            "NEGS  <Wd>, <Wm>{, <shift> #<amount>}",
            "NEGS  <Xd>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "NEG_SUB_addsub_shift": {
        "authored": "Negate (shifted register) negates an optionally-shifted register value, and\nwrites the result to the destination register.",
        "heading": "NEG (shifted register)",
        "templates": {
          "NO_S": [
            "NEG  <Wd>, <Wm>{, <shift> #<amount>}",
            "NEG  <Xd>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "NGCS_SBCS": {
        "authored": "Negate with Carry, setting flags, negates the sum of a register value and the\nvalue of NOT (Carry flag), and writes the result to the destination register. It\nupdates the condition flags based on the result.",
        "heading": "NGCS",
        "templates": {
          "S": [
            "NGCS  <Wd>, <Wm>",
            "NGCS  <Xd>, <Xm>"
          ]
        }
      },
      "NGC_SBC": {
        "authored": "Negate with Carry negates the sum of a register value and the value of NOT\n(Carry flag), and writes the result to the destination register.",
        "heading": "NGC",
        "templates": {
          "NO_S": [
            "NGC  <Wd>, <Wm>",
            "NGC  <Xd>, <Xm>"
          ]
        }
      },
      "NOP": {
        "authored": "No Operation does nothing, other than advance the value of the program counter\nby 4. This instruction can be used for instruction alignment purposes.\n\nThe timing effects of including a NOP instruction in a program are not\nguaranteed. It can increase execution time, leave it unchanged, or even reduce\nit. Therefore, NOP instructions are not suitable for timing loops.",
        "heading": "NOP",
        "templates": {
          "NOP_HI_HINTS": [
            "NOP"
          ]
        }
      },
      "ORN_log_shift": {
        "authored": "Bitwise OR NOT (shifted register) performs a bitwise (inclusive) OR of a\nregister value and the complement of an optionally-shifted register value, and\nwrites the result to the destination register.",
        "heading": "ORN (shifted register)",
        "templates": {
          "NO_S": [
            "ORN  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "ORN  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "ORR_log_imm": {
        "authored": "Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value and\nan immediate register value, and writes the result to the destination register.",
        "heading": "ORR (immediate)",
        "templates": {
          "NO_S": [
            "ORR  <Wd|WSP>, <Wn>, #<imm>",
            "ORR  <Xd|SP>, <Xn>, #<imm>"
          ]
        }
      },
      "ORR_log_shift": {
        "authored": "Bitwise OR (shifted register) performs a bitwise (inclusive) OR of a register\nvalue and an optionally-shifted register value, and writes the result to the\ndestination register.",
        "heading": "ORR (shifted register)",
        "templates": {
          "NO_S": [
            "ORR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "ORR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "PACDA": {
        "authored": "Pointer Authentication Code for Data address, using key A. This instruction\ncomputes and inserts a pointer authentication code for a data address, using a\nmodifier and key A.\n\nThe address is in the general-purpose register that is specified by <Xd>.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for PACDA.\n  - The value zero, for PACDZA.",
        "heading": "PACDA, PACDZA",
        "templates": {
          "GENERAL": [
            "PACDA  <Xd>, <Xn|SP>",
            "PACDZA  <Xd>"
          ]
        }
      },
      "PACDB": {
        "authored": "Pointer Authentication Code for Data address, using key B. This instruction\ncomputes and inserts a pointer authentication code for a data address, using a\nmodifier and key B.\n\nThe address is in the general-purpose register that is specified by <Xd>.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for PACDB.\n  - The value zero, for PACDZB.",
        "heading": "PACDB, PACDZB",
        "templates": {
          "GENERAL": [
            "PACDB  <Xd>, <Xn|SP>",
            "PACDZB  <Xd>"
          ]
        }
      },
      "PACGA": {
        "authored": "Pointer Authentication Code, using Generic key. This instruction computes the\npointer authentication code for an address in the first source register, using a\nmodifier in the second source register, and the Generic key. The computed\npointer authentication code is returned in the upper 32 bits of the destination\nregister.",
        "heading": "PACGA",
        "templates": {
          "PACGA_64P_DP_2SRC": [
            "PACGA  <Xd>, <Xn>, <Xm|SP>"
          ]
        }
      },
      "PACIA": {
        "authored": "Pointer Authentication Code for Instruction address, using key A. This\ninstruction computes and inserts a pointer authentication code for an\ninstruction address, using a modifier and key A.\n\nThe address is:\n  - In the general-purpose register that is specified by <Xd> for PACIA and\nPACIZA.\n  - In X17, for PACIA1716.\n  - In X30, for PACIASP and PACIAZ.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for PACIA.\n  - The value zero, for PACIZA and PACIAZ.\n  - In X16, for PACIA1716.\n  - In SP, for PACIASP.",
        "heading": "PACIA, PACIA1716, PACIASP, PACIAZ, PACIZA",
        "templates": {
          "GENERAL": [
            "PACIA  <Xd>, <Xn|SP>",
            "PACIZA  <Xd>"
          ],
          "SYSTEM": [
            "PACIA1716",
            "PACIASP",
            "PACIAZ"
          ]
        }
      },
      "PACIB": {
        "authored": "Pointer Authentication Code for Instruction address, using key B. This\ninstruction computes and inserts a pointer authentication code for an\ninstruction address, using a modifier and key B.\n\nThe address is:\n  - In the general-purpose register that is specified by <Xd> for PACIB and\nPACIZB.\n  - In X17, for PACIB1716.\n  - In X30, for PACIBSP and PACIBZ.\n\nThe modifier is:\n  - In the general-purpose register or stack pointer that is specified by\n<Xn|SP> for PACIB.\n  - The value zero, for PACIZB and PACIBZ.\n  - In X16, for PACIB1716.\n  - In SP, for PACIBSP.",
        "heading": "PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZB",
        "templates": {
          "GENERAL": [
            "PACIB  <Xd>, <Xn|SP>",
            "PACIZB  <Xd>"
          ],
          "SYSTEM": [
            "PACIB1716",
            "PACIBSP",
            "PACIBZ"
          ]
        }
      },
      "PRFM_imm": {
        "authored": "Prefetch Memory (immediate) signals the memory system that data memory accesses\nfrom a specified address are likely to occur in the near future. The memory\nsystem can respond by taking actions that are expected to speed up the memory\naccesses when they do occur, such as preloading the cache line containing the\nspecified address into one or more caches.\n\nThe effect of an PRFM instruction is implementation defined. For more\ninformation, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "PRFM (immediate)",
        "templates": {
          "PRFM_P_LDST_POS": [
            "PRFM  (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "PRFM_lit": {
        "authored": "Prefetch Memory (literal) signals the memory system that data memory accesses\nfrom a specified address are likely to occur in the near future. The memory\nsystem can respond by taking actions that are expected to speed up the memory\naccesses when they do occur, such as preloading the cache line containing the\nspecified address into one or more caches.\n\nThe effect of an PRFM instruction is implementation defined. For more\ninformation, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "PRFM (literal)",
        "templates": {
          "PRFM_P_LOADLIT": [
            "PRFM  (<prfop>|#<imm5>), <label>"
          ]
        }
      },
      "PRFM_reg": {
        "authored": "Prefetch Memory (register) signals the memory system that data memory accesses\nfrom a specified address are likely to occur in the near future. The memory\nsystem can respond by taking actions that are expected to speed up the memory\naccesses when they do occur, such as preloading the cache line containing the\nspecified address into one or more caches.\n\nThe effect of an PRFM instruction is implementation defined. For more\ninformation, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "PRFM (register)",
        "templates": {
          "PRFM_P_LDST_REGOFF": [
            "PRFM  (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "PRFUM": {
        "authored": "Prefetch Memory (unscaled offset) signals the memory system that data memory\naccesses from a specified address are likely to occur in the near future. The\nmemory system can respond by taking actions that are expected to speed up the\nmemory accesses when they do occur, such as preloading the cache line containing\nthe specified address into one or more caches.\n\nThe effect of an PRFUM instruction is implementation defined. For more\ninformation, see Prefetch memory.\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "PRFUM",
        "templates": {
          "PRFUM_P_LDST_UNSCALED": [
            "PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "PSB": {
        "authored": "Profiling Synchronization Barrier. This instruction is a barrier that ensures\nthat all existing profiling data for the current PE has been formatted, and\nprofiling buffer addresses have been translated such that all writes to the\nprofiling buffer have been initiated.  A following DSB instruction completes\nwhen the writes to the profiling buffer have completed.\n\nIf the Statistical Profiling Extension is not implemented, this instruction\nexecutes as a NOP.",
        "heading": "PSB CSYNC",
        "templates": {
          "PSB_HC_HINTS": [
            "PSB CSYNC"
          ]
        }
      },
      "PSSBB": {
        "authored": "Physical Speculative Store Bypass Barrier is a memory barrier which prevents\nspeculative loads from bypassing earlier stores to the same physical address.\n\nThe semantics of the Physical Speculative Store Bypass Barrier are:\n  - When a load to a location appears in program order after the PSSBB, then the\nload does not speculatively read an entry earlier in the coherence order for\nthat location than the entry generated by the latest store satisfying all of the\nfollowing conditions:\n    - The store is to the same location as the load.\n    - The store appears in program order before the PSSBB.\n  - When a load to a location appears in program order before the PSSBB, then\nthe load does not speculatively read data from any store satisfying all of the\nfollowing conditions:\n    - The store is to the same location as the load.\n    - The store appears in program order after the PSSBB.",
        "heading": "PSSBB",
        "templates": {
          "PSSBB_ONLY_BARRIERS": [
            "PSSBB"
          ]
        }
      },
      "RBIT_int": {
        "authored": "Reverse Bits reverses the bit order in a register.",
        "heading": "RBIT",
        "templates": {
          "GENERAL": [
            "RBIT  <Wd>, <Wn>",
            "RBIT  <Xd>, <Xn>"
          ]
        }
      },
      "RET": {
        "authored": "Return from subroutine branches unconditionally to an address in a register,\nwith a hint that this is a subroutine return.",
        "heading": "RET",
        "templates": {
          "RET_64R_BRANCH_REG": [
            "RET  {<Xn>}"
          ]
        }
      },
      "RETA": {
        "authored": "Return from subroutine, with pointer authentication. This instruction\nauthenticates the address that is held in LR, using SP as the modifier and the\nspecified key, branches to the authenticated address, with a hint that this\ninstruction is a subroutine return.\n\nKey A is used for RETAA, and key B is used for RETAB.\n\nIf the authentication passes, the PE continues execution at the target of the\nbranch. If the authentication fails, a Translation fault is generated.\n\nThe authenticated address is not written back to LR.",
        "heading": "RETAA, RETAB",
        "templates": {
          "GENERAL": [
            "RETAA",
            "RETAB"
          ]
        }
      },
      "REV": {
        "authored": "Reverse Bytes reverses the byte order in a register.",
        "heading": "REV",
        "templates": {
          "GENERAL": [
            "REV  <Wd>, <Wn>",
            "REV  <Xd>, <Xn>"
          ]
        }
      },
      "REV16_int": {
        "authored": "Reverse bytes in 16-bit halfwords reverses the byte order in each 16-bit\nhalfword of a register.",
        "heading": "REV16",
        "templates": {
          "GENERAL": [
            "REV16  <Wd>, <Wn>",
            "REV16  <Xd>, <Xn>"
          ]
        }
      },
      "REV32_int": {
        "authored": "Reverse bytes in 32-bit words reverses the byte order in each 32-bit word of a\nregister.",
        "heading": "REV32",
        "templates": {
          "REV32_64_DP_1SRC": [
            "REV32  <Xd>, <Xn>"
          ]
        }
      },
      "REV64_REV": {
        "authored": "Reverse Bytes reverses the byte order in a 64-bit general-purpose register.\n\nWhen assembling for Armv8.2, an assembler must support this pseudo-instruction.\nIt is optional whether an assembler supports this pseudo-instruction when\nassembling for an architecture earlier than Armv8.2.",
        "heading": "REV64",
        "templates": {
          "GENERAL": [
            "REV64  <Xd>, <Xn>"
          ]
        }
      },
      "RMIF": {
        "authored": "Performs a rotation right of a value held in a general purpose register by an\nimmediate value, and then inserts a selection of the bottom four bits of the\nresult of the rotation into the PSTATE flags, under the control of a second\nimmediate mask.",
        "heading": "RMIF",
        "templates": {
          "RMIF_ONLY_RMIF": [
            "RMIF  <Xn>, #<shift>, #<mask>"
          ]
        }
      },
      "RORV": {
        "authored": "Rotate Right Variable provides the value of the contents of a register rotated\nby a variable number of bits. The bits that are rotated off the right end are\ninserted into the vacated bit positions on the left. The remainder obtained by\ndividing the second source register by the data size defines the number of bits\nby which the first source register is right-shifted.",
        "heading": "RORV",
        "templates": {
          "GENERAL": [
            "RORV  <Wd>, <Wn>, <Wm>",
            "RORV  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "ROR_EXTR": {
        "authored": "Rotate right (immediate) provides the value of the contents of a register\nrotated by a variable number of bits. The bits that are rotated off the right\nend are inserted into the vacated bit positions on the left.",
        "heading": "ROR (immediate)",
        "templates": {
          "GENERAL": [
            "ROR  <Wd>, <Ws>, #<shift>",
            "ROR  <Xd>, <Xs>, #<shift>"
          ]
        }
      },
      "ROR_RORV": {
        "authored": "Rotate Right (register) provides the value of the contents of a register rotated\nby a variable number of bits. The bits that are rotated off the right end are\ninserted into the vacated bit positions on the left. The remainder obtained by\ndividing the second source register by the data size defines the number of bits\nby which the first source register is right-shifted.",
        "heading": "ROR (register)",
        "templates": {
          "GENERAL": [
            "ROR  <Wd>, <Wn>, <Wm>",
            "ROR  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "SB": {
        "authored": "Speculation Barrier is a barrier that controls speculation.\n\nThe semantics of the Speculation Barrier are that the execution, until the\nbarrier completes, of any instruction that appears later in the program order\nthan the barrier:\n  - Cannot be performed speculatively to the extent that such speculation can be\nobserved through side-channels as a result of control flow speculation or data\nvalue speculation.\n  - Can be speculatively executed as a result of predicting that a potentially\nexception generating instruction has not generated an exception.\n\nIn particular, any instruction that appears later in the program order than the\nbarrier cannot cause a speculative allocation into any caching structure where\nthe allocation of that entry could be indicative of any data value present in\nmemory or in the registers.\n\nThe SB instruction:\n  - Cannot be speculatively executed as a result of control flow speculation or\ndata value speculation.\n  - Can be speculatively executed as a result of predicting that a potentially\nexception generating instruction has not generated an exception. The potentially\nexception generating instruction can complete once it is known not to be\nspeculative, and all data values generated by instructions appearing in program\norder before the SB instruction have their predicted values confirmed.\n\nWhen the prediction of the instruction stream is not informed by data taken from\nthe register outputs of the speculative execution of instructions appearing in\nprogram order after an uncompleted SB instruction, the SB instruction has no\neffect on the use of prediction resources to predict the instruction stream that\nis being fetched.",
        "heading": "SB",
        "templates": {
          "SB_ONLY_BARRIERS": [
            "SB"
          ]
        }
      },
      "SBC": {
        "authored": "Subtract with Carry subtracts a register value and the value of NOT (Carry flag)\nfrom a register value, and writes the result to the destination register.",
        "heading": "SBC",
        "templates": {
          "NO_S": [
            "SBC  <Wd>, <Wn>, <Wm>",
            "SBC  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "SBCS": {
        "authored": "Subtract with Carry, setting flags, subtracts a register value and the value of\nNOT (Carry flag) from a register value, and writes the result to the destination\nregister. It updates the condition flags based on the result.",
        "heading": "SBCS",
        "templates": {
          "S": [
            "SBCS  <Wd>, <Wn>, <Wm>",
            "SBCS  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "SBFIZ_SBFM": {
        "authored": "Signed Bitfield Insert in Zeros copies a bitfield of <width> bits from the least\nsignificant bits of the source register to bit position <lsb> of the destination\nregister, setting the destination bits below the bitfield to zero, and the bits\nabove the bitfield to a copy of the most significant bit of the bitfield.",
        "heading": "SBFIZ",
        "templates": {
          "SIGNED_FILL": [
            "SBFIZ  <Wd>, <Wn>, #<lsb>, #<width>",
            "SBFIZ  <Xd>, <Xn>, #<lsb>, #<width>"
          ]
        }
      },
      "SBFM": {
        "authored": "Signed Bitfield Move is usually accessed via one of its aliases, which are\nalways preferred for disassembly.\n\nIf <imms> is greater than or equal to <immr>, this copies a bitfield of\n(<imms>-<immr>+1) bits starting from bit position <immr> in the source register\nto the least significant bits of the destination register.\n\nIf <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from\nthe least significant bits of the source register to bit position\n(regsize-<immr>) of the destination register, where regsize is the destination\nregister size of 32 or 64 bits.\n\nIn both cases the destination bits below the bitfield are set to zero, and the\nbits above the bitfield are set to a copy of the most significant bit of the\nbitfield.",
        "heading": "SBFM",
        "templates": {
          "SIGNED_FILL": [
            "SBFM  <Wd>, <Wn>, #<immr>, #<imms>",
            "SBFM  <Xd>, <Xn>, #<immr>, #<imms>"
          ]
        }
      },
      "SBFX_SBFM": {
        "authored": "Signed Bitfield Extract copies a bitfield of <width> bits starting from bit\nposition <lsb> in the source register to the least significant bits of the\ndestination register, and sets destination bits above the bitfield to a copy of\nthe most significant bit of the bitfield.",
        "heading": "SBFX",
        "templates": {
          "SIGNED_FILL": [
            "SBFX  <Wd>, <Wn>, #<lsb>, #<width>",
            "SBFX  <Xd>, <Xn>, #<lsb>, #<width>"
          ]
        }
      },
      "SDIV": {
        "authored": "Signed Divide divides a signed integer register value by another signed integer\nregister value, and writes the result to the destination register. The condition\nflags are not affected.",
        "heading": "SDIV",
        "templates": {
          "GENERAL": [
            "SDIV  <Wd>, <Wn>, <Wm>",
            "SDIV  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "SETF": {
        "authored": "Set the PSTATE.NZV flags based on the value in the specified general-purpose\nregister. SETF8 treats the value as an 8 bit value, and SETF16 treats the value\nas an 16 bit value.\n\nThe PSTATE.C flag is not affected by these instructions.",
        "heading": "SETF8, SETF16",
        "templates": {
          "GENERAL": [
            "SETF8  <Wn>",
            "SETF16  <Wn>"
          ]
        }
      },
      "SEV": {
        "authored": "Send Event is a hint instruction. It causes an event to be signaled to all PEs\nin the multiprocessor system. For more information, see Wait for Event mechanism\nand Send event.",
        "heading": "SEV",
        "templates": {
          "SEV_HI_HINTS": [
            "SEV"
          ]
        }
      },
      "SEVL": {
        "authored": "Send Event Local is a hint instruction that causes an event to be signaled\nlocally without requiring the event to be signaled to other PEs in the\nmultiprocessor system. It can prime a wait-loop which starts with a WFE\ninstruction.",
        "heading": "SEVL",
        "templates": {
          "SEVL_HI_HINTS": [
            "SEVL"
          ]
        }
      },
      "SMADDL": {
        "authored": "Signed Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit\nregister value, and writes the result to the 64-bit destination register.",
        "heading": "SMADDL",
        "templates": {
          "SMADDL_64WA_DP_3SRC": [
            "SMADDL  <Xd>, <Wn>, <Wm>, <Xa>"
          ]
        }
      },
      "SMC": {
        "authored": "Secure Monitor Call causes an exception to EL3.\n\nSMC is available only for software executing at EL1 or higher. It is undefined\nin EL0.\n\nIf the values of HCR_EL2.TSC and SCR_EL3.SMD are both 0, execution of an SMC\ninstruction at EL1 or higher generates a Secure Monitor Call exception,\nrecording it in ESR_ELx, using the EC value 0x17, that is taken to EL3.\n\nIf the value of HCR_EL2.TSC is 1 and EL2 is enabled in the current Security\nstate, execution of an SMC instruction at EL1 generates an exception that is\ntaken to EL2, regardless of the value of SCR_EL3.SMD. For more information, see\nTraps to EL2 of Non-secure EL1 execution of SMC instructions.\n\nIf the value of HCR_EL2.TSC is 0 and the value of SCR_EL3.SMD is 1, the SMC\ninstruction is undefined.",
        "heading": "SMC",
        "templates": {
          "SMC_EX_EXCEPTION": [
            "SMC  #<imm>"
          ]
        }
      },
      "SMNEGL_SMSUBL": {
        "authored": "Signed Multiply-Negate Long multiplies two 32-bit register values, negates the\nproduct, and writes the result to the 64-bit destination register.",
        "heading": "SMNEGL",
        "templates": {
          "SMSUBL_64WA_DP_3SRC": [
            "SMNEGL  <Xd>, <Wn>, <Wm>"
          ]
        }
      },
      "SMSUBL": {
        "authored": "Signed Multiply-Subtract Long multiplies two 32-bit register values, subtracts\nthe product from a 64-bit register value, and writes the result to the 64-bit\ndestination register.",
        "heading": "SMSUBL",
        "templates": {
          "SMSUBL_64WA_DP_3SRC": [
            "SMSUBL  <Xd>, <Wn>, <Wm>, <Xa>"
          ]
        }
      },
      "SMULH": {
        "authored": "Signed Multiply High multiplies two 64-bit register values, and writes\nbits[127:64] of the 128-bit result to the 64-bit destination register.",
        "heading": "SMULH",
        "templates": {
          "SMULH_64_DP_3SRC": [
            "SMULH  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "SMULL_SMADDL": {
        "authored": "Signed Multiply Long multiplies two 32-bit register values, and writes the\nresult to the 64-bit destination register.",
        "heading": "SMULL",
        "templates": {
          "SMADDL_64WA_DP_3SRC": [
            "SMULL  <Xd>, <Wn>, <Wm>"
          ]
        }
      },
      "SSBB": {
        "authored": "Speculative Store Bypass Barrier is a memory barrier which prevents speculative\nloads from bypassing earlier stores to the same virtual address under certain\nconditions.\n\nThe semantics of the Speculative Store Bypass Barrier are:\n  - When a load to a location appears in program order after the SSBB, then the\nload does not speculatively read an entry earlier in the coherence order for\nthat location than the entry generated by the latest store satisfying all of the\nfollowing conditions:\n    - The store is to the same location as the load.\n    - The store uses the same virtual address as the load.\n    - The store appears in program order before the SSBB.\n  - When a load to a location appears in program order before the SSBB, then the\nload does not speculatively read data from any store satisfying all of the\nfollowing conditions:\n    - The store is to the same location as the load.\n    - The store uses the same virtual address as the load.\n    - The store appears in program order after the SSBB.",
        "heading": "SSBB",
        "templates": {
          "SSBB_ONLY_BARRIERS": [
            "SSBB"
          ]
        }
      },
      "ST2G": {
        "authored": "Store Allocation Tags stores an Allocation Tag to two Tag granules of memory.\nThe address used for the store is calculated from the base register and an\nimmediate signed offset scaled by the Tag granule. The Allocation Tag is\ncalculated from the Logical Address Tag in the source register.\n\nThis instruction generates an Unchecked access.",
        "heading": "ST2G",
        "templates": {
          "ST2G_64SOFFSET_LDSTTAGS": [
            "ST2G  <Xt|SP>, [<Xn|SP>{, #<simm>}]"
          ],
          "ST2G_64SPOST_LDSTTAGS": [
            "ST2G  <Xt|SP>, [<Xn|SP>], #<simm>"
          ],
          "ST2G_64SPRE_LDSTTAGS": [
            "ST2G  <Xt|SP>, [<Xn|SP>, #<simm>]!"
          ]
        }
      },
      "STADDB_LDADDB": {
        "authored": "Atomic add on byte in memory, without return, atomically loads an 8-bit byte\nfrom memory, adds the value held in a register to it, and stores the result back\nto memory.\n  - STADDB has no memory ordering semantics.\n  - STADDLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STADDB, STADDLB",
        "templates": {
          "GENERAL": [
            "STADDB  <Ws>, [<Xn|SP>]",
            "STADDLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STADDH_LDADDH": {
        "authored": "Atomic add on halfword in memory, without return, atomically loads a 16-bit\nhalfword from memory, adds the value held in a register to it, and stores the\nresult back to memory.\n  - STADDH has no memory ordering semantics.\n  - STADDLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STADDH, STADDLH",
        "templates": {
          "GENERAL": [
            "STADDH  <Ws>, [<Xn|SP>]",
            "STADDLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STADD_LDADD": {
        "authored": "Atomic add on word or doubleword in memory, without return, atomically loads a\n32-bit word or 64-bit doubleword from memory, adds the value held in a register\nto it, and stores the result back to memory.\n  - STADD has no memory ordering semantics.\n  - STADDL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STADD, STADDL",
        "templates": {
          "GENERAL": [
            "STADD  <Ws>, [<Xn|SP>]",
            "STADDL  <Ws>, [<Xn|SP>]",
            "STADD  <Xs>, [<Xn|SP>]",
            "STADDL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STCLRB_LDCLRB": {
        "authored": "Atomic bit clear on byte in memory, without return, atomically loads an 8-bit\nbyte from memory, performs a bitwise AND with the complement of the value held\nin a register on it, and stores the result back to memory.\n  - STCLRB has no memory ordering semantics.\n  - STCLRLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STCLRB, STCLRLB",
        "templates": {
          "GENERAL": [
            "STCLRB  <Ws>, [<Xn|SP>]",
            "STCLRLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STCLRH_LDCLRH": {
        "authored": "Atomic bit clear on halfword in memory, without return, atomically loads a\n16-bit halfword from memory, performs a bitwise AND with the complement of the\nvalue held in a register on it, and stores the result back to memory.\n  - STCLRH has no memory ordering semantics.\n  - STCLRLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STCLRH, STCLRLH",
        "templates": {
          "GENERAL": [
            "STCLRH  <Ws>, [<Xn|SP>]",
            "STCLRLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STCLR_LDCLR": {
        "authored": "Atomic bit clear on word or doubleword in memory, without return, atomically\nloads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND\nwith the complement of the value held in a register on it, and stores the result\nback to memory.\n  - STCLR has no memory ordering semantics.\n  - STCLRL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STCLR, STCLRL",
        "templates": {
          "GENERAL": [
            "STCLR  <Ws>, [<Xn|SP>]",
            "STCLRL  <Ws>, [<Xn|SP>]",
            "STCLR  <Xs>, [<Xn|SP>]",
            "STCLRL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STEORB_LDEORB": {
        "authored": "Atomic exclusive OR on byte in memory, without return, atomically loads an 8-bit\nbyte from memory, performs an exclusive OR with the value held in a register on\nit, and stores the result back to memory.\n  - STEORB has no memory ordering semantics.\n  - STEORLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STEORB, STEORLB",
        "templates": {
          "GENERAL": [
            "STEORB  <Ws>, [<Xn|SP>]",
            "STEORLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STEORH_LDEORH": {
        "authored": "Atomic exclusive OR on halfword in memory, without return, atomically loads a\n16-bit halfword from memory, performs an exclusive OR with the value held in a\nregister on it, and stores the result back to memory.\n  - STEORH has no memory ordering semantics.\n  - STEORLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STEORH, STEORLH",
        "templates": {
          "GENERAL": [
            "STEORH  <Ws>, [<Xn|SP>]",
            "STEORLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STEOR_LDEOR": {
        "authored": "Atomic exclusive OR on word or doubleword in memory, without return, atomically\nloads a 32-bit word or 64-bit doubleword from memory, performs an exclusive OR\nwith the value held in a register on it, and stores the result back to memory.\n  - STEOR has no memory ordering semantics.\n  - STEORL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STEOR, STEORL",
        "templates": {
          "GENERAL": [
            "STEOR  <Ws>, [<Xn|SP>]",
            "STEORL  <Ws>, [<Xn|SP>]",
            "STEOR  <Xs>, [<Xn|SP>]",
            "STEORL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STG": {
        "authored": "Store Allocation Tag stores an Allocation Tag to memory. The address used for\nthe store is calculated from the base register and an immediate signed offset\nscaled by the Tag granule. The Allocation Tag is calculated from the Logical\nAddress Tag in the source register.\n\nThis instruction generates an Unchecked access.",
        "heading": "STG",
        "templates": {
          "STG_64SOFFSET_LDSTTAGS": [
            "STG  <Xt|SP>, [<Xn|SP>{, #<simm>}]"
          ],
          "STG_64SPOST_LDSTTAGS": [
            "STG  <Xt|SP>, [<Xn|SP>], #<simm>"
          ],
          "STG_64SPRE_LDSTTAGS": [
            "STG  <Xt|SP>, [<Xn|SP>, #<simm>]!"
          ]
        }
      },
      "STGM": {
        "authored": "Store Tag Multiple writes a naturally aligned block of N Allocation Tags, where\nthe size of N is identified in GMID_EL1.BS, and the Allocation Tag written to\naddress A is taken from the source register at 4*A<7:4>+3:4*A<7:4>.\n\nThis instruction is undefined at EL0.\n\nThis instruction generates an Unchecked access.\n\nIf ID_AA64PFR1_EL1.MTE != 0b0010, this instruction is undefined.",
        "heading": "STGM",
        "templates": {
          "STGM_64BULK_LDSTTAGS": [
            "STGM  <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "STGP": {
        "authored": "Store Allocation Tag and Pair of registers stores an Allocation Tag and two\n64-bit doublewords to memory, from two registers. The address used for the store\nis calculated from the base register and an immediate signed offset scaled by\nthe Tag granule. The Allocation Tag is calculated from the Logical Address Tag\nin the base register.\n\nThis instruction generates an Unchecked access.",
        "heading": "STGP",
        "templates": {
          "STGP_64_LDSTPAIR_OFF": [
            "STGP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          ],
          "STGP_64_LDSTPAIR_POST": [
            "STGP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
          ],
          "STGP_64_LDSTPAIR_PRE": [
            "STGP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
          ]
        }
      },
      "STLLR": {
        "authored": "Store LORelease Register stores a 32-bit word or a 64-bit doubleword to a memory\nlocation, from a register. The instruction also has memory ordering semantics as\ndescribed in Load LOAcquire, Store LORelease. For information about memory\naccesses, see Load/Store addressing modes.",
        "heading": "STLLR",
        "templates": {
          "BASE_REGISTER": [
            "STLLR  <Wt>, [<Xn|SP>{,#0}]",
            "STLLR  <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLLRB": {
        "authored": "Store LORelease Register Byte stores a byte from a 32-bit register to a memory\nlocation. The instruction also has memory ordering semantics as described in\nLoad LOAcquire, Store LORelease. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "STLLRB",
        "templates": {
          "STLLRB_SL32_LDSTEXCL": [
            "STLLRB  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLLRH": {
        "authored": "Store LORelease Register Halfword stores a halfword from a 32-bit register to a\nmemory location. The instruction also has memory ordering semantics as described\nin Load LOAcquire, Store LORelease. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "STLLRH",
        "templates": {
          "STLLRH_SL32_LDSTEXCL": [
            "STLLRH  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLR": {
        "authored": "Store-Release Register stores a 32-bit word or a 64-bit doubleword to a memory\nlocation, from a register. The instruction also has memory ordering semantics as\ndescribed in Load-Acquire, Store-Release. For information about memory accesses,\nsee Load/Store addressing modes.",
        "heading": "STLR",
        "templates": {
          "BASE_REGISTER": [
            "STLR  <Wt>, [<Xn|SP>{,#0}]",
            "STLR  <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLRB": {
        "authored": "Store-Release Register Byte stores a byte from a 32-bit register to a memory\nlocation. The instruction also has memory ordering semantics as described in\nLoad-Acquire, Store-Release. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "STLRB",
        "templates": {
          "STLRB_SL32_LDSTEXCL": [
            "STLRB  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLRH": {
        "authored": "Store-Release Register Halfword stores a halfword from a 32-bit register to a\nmemory location. The instruction also has memory ordering semantics as described\nin Load-Acquire, Store-Release. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "STLRH",
        "templates": {
          "STLRH_SL32_LDSTEXCL": [
            "STLRH  <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLURB": {
        "authored": "Store-Release Register Byte (unscaled) calculates an address from a base\nregister value and an immediate offset, and stores a byte to the calculated\naddress, from a 32-bit register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "STLURB",
        "templates": {
          "STLURB_32_LDAPSTL_UNSCALED": [
            "STLURB  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STLURH": {
        "authored": "Store-Release Register Halfword (unscaled) calculates an address from a base\nregister value and an immediate offset, and stores a halfword to the calculated\naddress, from a 32-bit register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "STLURH",
        "templates": {
          "STLURH_32_LDAPSTL_UNSCALED": [
            "STLURH  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STLUR_gen": {
        "authored": "Store-Release Register (unscaled) calculates an address from a base register\nvalue and an immediate offset, and stores a 32-bit word or a 64-bit doubleword\nto the calculated address, from a register.\n\nThe instruction has memory ordering semantics as described in Load-Acquire,\nLoad-AcquirePC, and Store-Release\n\nFor information about memory accesses, see Load/Store addressing modes.",
        "heading": "STLUR",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STLUR  <Wt>, [<Xn|SP>{, #<simm>}]",
            "STLUR  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STLXP": {
        "authored": "Store-Release Exclusive Pair of registers stores two 32-bit words or two 64-bit\ndoublewords to a memory location if the PE has exclusive access to the memory\naddress, from two registers, and returns a status value of 0 if the store was\nsuccessful, or of 1 if no store was performed. See Synchronization and\nsemaphores. A 32-bit pair requires the address to be doubleword aligned and is\nsingle-copy atomic at doubleword granularity. A 64-bit pair requires the address\nto be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-\ncopy atomic update of the 128-bit memory location being updated. The instruction\nalso has memory ordering semantics as described in Load-Acquire, Store-Release.\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STLXP",
        "templates": {
          "BASE_REGISTER": [
            "STLXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]",
            "STLXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLXR": {
        "authored": "Store-Release Exclusive Register stores a 32-bit word or a 64-bit doubleword to\nmemory if the PE has exclusive access to the memory address, from two registers,\nand returns a status value of 0 if the store was successful, or of 1 if no store\nwas performed. See Synchronization and semaphores. The memory access is atomic.\nThe instruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release. For information about memory accesses see Load/Store addressing\nmodes.",
        "heading": "STLXR",
        "templates": {
          "BASE_REGISTER": [
            "STLXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "STLXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLXRB": {
        "authored": "Store-Release Exclusive Register Byte stores a byte from a 32-bit register to\nmemory if the PE has exclusive access to the memory address, and returns a\nstatus value of 0 if the store was successful, or of 1 if no store was\nperformed. See Synchronization and semaphores. The memory access is atomic. The\ninstruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release. For information about memory accesses see Load/Store addressing\nmodes.",
        "heading": "STLXRB",
        "templates": {
          "STLXRB_SR32_LDSTEXCL": [
            "STLXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STLXRH": {
        "authored": "Store-Release Exclusive Register Halfword stores a halfword from a 32-bit\nregister to memory if the PE has exclusive access to the memory address, and\nreturns a status value of 0 if the store was successful, or of 1 if no store was\nperformed. See Synchronization and semaphores. The memory access is atomic. The\ninstruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release. For information about memory accesses see Load/Store addressing\nmodes.",
        "heading": "STLXRH",
        "templates": {
          "STLXRH_SR32_LDSTEXCL": [
            "STLXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STNP_gen": {
        "authored": "Store Pair of Registers, with non-temporal hint, calculates an address from a\nbase register value and an immediate offset, and stores two 32-bit words or two\n64-bit doublewords to the calculated address, from two registers. For\ninformation about memory accesses, see Load/Store addressing modes. For\ninformation about Non-temporal pair instructions, see Load/Store Non-temporal\npair.",
        "heading": "STNP",
        "templates": {
          "SIGNED_SCALED_OFFSET": [
            "STNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]",
            "STNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "STP_gen": {
        "authored": "Store Pair of Registers calculates an address from a base register value and an\nimmediate offset, and stores two 32-bit words or two 64-bit doublewords to the\ncalculated address, from two registers. For information about memory accesses,\nsee Load/Store addressing modes.",
        "heading": "STP",
        "templates": {
          "POST_INDEXED": [
            "STP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>",
            "STP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
          ],
          "PRE_INDEXED": [
            "STP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!",
            "STP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "STP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]",
            "STP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "STRB_imm": {
        "authored": "Store Register Byte (immediate) stores the least significant byte of a 32-bit\nregister to memory. The address that is used for the store is calculated from a\nbase register and an immediate offset. For information about memory accesses,\nsee Load/Store addressing modes.",
        "heading": "STRB (immediate)",
        "templates": {
          "STRB_32_LDST_IMMPOST": [
            "STRB  <Wt>, [<Xn|SP>], #<simm>"
          ],
          "STRB_32_LDST_IMMPRE": [
            "STRB  <Wt>, [<Xn|SP>, #<simm>]!"
          ],
          "STRB_32_LDST_POS": [
            "STRB  <Wt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "STRB_reg": {
        "authored": "Store Register Byte (register) calculates an address from a base register value\nand an offset register value, and stores a byte from a 32-bit register to the\ncalculated address. For information about memory accesses, see Load/Store\naddressing modes.\n\nThe instruction uses an offset addressing mode, that calculates the address used\nfor the memory access from a base register value and an offset register value.\nThe offset can be optionally shifted and extended.",
        "heading": "STRB (register)",
        "templates": {
          "32": [
            "STRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]",
            "STRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
          ]
        }
      },
      "STRH_imm": {
        "authored": "Store Register Halfword (immediate) stores the least significant halfword of a\n32-bit register to memory. The address that is used for the store is calculated\nfrom a base register and an immediate offset. For information about memory\naccesses, see Load/Store addressing modes.",
        "heading": "STRH (immediate)",
        "templates": {
          "STRH_32_LDST_IMMPOST": [
            "STRH  <Wt>, [<Xn|SP>], #<simm>"
          ],
          "STRH_32_LDST_IMMPRE": [
            "STRH  <Wt>, [<Xn|SP>, #<simm>]!"
          ],
          "STRH_32_LDST_POS": [
            "STRH  <Wt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "STRH_reg": {
        "authored": "Store Register Halfword (register) calculates an address from a base register\nvalue and an offset register value, and stores a halfword from a 32-bit register\nto the calculated address. For information about memory accesses, see Load/Store\naddressing modes.\n\nThe instruction uses an offset addressing mode, that calculates the address used\nfor the memory access from a base register value and an offset register value.\nThe offset can be optionally shifted and extended.",
        "heading": "STRH (register)",
        "templates": {
          "STRH_32_LDST_REGOFF": [
            "STRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "STR_imm_gen": {
        "authored": "Store Register (immediate) stores a word or a doubleword from a register to\nmemory. The address that is used for the store is calculated from a base\nregister and an immediate offset. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "STR (immediate)",
        "templates": {
          "POST_INDEXED": [
            "STR  <Wt>, [<Xn|SP>], #<simm>",
            "STR  <Xt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "STR  <Wt>, [<Xn|SP>, #<simm>]!",
            "STR  <Xt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "STR  <Wt>, [<Xn|SP>{, #<pimm>}]",
            "STR  <Xt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "STR_reg_gen": {
        "authored": "Store Register (register) calculates an address from a base register value and\nan offset register value, and stores a 32-bit word or a 64-bit doubleword to the\ncalculated address, from a register. For information about memory accesses, see\nLoad/Store addressing modes.\n\nThe instruction uses an offset addressing mode, that calculates the address used\nfor the memory access from a base register value and an offset register value.\nThe offset can be optionally shifted and extended.",
        "heading": "STR (register)",
        "templates": {
          "GENERAL": [
            "STR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "STR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "STSETB_LDSETB": {
        "authored": "Atomic bit set on byte in memory, without return, atomically loads an 8-bit byte\nfrom memory, performs a bitwise OR with the value held in a register on it, and\nstores the result back to memory.\n  - STSETB has no memory ordering semantics.\n  - STSETLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSETB, STSETLB",
        "templates": {
          "GENERAL": [
            "STSETB  <Ws>, [<Xn|SP>]",
            "STSETLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STSETH_LDSETH": {
        "authored": "Atomic bit set on halfword in memory, without return, atomically loads a 16-bit\nhalfword from memory, performs a bitwise OR with the value held in a register on\nit, and stores the result back to memory.\n  - STSETH has no memory ordering semantics.\n  - STSETLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSETH, STSETLH",
        "templates": {
          "GENERAL": [
            "STSETH  <Ws>, [<Xn|SP>]",
            "STSETLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STSET_LDSET": {
        "authored": "Atomic bit set on word or doubleword in memory, without return, atomically loads\na 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the\nvalue held in a register on it, and stores the result back to memory.\n  - STSET has no memory ordering semantics.\n  - STSETL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSET, STSETL",
        "templates": {
          "GENERAL": [
            "STSET  <Ws>, [<Xn|SP>]",
            "STSETL  <Ws>, [<Xn|SP>]",
            "STSET  <Xs>, [<Xn|SP>]",
            "STSETL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STSMAXB_LDSMAXB": {
        "authored": "Atomic signed maximum on byte in memory, without return, atomically loads an\n8-bit byte from memory, compares it against the value held in a register, and\nstores the larger value back to memory, treating the values as signed numbers.\n  - STSMAXB has no memory ordering semantics.\n  - STSMAXLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSMAXB, STSMAXLB",
        "templates": {
          "GENERAL": [
            "STSMAXB  <Ws>, [<Xn|SP>]",
            "STSMAXLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STSMAXH_LDSMAXH": {
        "authored": "Atomic signed maximum on halfword in memory, without return, atomically loads a\n16-bit halfword from memory, compares it against the value held in a register,\nand stores the larger value back to memory, treating the values as signed\nnumbers.\n  - STSMAXH has no memory ordering semantics.\n  - STSMAXLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSMAXH, STSMAXLH",
        "templates": {
          "GENERAL": [
            "STSMAXH  <Ws>, [<Xn|SP>]",
            "STSMAXLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STSMAX_LDSMAX": {
        "authored": "Atomic signed maximum on word or doubleword in memory, without return,\natomically loads a 32-bit word or 64-bit doubleword from memory, compares it\nagainst the value held in a register, and stores the larger value back to\nmemory, treating the values as signed numbers.\n  - STSMAX has no memory ordering semantics.\n  - STSMAXL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSMAX, STSMAXL",
        "templates": {
          "GENERAL": [
            "STSMAX  <Ws>, [<Xn|SP>]",
            "STSMAXL  <Ws>, [<Xn|SP>]",
            "STSMAX  <Xs>, [<Xn|SP>]",
            "STSMAXL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STSMINB_LDSMINB": {
        "authored": "Atomic signed minimum on byte in memory, without return, atomically loads an\n8-bit byte from memory, compares it against the value held in a register, and\nstores the smaller value back to memory, treating the values as signed numbers.\n  - STSMINB has no memory ordering semantics.\n  - STSMINLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSMINB, STSMINLB",
        "templates": {
          "GENERAL": [
            "STSMINB  <Ws>, [<Xn|SP>]",
            "STSMINLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STSMINH_LDSMINH": {
        "authored": "Atomic signed minimum on halfword in memory, without return, atomically loads a\n16-bit halfword from memory, compares it against the value held in a register,\nand stores the smaller value back to memory, treating the values as signed\nnumbers.\n  - STSMINH has no memory ordering semantics.\n  - STSMINLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSMINH, STSMINLH",
        "templates": {
          "GENERAL": [
            "STSMINH  <Ws>, [<Xn|SP>]",
            "STSMINLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STSMIN_LDSMIN": {
        "authored": "Atomic signed minimum on word or doubleword in memory, without return,\natomically loads a 32-bit word or 64-bit doubleword from memory, compares it\nagainst the value held in a register, and stores the smaller value back to\nmemory, treating the values as signed numbers.\n  - STSMIN has no memory ordering semantics.\n  - STSMINL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STSMIN, STSMINL",
        "templates": {
          "GENERAL": [
            "STSMIN  <Ws>, [<Xn|SP>]",
            "STSMINL  <Ws>, [<Xn|SP>]",
            "STSMIN  <Xs>, [<Xn|SP>]",
            "STSMINL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STTR": {
        "authored": "Store Register (unprivileged) stores a word or doubleword from a register to\nmemory. The address that is used for the store is calculated from a base\nregister and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "STTR",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STTR  <Wt>, [<Xn|SP>{, #<simm>}]",
            "STTR  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STTRB": {
        "authored": "Store Register Byte (unprivileged) stores a byte from a 32-bit register to\nmemory. The address that is used for the store is calculated from a base\nregister and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "STTRB",
        "templates": {
          "STTRB_32_LDST_UNPRIV": [
            "STTRB  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STTRH": {
        "authored": "Store Register Halfword (unprivileged) stores a halfword from a 32-bit register\nto memory. The address that is used for the store is calculated from a base\nregister and an immediate offset.\n\nMemory accesses made by the instruction behave as if the instruction was\nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either:\n  - The instruction is executed at EL1.\n  - The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H,\nTGE} is {1, 1}.\n\nOtherwise, the memory access operates with the restrictions determined by the\nException level at which the instruction is executed. For information about\nmemory accesses, see Load/Store addressing modes.",
        "heading": "STTRH",
        "templates": {
          "STTRH_32_LDST_UNPRIV": [
            "STTRH  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STUMAXB_LDUMAXB": {
        "authored": "Atomic unsigned maximum on byte in memory, without return, atomically loads an\n8-bit byte from memory, compares it against the value held in a register, and\nstores the larger value back to memory, treating the values as unsigned numbers.\n  - STUMAXB has no memory ordering semantics.\n  - STUMAXLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STUMAXB, STUMAXLB",
        "templates": {
          "GENERAL": [
            "STUMAXB  <Ws>, [<Xn|SP>]",
            "STUMAXLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STUMAXH_LDUMAXH": {
        "authored": "Atomic unsigned maximum on halfword in memory, without return, atomically loads\na 16-bit halfword from memory, compares it against the value held in a register,\nand stores the larger value back to memory, treating the values as unsigned\nnumbers.\n  - STUMAXH has no memory ordering semantics.\n  - STUMAXLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STUMAXH, STUMAXLH",
        "templates": {
          "GENERAL": [
            "STUMAXH  <Ws>, [<Xn|SP>]",
            "STUMAXLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STUMAX_LDUMAX": {
        "authored": "Atomic unsigned maximum on word or doubleword in memory, without return,\natomically loads a 32-bit word or 64-bit doubleword from memory, compares it\nagainst the value held in a register, and stores the larger value back to\nmemory, treating the values as unsigned numbers.\n  - STUMAX has no memory ordering semantics.\n  - STUMAXL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STUMAX, STUMAXL",
        "templates": {
          "GENERAL": [
            "STUMAX  <Ws>, [<Xn|SP>]",
            "STUMAXL  <Ws>, [<Xn|SP>]",
            "STUMAX  <Xs>, [<Xn|SP>]",
            "STUMAXL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STUMINB_LDUMINB": {
        "authored": "Atomic unsigned minimum on byte in memory, without return, atomically loads an\n8-bit byte from memory, compares it against the value held in a register, and\nstores the smaller value back to memory, treating the values as unsigned\nnumbers.\n  - STUMINB has no memory ordering semantics.\n  - STUMINLB stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STUMINB, STUMINLB",
        "templates": {
          "GENERAL": [
            "STUMINB  <Ws>, [<Xn|SP>]",
            "STUMINLB  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STUMINH_LDUMINH": {
        "authored": "Atomic unsigned minimum on halfword in memory, without return, atomically loads\na 16-bit halfword from memory, compares it against the value held in a register,\nand stores the smaller value back to memory, treating the values as unsigned\nnumbers.\n  - STUMINH has no memory ordering semantics.\n  - STUMINLH stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STUMINH, STUMINLH",
        "templates": {
          "GENERAL": [
            "STUMINH  <Ws>, [<Xn|SP>]",
            "STUMINLH  <Ws>, [<Xn|SP>]"
          ]
        }
      },
      "STUMIN_LDUMIN": {
        "authored": "Atomic unsigned minimum on word or doubleword in memory, without return,\natomically loads a 32-bit word or 64-bit doubleword from memory, compares it\nagainst the value held in a register, and stores the smaller value back to\nmemory, treating the values as unsigned numbers.\n  - STUMIN has no memory ordering semantics.\n  - STUMINL stores to memory with release semantics, as described in Load-\nAcquire, Store-Release.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STUMIN, STUMINL",
        "templates": {
          "GENERAL": [
            "STUMIN  <Ws>, [<Xn|SP>]",
            "STUMINL  <Ws>, [<Xn|SP>]",
            "STUMIN  <Xs>, [<Xn|SP>]",
            "STUMINL  <Xs>, [<Xn|SP>]"
          ]
        }
      },
      "STURB": {
        "authored": "Store Register Byte (unscaled) calculates an address from a base register value\nand an immediate offset, and stores a byte to the calculated address, from a\n32-bit register. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "STURB",
        "templates": {
          "STURB_32_LDST_UNSCALED": [
            "STURB  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STURH": {
        "authored": "Store Register Halfword (unscaled) calculates an address from a base register\nvalue and an immediate offset, and stores a halfword to the calculated address,\nfrom a 32-bit register. For information about memory accesses, see Load/Store\naddressing modes.",
        "heading": "STURH",
        "templates": {
          "STURH_32_LDST_UNSCALED": [
            "STURH  <Wt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STUR_gen": {
        "authored": "Store Register (unscaled) calculates an address from a base register value and\nan immediate offset, and stores a 32-bit word or a 64-bit doubleword to the\ncalculated address, from a register. For information about memory accesses, see\nLoad/Store addressing modes.",
        "heading": "STUR",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STUR  <Wt>, [<Xn|SP>{, #<simm>}]",
            "STUR  <Xt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "STXP": {
        "authored": "Store Exclusive Pair of registers stores two 32-bit words or two 64-bit\ndoublewords from two registers to a memory location if the PE has exclusive\naccess to the memory address, and returns a status value of 0 if the store was\nsuccessful, or of 1 if no store was performed. See Synchronization and\nsemaphores. A 32-bit pair requires the address to be doubleword aligned and is\nsingle-copy atomic at doubleword granularity. A 64-bit pair requires the address\nto be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-\ncopy atomic update of the 128-bit memory location being updated. For information\nabout memory accesses see Load/Store addressing modes.",
        "heading": "STXP",
        "templates": {
          "BASE_REGISTER": [
            "STXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]",
            "STXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STXR": {
        "authored": "Store Exclusive Register stores a 32-bit word or a 64-bit doubleword from a\nregister to memory if the PE has exclusive access to the memory address, and\nreturns a status value of 0 if the store was successful, or of 1 if no store was\nperformed. See Synchronization and semaphores. For information about memory\naccesses see Load/Store addressing modes.",
        "heading": "STXR",
        "templates": {
          "BASE_REGISTER": [
            "STXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]",
            "STXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STXRB": {
        "authored": "Store Exclusive Register Byte stores a byte from a register to memory if the PE\nhas exclusive access to the memory address, and returns a status value of 0 if\nthe store was successful, or of 1 if no store was performed. See Synchronization\nand semaphores. The memory access is atomic.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STXRB",
        "templates": {
          "STXRB_SR32_LDSTEXCL": [
            "STXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STXRH": {
        "authored": "Store Exclusive Register Halfword stores a halfword from a register to memory if\nthe PE has exclusive access to the memory address, and returns a status value of\n0 if the store was successful, or of 1 if no store was performed. See\nSynchronization and semaphores. The memory access is atomic.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "STXRH",
        "templates": {
          "STXRH_SR32_LDSTEXCL": [
            "STXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          ]
        }
      },
      "STZ2G": {
        "authored": "Store Allocation Tags, Zeroing stores an Allocation Tag to two Tag granules of\nmemory, zeroing the associated data locations. The address used for the store is\ncalculated from the base register and an immediate signed offset scaled by the\nTag granule. The Allocation Tag is calculated from the Logical Address Tag in\nthe source register.\n\nThis instruction generates an Unchecked access.",
        "heading": "STZ2G",
        "templates": {
          "STZ2G_64SOFFSET_LDSTTAGS": [
            "STZ2G  <Xt|SP>, [<Xn|SP>{, #<simm>}]"
          ],
          "STZ2G_64SPOST_LDSTTAGS": [
            "STZ2G  <Xt|SP>, [<Xn|SP>], #<simm>"
          ],
          "STZ2G_64SPRE_LDSTTAGS": [
            "STZ2G  <Xt|SP>, [<Xn|SP>, #<simm>]!"
          ]
        }
      },
      "STZG": {
        "authored": "Store Allocation Tag, Zeroing stores an Allocation Tag to memory, zeroing the\nassociated data location. The address used for the store is calculated from the\nbase register and an immediate signed offset scaled by the Tag granule. The\nAllocation Tag is calculated from the Logical Address Tag in the source\nregister.\n\nThis instruction generates an Unchecked access.",
        "heading": "STZG",
        "templates": {
          "STZG_64SOFFSET_LDSTTAGS": [
            "STZG  <Xt|SP>, [<Xn|SP>{, #<simm>}]"
          ],
          "STZG_64SPOST_LDSTTAGS": [
            "STZG  <Xt|SP>, [<Xn|SP>], #<simm>"
          ],
          "STZG_64SPRE_LDSTTAGS": [
            "STZG  <Xt|SP>, [<Xn|SP>, #<simm>]!"
          ]
        }
      },
      "STZGM": {
        "authored": "Store Tag and Zero Multiple writes a naturally aligned block of N Allocation\nTags and stores zero to the associated data locations, where the size of N is\nidentified in DCZID_EL0.BS, and the Allocation Tag written to address A is taken\nfrom the source register bits<3:0>.\n\nThis instruction is undefined at EL0.\n\nThis instruction generates an Unchecked access.\n\nIf ID_AA64PFR1_EL1.MTE != 0b0010, this instruction is undefined.",
        "heading": "STZGM",
        "templates": {
          "STZGM_64BULK_LDSTTAGS": [
            "STZGM  <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "SUBG": {
        "authored": "Subtract with Tag subtracts an immediate value scaled by the Tag granule from\nthe address in the source register, modifies the Logical Address Tag of the\naddress using an immediate value, and writes the result to the destination\nregister. Tags specified in GCR_EL1.Exclude are excluded from the possible\noutputs when modifying the Logical Address Tag.",
        "heading": "SUBG",
        "templates": {
          "SUBG_64_ADDSUB_IMMTAGS": [
            "SUBG  <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>"
          ]
        }
      },
      "SUBP": {
        "authored": "Subtract Pointer subtracts the 56-bit address held in the second source register\nfrom the 56-bit address held in the first source register, sign-extends the\nresult to 64-bits, and writes the result to the destination register.",
        "heading": "SUBP",
        "templates": {
          "SUBP_64S_DP_2SRC": [
            "SUBP  <Xd>, <Xn|SP>, <Xm|SP>"
          ]
        }
      },
      "SUBPS": {
        "authored": "Subtract Pointer, setting Flags subtracts the 56-bit address held in the second\nsource register from the 56-bit address held in the first source register, sign-\nextends the result to 64-bits, and writes the result to the destination\nregister. It updates the condition flags based on the result of the subtraction.",
        "heading": "SUBPS",
        "templates": {
          "SUBPS_64S_DP_2SRC": [
            "SUBPS  <Xd>, <Xn|SP>, <Xm|SP>"
          ]
        }
      },
      "SUBS_addsub_ext": {
        "authored": "Subtract (extended register), setting flags, subtracts a sign or zero-extended\nregister value, followed by an optional left shift amount, from a register\nvalue, and writes the result to the destination register. The argument that is\nextended from the <Rm> register can be a byte, halfword, word, or doubleword. It\nupdates the condition flags based on the result.",
        "heading": "SUBS (extended register)",
        "templates": {
          "S": [
            "SUBS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}",
            "SUBS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          ]
        }
      },
      "SUBS_addsub_imm": {
        "authored": "Subtract (immediate), setting flags, subtracts an optionally-shifted immediate\nvalue from a register value, and writes the result to the destination register.\nIt updates the condition flags based on the result.",
        "heading": "SUBS (immediate)",
        "templates": {
          "S": [
            "SUBS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}",
            "SUBS  <Xd>, <Xn|SP>, #<imm>{, <shift>}"
          ]
        }
      },
      "SUBS_addsub_shift": {
        "authored": "Subtract (shifted register), setting flags, subtracts an optionally-shifted\nregister value from a register value, and writes the result to the destination\nregister. It updates the condition flags based on the result.",
        "heading": "SUBS (shifted register)",
        "templates": {
          "S": [
            "SUBS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "SUBS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "SUB_addsub_ext": {
        "authored": "Subtract (extended register) subtracts a sign or zero-extended register value,\nfollowed by an optional left shift amount, from a register value, and writes the\nresult to the destination register. The argument that is extended from the <Rm>\nregister can be a byte, halfword, word, or doubleword.",
        "heading": "SUB (extended register)",
        "templates": {
          "NO_S": [
            "SUB  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}",
            "SUB  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          ]
        }
      },
      "SUB_addsub_imm": {
        "authored": "Subtract (immediate) subtracts an optionally-shifted immediate value from a\nregister value, and writes the result to the destination register.",
        "heading": "SUB (immediate)",
        "templates": {
          "NO_S": [
            "SUB  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}",
            "SUB  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}"
          ]
        }
      },
      "SUB_addsub_shift": {
        "authored": "Subtract (shifted register) subtracts an optionally-shifted register value from\na register value, and writes the result to the destination register.",
        "heading": "SUB (shifted register)",
        "templates": {
          "NO_S": [
            "SUB  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}",
            "SUB  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "SVC": {
        "authored": "Supervisor Call causes an exception to be taken to EL1.\n\nOn executing an SVC instruction, the PE records the exception as a Supervisor\nCall exception in ESR_ELx, using the EC value 0x15, and the value of the\nimmediate argument.",
        "heading": "SVC",
        "templates": {
          "SVC_EX_EXCEPTION": [
            "SVC  #<imm>"
          ]
        }
      },
      "SWP": {
        "authored": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit\ndoubleword from a memory location, and stores the value held in a register back\nto the same memory location. The value initially loaded from memory is returned\nin the destination register.\n  - If the destination register is not one of WZR or XZR, SWPA and SWPAL load\nfrom memory with acquire semantics.\n  - SWPL and SWPAL store to memory with release semantics.\n  - SWP has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "SWP, SWPA, SWPAL, SWPL",
        "templates": {
          "GENERAL": [
            "SWP  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPA  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPAL  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPL  <Ws>, <Wt>, [<Xn|SP>]",
            "SWP  <Xs>, <Xt>, [<Xn|SP>]",
            "SWPA  <Xs>, <Xt>, [<Xn|SP>]",
            "SWPAL  <Xs>, <Xt>, [<Xn|SP>]",
            "SWPL  <Xs>, <Xt>, [<Xn|SP>]"
          ]
        }
      },
      "SWPB": {
        "authored": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and\nstores the value held in a register back to the same memory location. The value\ninitially loaded from memory is returned in the destination register.\n  - If the destination register is not WZR, SWPAB and SWPALB load from memory\nwith acquire semantics.\n  - SWPLB and SWPALB store to memory with release semantics.\n  - SWPB has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "SWPB, SWPAB, SWPALB, SWPLB",
        "templates": {
          "GENERAL": [
            "SWPAB  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPALB  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPB  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPLB  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "SWPH": {
        "authored": "Swap halfword in memory atomically loads a 16-bit halfword from a memory\nlocation, and stores the value held in a register back to the same memory\nlocation. The value initially loaded from memory is returned in the destination\nregister.\n  - If the destination register is not WZR, SWPAH and SWPALH load from memory\nwith acquire semantics.\n  - SWPLH and SWPALH store to memory with release semantics.\n  - SWPH has no memory ordering requirements.\n\nFor more information about memory ordering semantics see Load-Acquire, Store-\nRelease.\n\nFor information about memory accesses see Load/Store addressing modes.",
        "heading": "SWPH, SWPAH, SWPALH, SWPLH",
        "templates": {
          "GENERAL": [
            "SWPAH  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPALH  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPH  <Ws>, <Wt>, [<Xn|SP>]",
            "SWPLH  <Ws>, <Wt>, [<Xn|SP>]"
          ]
        }
      },
      "SXTB_SBFM": {
        "authored": "Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to\nthe size of the register, and writes the result to the destination register.",
        "heading": "SXTB",
        "templates": {
          "SIGNED_FILL": [
            "SXTB  <Wd>, <Wn>",
            "SXTB  <Xd>, <Wn>"
          ]
        }
      },
      "SXTH_SBFM": {
        "authored": "Sign Extend Halfword extracts a 16-bit value, sign-extends it to the size of the\nregister, and writes the result to the destination register.",
        "heading": "SXTH",
        "templates": {
          "SIGNED_FILL": [
            "SXTH  <Wd>, <Wn>",
            "SXTH  <Xd>, <Wn>"
          ]
        }
      },
      "SXTW_SBFM": {
        "authored": "Sign Extend Word sign-extends a word to the size of the register, and writes the\nresult to the destination register.",
        "heading": "SXTW",
        "templates": {
          "SIGNED_FILL": [
            "SXTW  <Xd>, <Wn>"
          ]
        }
      },
      "SYS": {
        "authored": "System instruction. For more information, see Op0 equals 0b01, cache\nmaintenance, TLB maintenance, and address translation instructions for the\nencodings of System instructions.",
        "heading": "SYS",
        "templates": {
          "SYS_CR_SYSTEMINSTRS": [
            "SYS  #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}"
          ]
        }
      },
      "SYSL": {
        "authored": "System instruction with result. For more information, see Op0 equals 0b01, cache\nmaintenance, TLB maintenance, and address translation instructions for the\nencodings of System instructions.",
        "heading": "SYSL",
        "templates": {
          "SYSL_RC_SYSTEMINSTRS": [
            "SYSL  <Xt>, #<op1>, <Cn>, <Cm>, #<op2>"
          ]
        }
      },
      "TBNZ": {
        "authored": "Test bit and Branch if Nonzero compares the value of a bit in a general-purpose\nregister with zero, and conditionally branches to a label at a PC-relative\noffset if the comparison is not equal. It provides a hint that this is not a\nsubroutine call or return. This instruction does not affect condition flags.",
        "heading": "TBNZ",
        "templates": {
          "TBNZ_ONLY_TESTBRANCH": [
            "TBNZ  <R><t>, #<imm>, <label>"
          ]
        }
      },
      "TBZ": {
        "authored": "Test bit and Branch if Zero compares the value of a test bit with zero, and\nconditionally branches to a label at a PC-relative offset if the comparison is\nequal. It provides a hint that this is not a subroutine call or return. This\ninstruction does not affect condition flags.",
        "heading": "TBZ",
        "templates": {
          "TBZ_ONLY_TESTBRANCH": [
            "TBZ  <R><t>, #<imm>, <label>"
          ]
        }
      },
      "TLBI_SYS": {
        "authored": "TLB Invalidate operation. For more information, see op0==0b01, cache\nmaintenance, TLB maintenance, and address translation instructions.",
        "heading": "TLBI",
        "templates": {
          "SYS_CR_SYSTEMINSTRS": [
            "TLBI  <tlbi_op>{, <Xt>}"
          ]
        }
      },
      "TSB": {
        "authored": "Trace Synchronization Barrier. This instruction is a barrier that synchronizes\nthe trace operations of instructions.\n\nIf ARMv8.4-Trace is not implemented, this instruction executes as a NOP.",
        "heading": "TSB CSYNC",
        "templates": {
          "TSB_HC_HINTS": [
            "TSB CSYNC"
          ]
        }
      },
      "TST_ANDS_log_imm": {
        "authored": ", setting the condition flags and discarding the result",
        "heading": "TST (immediate)",
        "templates": {
          "S": [
            "TST  <Wn>, #<imm>",
            "TST  <Xn>, #<imm>"
          ]
        }
      },
      "TST_ANDS_log_shift": {
        "authored": "Test (shifted register) performs a bitwise AND operation on a register value and\nan optionally-shifted register value. It updates the condition flags based on\nthe result, and discards the result.",
        "heading": "TST (shifted register)",
        "templates": {
          "S": [
            "TST  <Wn>, <Wm>{, <shift> #<amount>}",
            "TST  <Xn>, <Xm>{, <shift> #<amount>}"
          ]
        }
      },
      "UBFIZ_UBFM": {
        "authored": "Unsigned Bitfield Insert in Zeros copies a bitfield of <width> bits from the\nleast significant bits of the source register to bit position <lsb> of the\ndestination register, setting the destination bits above and below the bitfield\nto zero.",
        "heading": "UBFIZ",
        "templates": {
          "ZERO_FILL": [
            "UBFIZ  <Wd>, <Wn>, #<lsb>, #<width>",
            "UBFIZ  <Xd>, <Xn>, #<lsb>, #<width>"
          ]
        }
      },
      "UBFM": {
        "authored": "Unigned Bitfield Move is usually accessed via one of its aliases, which are\nalways preferred for disassembly.\n\nIf <imms> is greater than or equal to <immr>, this copies a bitfield of\n(<imms>-<immr>+1) bits starting from bit position <immr> in the source register\nto the least significant bits of the destination register.\n\nIf <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from\nthe least significant bits of the source register to bit position\n(regsize-<immr>) of the destination register, where regsize is the destination\nregister size of 32 or 64 bits.\n\nIn both cases the destination bits below and above the bitfield are set to zero.",
        "heading": "UBFM",
        "templates": {
          "ZERO_FILL": [
            "UBFM  <Wd>, <Wn>, #<immr>, #<imms>",
            "UBFM  <Xd>, <Xn>, #<immr>, #<imms>"
          ]
        }
      },
      "UBFX_UBFM": {
        "authored": "Unsigned Bitfield Extract copies a bitfield of <width> bits starting from bit\nposition <lsb> in the source register to the least significant bits of the\ndestination register, and sets destination bits above the bitfield to zero.",
        "heading": "UBFX",
        "templates": {
          "ZERO_FILL": [
            "UBFX  <Wd>, <Wn>, #<lsb>, #<width>",
            "UBFX  <Xd>, <Xn>, #<lsb>, #<width>"
          ]
        }
      },
      "UDF_perm_undef": {
        "authored": "Permanently Undefined generates an Undefined Instruction exception (ESR_ELx.EC =\n0b000000). The encodings for UDF used in this section are defined as permanently\nundefined in the Armv8-A architecture.",
        "heading": "UDF",
        "templates": {
          "UDF_ONLY_PERM_UNDEF": [
            "UDF  #<imm>"
          ]
        }
      },
      "UDIV": {
        "authored": "Unsigned Divide divides an unsigned integer register value by another unsigned\ninteger register value, and writes the result to the destination register. The\ncondition flags are not affected.",
        "heading": "UDIV",
        "templates": {
          "GENERAL": [
            "UDIV  <Wd>, <Wn>, <Wm>",
            "UDIV  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "UMADDL": {
        "authored": "Unsigned Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit\nregister value, and writes the result to the 64-bit destination register.",
        "heading": "UMADDL",
        "templates": {
          "UMADDL_64WA_DP_3SRC": [
            "UMADDL  <Xd>, <Wn>, <Wm>, <Xa>"
          ]
        }
      },
      "UMNEGL_UMSUBL": {
        "authored": "Unsigned Multiply-Negate Long multiplies two 32-bit register values, negates the\nproduct, and writes the result to the 64-bit destination register.",
        "heading": "UMNEGL",
        "templates": {
          "UMSUBL_64WA_DP_3SRC": [
            "UMNEGL  <Xd>, <Wn>, <Wm>"
          ]
        }
      },
      "UMSUBL": {
        "authored": "Unsigned Multiply-Subtract Long multiplies two 32-bit register values, subtracts\nthe product from a 64-bit register value, and writes the result to the 64-bit\ndestination register.",
        "heading": "UMSUBL",
        "templates": {
          "UMSUBL_64WA_DP_3SRC": [
            "UMSUBL  <Xd>, <Wn>, <Wm>, <Xa>"
          ]
        }
      },
      "UMULH": {
        "authored": "Unsigned Multiply High multiplies two 64-bit register values, and writes\nbits[127:64] of the 128-bit result to the 64-bit destination register.",
        "heading": "UMULH",
        "templates": {
          "UMULH_64_DP_3SRC": [
            "UMULH  <Xd>, <Xn>, <Xm>"
          ]
        }
      },
      "UMULL_UMADDL": {
        "authored": "Unsigned Multiply Long multiplies two 32-bit register values, and writes the\nresult to the 64-bit destination register.",
        "heading": "UMULL",
        "templates": {
          "UMADDL_64WA_DP_3SRC": [
            "UMULL  <Xd>, <Wn>, <Wm>"
          ]
        }
      },
      "UXTB_UBFM": {
        "authored": "Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it to\nthe size of the register, and writes the result to the destination register.",
        "heading": "UXTB",
        "templates": {
          "ZERO_FILL": [
            "UXTB  <Wd>, <Wn>"
          ]
        }
      },
      "UXTH_UBFM": {
        "authored": "Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends\nit to the size of the register, and writes the result to the destination\nregister.",
        "heading": "UXTH",
        "templates": {
          "ZERO_FILL": [
            "UXTH  <Wd>, <Wn>"
          ]
        }
      },
      "WFE": {
        "authored": "Wait For Event is a hint instruction that indicates that the PE can enter a low-\npower state and remain there until a wakeup event occurs. Wakeup events include\nthe event signaled as a result of executing the SEV instruction on any PE in the\nmultiprocessor system. For more information, see Wait For Event mechanism and\nSend event.\n\nAs described in Wait For Event mechanism and Send event, the execution of a WFE\ninstruction that would otherwise cause entry to a low-power state can be trapped\nto a higher Exception level. See:\n  - Traps to EL1 of EL0 execution of WFE and WFI instructions.\n  - Traps to EL2 of Non-secure EL0 and EL1 execution of WFE and WFI\ninstructions.\n  - Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions.",
        "heading": "WFE",
        "templates": {
          "WFE_HI_HINTS": [
            "WFE"
          ]
        }
      },
      "WFI": {
        "authored": "Wait For Interrupt is a hint instruction that indicates that the PE can enter a\nlow-power state and remain there until a wakeup event occurs. For more\ninformation, see Wait For Interrupt.\n\nAs described in Wait For Interrupt, the execution of a WFI instruction that\nwould otherwise cause entry to a low-power state can be trapped to a higher\nException level. See:\n  - Traps to EL1 of EL0 execution of WFE and WFI instructions.\n  - Traps to EL2 of Non-secure EL0 and EL1 execution of WFE and WFI\ninstructions.\n  - Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions.",
        "heading": "WFI",
        "templates": {
          "WFI_HI_HINTS": [
            "WFI"
          ]
        }
      },
      "XAFLAG": {
        "authored": "Convert floating-point condition flags from external format to Arm format. This\ninstruction converts the state of the PSTATE.{N,Z,C,V} flags from an alternative\nrepresentation required by some software to a form representing the result of an\nArm floating-point scalar compare instruction.",
        "heading": "XAFLAG",
        "templates": {
          "XAFLAG_M_PSTATE": [
            "XAFLAG"
          ]
        }
      },
      "XPAC": {
        "authored": "Strip Pointer Authentication Code. This instruction removes the pointer\nauthentication code from an address. The address is in the specified general-\npurpose register for XPACI and XPACD, and is in LR for XPACLRI.\n\nThe XPACD instruction is used for data addresses, and XPACI and XPACLRI are used\nfor instruction addresses.",
        "heading": "XPACD, XPACI, XPACLRI",
        "templates": {
          "GENERAL": [
            "XPACD  <Xd>",
            "XPACI  <Xd>"
          ],
          "XPACLRI_HI_HINTS": [
            "XPACLRI"
          ]
        }
      },
      "YIELD": {
        "authored": "YIELD is a hint instruction. Software with a multithreading capability can use a\nYIELD instruction to indicate to the PE that it is performing a task, for\nexample a spin-lock, that could be swapped out to improve overall system\nperformance. The PE can use this hint to suspend and resume multiple software\nthreads if it supports the capability.\n\nFor more information about the recommended use of this instruction, see The\nYIELD instruction.",
        "heading": "YIELD",
        "templates": {
          "YIELD_HI_HINTS": [
            "YIELD"
          ]
        }
      }
    },
    "encodings": {
      "A64": {
        "ABS_advsimd": {
          "ABS_ASIMDMISC_R": ["0x001110xx100000101110xxxxxxxxxx"],
          "ABS_ASISDMISC_R": ["01011110xx100000101110xxxxxxxxxx"]
        },
        "ADC": {
          "NO_S": ["x0011010000xxxxx000000xxxxxxxxxx"]
        },
        "ADCS": {
          "S": ["x0111010000xxxxx000000xxxxxxxxxx"]
        },
        "ADDG": {
          "ADDG_64_ADDSUB_IMMTAGS": ["1001000110xxxxxx00xxxxxxxxxxxxxx"]
        },
        "ADDHN_advsimd": {
          "ADDHN_ASIMDDIFF_N": ["0x001110xx1xxxxx010000xxxxxxxxxx"]
        },
        "ADDP_advsimd_pair": {
          "ADDP_ASISDPAIR_ONLY": ["01011110xx110001101110xxxxxxxxxx"]
        },
        "ADDP_advsimd_vec": {
          "ADDP_ASIMDSAME_ONLY": ["0x001110xx1xxxxx101111xxxxxxxxxx"]
        },
        "ADDS_addsub_ext": {
          "S": ["x0101011001xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADDS_addsub_imm": {
          "S": ["x01100010xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADDS_addsub_shift": {
          "S": ["x0101011xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADDV_advsimd": {
          "ADDV_ASIMDALL_ONLY": ["0x001110xx110001101110xxxxxxxxxx"]
        },
        "ADD_addsub_ext": {
          "NO_S": ["x0001011001xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADD_addsub_imm": {
          "NO_S": ["x00100010xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADD_addsub_shift": {
          "NO_S": ["x0001011xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADD_advsimd": {
          "ADD_ASIMDSAME_ONLY": ["0x001110xx1xxxxx100001xxxxxxxxxx"],
          "ADD_ASISDSAME_ONLY": ["01011110xx1xxxxx100001xxxxxxxxxx"]
        },
        "ADR": {
          "ADR_ONLY_PCRELADDR": ["0xx10000xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADRP": {
          "ADRP_ONLY_PCRELADDR": ["1xx10000xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "AESD_advsimd": {
          "AESD_B_CRYPTOAES": ["0100111000101000010110xxxxxxxxxx"]
        },
        "AESE_advsimd": {
          "AESE_B_CRYPTOAES": ["0100111000101000010010xxxxxxxxxx"]
        },
        "AESIMC_advsimd": {
          "AESIMC_B_CRYPTOAES": ["0100111000101000011110xxxxxxxxxx"]
        },
        "AESMC_advsimd": {
          "AESMC_B_CRYPTOAES": ["0100111000101000011010xxxxxxxxxx"]
        },
        "ANDS_log_imm": {
          "S": ["x11100100xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ANDS_log_shift": {
          "S": ["x1101010xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "AND_advsimd": {
          "AND_ASIMDSAME_ONLY": ["0x001110001xxxxx000111xxxxxxxxxx"]
        },
        "AND_log_imm": {
          "NO_S": ["x00100100xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "AND_log_shift": {
          "NO_S": ["x0001010xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ASRV": {
          "GENERAL": ["x0011010110xxxxx001010xxxxxxxxxx"]
        },
        "ASR_ASRV": {
          "GENERAL": ["x0011010110xxxxx001010xxxxxxxxxx"]
        },
        "ASR_SBFM": {
          "SIGNED_FILL": ["x00100110xxxxxxxx11111xxxxxxxxxx"]
        },
        "AT_SYS": {
          "SYS_CR_SYSTEMINSTRS": ["1101010100001xxx0111100xxxxxxxxx"]
        },
        "AUTDA": {
          "GENERAL": ["110110101100000100x110xxxxxxxxxx"]
        },
        "AUTDB": {
          "GENERAL": ["110110101100000100x111xxxxxxxxxx"]
        },
        "AUTIA": {
          "GENERAL": ["110110101100000100x100xxxxxxxxxx"],
          "SYSTEM": ["1101010100000011001000x110x11111"]
        },
        "AUTIB": {
          "GENERAL": ["110110101100000100x101xxxxxxxxxx"],
          "SYSTEM": ["1101010100000011001000x111x11111"]
        },
        "AXFLAG": {
          "AXFLAG_M_PSTATE": ["11010101000000000100000001011111"]
        },
        "BCAX_advsimd": {
          "BCAX_VVV16_CRYPTO4": ["11001110001xxxxx0xxxxxxxxxxxxxxx"]
        },
        "BFCVTN_advsimd": {
          "BFCVTN_ASIMDMISC_4S": ["0x00111010100001011010xxxxxxxxxx"]
        },
        "BFCVT_float": {
          "BFCVT_BS_FLOATDP1": ["0001111001100011010000xxxxxxxxxx"]
        },
        "BFC_BFM": {
          "NOFILL": ["x01100110xxxxxxxxxxxxx11111xxxxx"]
        },
        "BFDOT_advsimd_elt": {
          "BFDOT_ASIMDELEM_E": ["0x00111101xxxxxx1111x0xxxxxxxxxx"]
        },
        "BFDOT_advsimd_vec": {
          "BFDOT_ASIMDSAME2_D": ["0x101110010xxxxx111111xxxxxxxxxx"]
        },
        "BFI_BFM": {
          "NOFILL": ["x01100110xxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxxxxxxx11111xxxxx"]
        },
        "BFM": {
          "NOFILL": ["x01100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BFMLAL_advsimd_elt": {
          "BFMLAL_ASIMDELEM_F": ["0x00111111xxxxxx1111x0xxxxxxxxxx"]
        },
        "BFMLAL_advsimd_vec": {
          "BFMLAL_ASIMDSAME2_F_": ["0x101110110xxxxx111111xxxxxxxxxx"]
        },
        "BFMMLA_advsimd": {
          "BFMMLA_ASIMDSAME2_E": ["01101110010xxxxx111011xxxxxxxxxx"]
        },
        "BFXIL_BFM": {
          "NOFILL": ["x01100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BICS": {
          "S": ["x1101010xx1xxxxxxxxxxxxxxxxxxxxx"]
        },
        "BIC_advsimd_imm": {
          "SHIFTED_IMMEDIATE": ["0x10111100000xxxxxx101xxxxxxxxxx"]
        },
        "BIC_advsimd_reg": {
          "BIC_ASIMDSAME_ONLY": ["0x001110011xxxxx000111xxxxxxxxxx"]
        },
        "BIC_log_shift": {
          "NO_S": ["x0001010xx1xxxxxxxxxxxxxxxxxxxxx"]
        },
        "BIF_advsimd": {
          "BIF_ASIMDSAME_ONLY": ["0x101110111xxxxx000111xxxxxxxxxx"]
        },
        "BIT_advsimd": {
          "BIT_ASIMDSAME_ONLY": ["0x101110101xxxxx000111xxxxxxxxxx"]
        },
        "BL": {
          "BL_ONLY_BRANCH_IMM": ["100101xxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BLR": {
          "BLR_64_BRANCH_REG": ["1101011000111111000000xxxxx00000"]
        },
        "BLRA": {
          "GENERAL": ["1101011x0011111100001xxxxxxxxxxx"]
        },
        "BR": {
          "BR_64_BRANCH_REG": ["1101011000011111000000xxxxx00000"]
        },
        "BRA": {
          "GENERAL": ["1101011x0001111100001xxxxxxxxxxx"]
        },
        "BRK": {
          "BRK_EX_EXCEPTION": ["11010100001xxxxxxxxxxxxxxxx00000"]
        },
        "BSL_advsimd": {
          "BSL_ASIMDSAME_ONLY": ["0x101110011xxxxx000111xxxxxxxxxx"]
        },
        "BTI": {
          "BTI_HB_HINTS": ["110101010000001100100100xx011111"]
        },
        "B_cond": {
          "B_ONLY_CONDBRANCH": ["01010100xxxxxxxxxxxxxxxxxxx0xxxx"]
        },
        "B_uncond": {
          "B_ONLY_BRANCH_IMM": ["000101xxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CAS": {
          "BASE_REGISTER": ["1x0010001x1xxxxxx11111xxxxxxxxxx"]
        },
        "CASB": {
          "BASE_REGISTER": ["000010001x1xxxxxx11111xxxxxxxxxx"]
        },
        "CASH": {
          "BASE_REGISTER": ["010010001x1xxxxxx11111xxxxxxxxxx"]
        },
        "CASP": {
          "BASE_REGISTER": ["0x0010000x1xxxxxx11111xxxxxxxxxx"]
        },
        "CBNZ": {
          "BR19": ["x0110101xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CBZ": {
          "BR19": ["x0110100xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CCMN_imm": {
          "IMM5U": ["x0111010010xxxxxxxxx10xxxxx0xxxx"]
        },
        "CCMN_reg": {
          "GENERAL": ["x0111010010xxxxxxxxx00xxxxx0xxxx"]
        },
        "CCMP_imm": {
          "IMM5U": ["x1111010010xxxxxxxxx10xxxxx0xxxx"]
        },
        "CCMP_reg": {
          "GENERAL": ["x1111010010xxxxxxxxx00xxxxx0xxxx"]
        },
        "CFINV": {
          "CFINV_M_PSTATE": ["11010101000000000100000000011111"]
        },
        "CFP_SYS": {
          "SYS_CR_SYSTEMINSTRS": ["110101010000101101110011100xxxxx"]
        },
        "CINC_CSINC": {
          "GENERAL": ["x0011010100xxxxxxxxx01xxxxxxxxxx", "xxxxxxxxxxx11111xxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxxxxxxx11111xxxxx"]
        },
        "CINV_CSINV": {
          "GENERAL": ["x1011010100xxxxxxxxx00xxxxxxxxxx", "xxxxxxxxxxx11111xxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxxxxxxx11111xxxxx"]
        },
        "CLREX": {
          "CLREX_BN_BARRIERS": ["11010101000000110011xxxx01011111"]
        },
        "CLS_advsimd": {
          "CLS_ASIMDMISC_R": ["0x001110xx100000010010xxxxxxxxxx"]
        },
        "CLS_int": {
          "GENERAL": ["x101101011000000000101xxxxxxxxxx"]
        },
        "CLZ_advsimd": {
          "CLZ_ASIMDMISC_R": ["0x101110xx100000010010xxxxxxxxxx"]
        },
        "CLZ_int": {
          "GENERAL": ["x101101011000000000100xxxxxxxxxx"]
        },
        "CMEQ_advsimd_reg": {
          "CMEQ_ASIMDSAME_ONLY": ["0x101110xx1xxxxx100011xxxxxxxxxx"],
          "CMEQ_ASISDSAME_ONLY": ["01111110xx1xxxxx100011xxxxxxxxxx"]
        },
        "CMEQ_advsimd_zero": {
          "CMEQ_ASIMDMISC_Z": ["0x001110xx100000100110xxxxxxxxxx"],
          "CMEQ_ASISDMISC_Z": ["01011110xx100000100110xxxxxxxxxx"]
        },
        "CMGE_advsimd_reg": {
          "CMGE_ASIMDSAME_ONLY": ["0x001110xx1xxxxx001111xxxxxxxxxx"],
          "CMGE_ASISDSAME_ONLY": ["01011110xx1xxxxx001111xxxxxxxxxx"]
        },
        "CMGE_advsimd_zero": {
          "CMGE_ASIMDMISC_Z": ["0x101110xx100000100010xxxxxxxxxx"],
          "CMGE_ASISDMISC_Z": ["01111110xx100000100010xxxxxxxxxx"]
        },
        "CMGT_advsimd_reg": {
          "CMGT_ASIMDSAME_ONLY": ["0x001110xx1xxxxx001101xxxxxxxxxx"],
          "CMGT_ASISDSAME_ONLY": ["01011110xx1xxxxx001101xxxxxxxxxx"]
        },
        "CMGT_advsimd_zero": {
          "CMGT_ASIMDMISC_Z": ["0x001110xx100000100010xxxxxxxxxx"],
          "CMGT_ASISDMISC_Z": ["01011110xx100000100010xxxxxxxxxx"]
        },
        "CMHI_advsimd": {
          "CMHI_ASIMDSAME_ONLY": ["0x101110xx1xxxxx001101xxxxxxxxxx"],
          "CMHI_ASISDSAME_ONLY": ["01111110xx1xxxxx001101xxxxxxxxxx"]
        },
        "CMHS_advsimd": {
          "CMHS_ASIMDSAME_ONLY": ["0x101110xx1xxxxx001111xxxxxxxxxx"],
          "CMHS_ASISDSAME_ONLY": ["01111110xx1xxxxx001111xxxxxxxxxx"]
        },
        "CMLE_advsimd": {
          "CMLE_ASIMDMISC_Z": ["0x101110xx100000100110xxxxxxxxxx"],
          "CMLE_ASISDMISC_Z": ["01111110xx100000100110xxxxxxxxxx"]
        },
        "CMLT_advsimd": {
          "CMLT_ASIMDMISC_Z": ["0x001110xx100000101010xxxxxxxxxx"],
          "CMLT_ASISDMISC_Z": ["01011110xx100000101010xxxxxxxxxx"]
        },
        "CMN_ADDS_addsub_ext": {
          "S": ["x0101011001xxxxxxxxxxxxxxxx11111"]
        },
        "CMN_ADDS_addsub_imm": {
          "S": ["x01100010xxxxxxxxxxxxxxxxxx11111"]
        },
        "CMN_ADDS_addsub_shift": {
          "S": ["x0101011xx0xxxxxxxxxxxxxxxx11111"]
        },
        "CMPP_SUBPS": {
          "SUBPS_64S_DP_2SRC": ["10111010110xxxxx000000xxxxx11111"]
        },
        "CMP_SUBS_addsub_ext": {
          "S": ["x1101011001xxxxxxxxxxxxxxxx11111"]
        },
        "CMP_SUBS_addsub_imm": {
          "S": ["x11100010xxxxxxxxxxxxxxxxxx11111"]
        },
        "CMP_SUBS_addsub_shift": {
          "S": ["x1101011xx0xxxxxxxxxxxxxxxx11111"]
        },
        "CMTST_advsimd": {
          "CMTST_ASIMDSAME_ONLY": ["0x001110xx1xxxxx100011xxxxxxxxxx"],
          "CMTST_ASISDSAME_ONLY": ["01011110xx1xxxxx100011xxxxxxxxxx"]
        },
        "CNEG_CSNEG": {
          "GENERAL": ["x1011010100xxxxxxxxx01xxxxxxxxxx", "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx"]
        },
        "CNT_advsimd": {
          "CNT_ASIMDMISC_R": ["0x001110xx100000010110xxxxxxxxxx"]
        },
        "CPP_SYS": {
          "SYS_CR_SYSTEMINSTRS": ["110101010000101101110011111xxxxx"]
        },
        "CRC32": {
          "CRC": ["x0011010110xxxxx0100xxxxxxxxxxxx"]
        },
        "CRC32C": {
          "CRC": ["x0011010110xxxxx0101xxxxxxxxxxxx"]
        },
        "CSDB": {
          "CSDB_HI_HINTS": ["11010101000000110010001010011111"]
        },
        "CSEL": {
          "GENERAL": ["x0011010100xxxxxxxxx00xxxxxxxxxx"]
        },
        "CSETM_CSINV": {
          "GENERAL": ["x101101010011111xxxx0011111xxxxx", "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx"]
        },
        "CSET_CSINC": {
          "GENERAL": ["x001101010011111xxxx0111111xxxxx", "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx"]
        },
        "CSINC": {
          "GENERAL": ["x0011010100xxxxxxxxx01xxxxxxxxxx"]
        },
        "CSINV": {
          "GENERAL": ["x1011010100xxxxxxxxx00xxxxxxxxxx"]
        },
        "CSNEG": {
          "GENERAL": ["x1011010100xxxxxxxxx01xxxxxxxxxx"]
        },
        "DCPS1": {
          "DCPS1_DC_EXCEPTION": ["11010100101xxxxxxxxxxxxxxxx00001"]
        },
        "DCPS2": {
          "DCPS2_DC_EXCEPTION": ["11010100101xxxxxxxxxxxxxxxx00010"]
        },
        "DCPS3": {
          "DCPS3_DC_EXCEPTION": ["11010100101xxxxxxxxxxxxxxxx00011"]
        },
        "DC_SYS": {
          "SYS_CR_SYSTEMINSTRS": ["1101010100001xxx0111xxxxxxxxxxxx"]
        },
        "DGH": {
          "DGH_HI_HINTS": ["11010101000000110010000011011111"]
        },
        "DMB": {
          "DMB_BO_BARRIERS": ["11010101000000110011xxxx10111111"]
        },
        "DRPS": {
          "DRPS_64E_BRANCH_REG": ["11010110101111110000001111100000"]
        },
        "DSB": {
          "DSB_BO_BARRIERS": ["11010101000000110011xxxx10011111", "xxxxxxxxxxxxxxxxxxxx0x00xxxxxxxx"]
        },
        "DUP_advsimd_elt": {
          "DUP_ASIMDINS_DV_V": ["0x001110000xxxxx000001xxxxxxxxxx"],
          "DUP_ASISDONE_ONLY": ["01011110000xxxxx000001xxxxxxxxxx"]
        },
        "DUP_advsimd_gen": {
          "DUP_ASIMDINS_DR_R": ["0x001110000xxxxx000011xxxxxxxxxx"]
        },
        "DVP_SYS": {
          "SYS_CR_SYSTEMINSTRS": ["110101010000101101110011101xxxxx"]
        },
        "EON": {
          "NO_S": ["x1001010xx1xxxxxxxxxxxxxxxxxxxxx"]
        },
        "EOR3_advsimd": {
          "EOR3_VVV16_CRYPTO4": ["11001110000xxxxx0xxxxxxxxxxxxxxx"]
        },
        "EOR_advsimd": {
          "EOR_ASIMDSAME_ONLY": ["0x101110001xxxxx000111xxxxxxxxxx"]
        },
        "EOR_log_imm": {
          "NO_S": ["x10100100xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "EOR_log_shift": {
          "GENERAL": ["x1001010xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ERET": {
          "ERET_64E_BRANCH_REG": ["11010110100111110000001111100000"]
        },
        "ERETA": {
          "GENERAL": ["110101101001111100001x1111111111"]
        },
        "ESB": {
          "ESB_HI_HINTS": ["11010101000000110010001000011111"]
        },
        "EXTR": {
          "GENERAL": ["x00100111x0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "EXT_advsimd": {
          "EXT_ASIMDEXT_ONLY": ["0x101110000xxxxx0xxxx0xxxxxxxxxx"]
        },
        "FABD_advsimd": {
          "FABD_ASIMDSAMEFP16_ONLY": ["0x101110110xxxxx000101xxxxxxxxxx"],
          "FABD_ASIMDSAME_ONLY": ["0x1011101x1xxxxx110101xxxxxxxxxx"],
          "FABD_ASISDSAMEFP16_ONLY": ["01111110110xxxxx000101xxxxxxxxxx"],
          "FABD_ASISDSAME_ONLY": ["011111101x1xxxxx110101xxxxxxxxxx"]
        },
        "FABS_advsimd": {
          "FABS_ASIMDMISCFP16_R": ["0x00111011111000111110xxxxxxxxxx"],
          "FABS_ASIMDMISC_R": ["0x0011101x100000111110xxxxxxxxxx"]
        },
        "FABS_float": {
          "FLOAT": ["00011110xx100000110000xxxxxxxxxx"]
        },
        "FACGE_advsimd": {
          "FACGE_ASIMDSAMEFP16_ONLY": ["0x101110010xxxxx001011xxxxxxxxxx"],
          "FACGE_ASIMDSAME_ONLY": ["0x1011100x1xxxxx111011xxxxxxxxxx"],
          "FACGE_ASISDSAMEFP16_ONLY": ["01111110010xxxxx001011xxxxxxxxxx"],
          "FACGE_ASISDSAME_ONLY": ["011111100x1xxxxx111011xxxxxxxxxx"]
        },
        "FACGT_advsimd": {
          "FACGT_ASIMDSAMEFP16_ONLY": ["0x101110110xxxxx001011xxxxxxxxxx"],
          "FACGT_ASIMDSAME_ONLY": ["0x1011101x1xxxxx111011xxxxxxxxxx"],
          "FACGT_ASISDSAMEFP16_ONLY": ["01111110110xxxxx001011xxxxxxxxxx"],
          "FACGT_ASISDSAME_ONLY": ["011111101x1xxxxx111011xxxxxxxxxx"]
        },
        "FADDP_advsimd_pair": {
          "FADDP_ASISDPAIR_ONLY_H": ["0101111000110000110110xxxxxxxxxx"],
          "FADDP_ASISDPAIR_ONLY_SD": ["011111100x110000110110xxxxxxxxxx"]
        },
        "FADDP_advsimd_vec": {
          "FADDP_ASIMDSAMEFP16_ONLY": ["0x101110010xxxxx000101xxxxxxxxxx"],
          "FADDP_ASIMDSAME_ONLY": ["0x1011100x1xxxxx110101xxxxxxxxxx"]
        },
        "FADD_advsimd": {
          "FADD_ASIMDSAMEFP16_ONLY": ["0x001110010xxxxx000101xxxxxxxxxx"],
          "FADD_ASIMDSAME_ONLY": ["0x0011100x1xxxxx110101xxxxxxxxxx"]
        },
        "FADD_float": {
          "FLOAT": ["00011110xx1xxxxx001010xxxxxxxxxx"]
        },
        "FCADD_advsimd_vec": {
          "FCADD_ASIMDSAME2_C": ["0x101110xx0xxxxx111x01xxxxxxxxxx"]
        },
        "FCCMPE_float": {
          "FLOAT": ["00011110xx1xxxxxxxxx01xxxxx1xxxx"]
        },
        "FCCMP_float": {
          "FLOAT": ["00011110xx1xxxxxxxxx01xxxxx0xxxx"]
        },
        "FCMEQ_advsimd_reg": {
          "FCMEQ_ASIMDSAMEFP16_ONLY": ["0x001110010xxxxx001001xxxxxxxxxx"],
          "FCMEQ_ASIMDSAME_ONLY": ["0x0011100x1xxxxx111001xxxxxxxxxx"],
          "FCMEQ_ASISDSAMEFP16_ONLY": ["01011110010xxxxx001001xxxxxxxxxx"],
          "FCMEQ_ASISDSAME_ONLY": ["010111100x1xxxxx111001xxxxxxxxxx"]
        },
        "FCMEQ_advsimd_zero": {
          "FCMEQ_ASIMDMISCFP16_FZ": ["0x00111011111000110110xxxxxxxxxx"],
          "FCMEQ_ASIMDMISC_FZ": ["0x0011101x100000110110xxxxxxxxxx"],
          "FCMEQ_ASISDMISCFP16_FZ": ["0101111011111000110110xxxxxxxxxx"],
          "FCMEQ_ASISDMISC_FZ": ["010111101x100000110110xxxxxxxxxx"]
        },
        "FCMGE_advsimd_reg": {
          "FCMGE_ASIMDSAMEFP16_ONLY": ["0x101110010xxxxx001001xxxxxxxxxx"],
          "FCMGE_ASIMDSAME_ONLY": ["0x1011100x1xxxxx111001xxxxxxxxxx"],
          "FCMGE_ASISDSAMEFP16_ONLY": ["01111110010xxxxx001001xxxxxxxxxx"],
          "FCMGE_ASISDSAME_ONLY": ["011111100x1xxxxx111001xxxxxxxxxx"]
        },
        "FCMGE_advsimd_zero": {
          "FCMGE_ASIMDMISCFP16_FZ": ["0x10111011111000110010xxxxxxxxxx"],
          "FCMGE_ASIMDMISC_FZ": ["0x1011101x100000110010xxxxxxxxxx"],
          "FCMGE_ASISDMISCFP16_FZ": ["0111111011111000110010xxxxxxxxxx"],
          "FCMGE_ASISDMISC_FZ": ["011111101x100000110010xxxxxxxxxx"]
        },
        "FCMGT_advsimd_reg": {
          "FCMGT_ASIMDSAMEFP16_ONLY": ["0x101110110xxxxx001001xxxxxxxxxx"],
          "FCMGT_ASIMDSAME_ONLY": ["0x1011101x1xxxxx111001xxxxxxxxxx"],
          "FCMGT_ASISDSAMEFP16_ONLY": ["01111110110xxxxx001001xxxxxxxxxx"],
          "FCMGT_ASISDSAME_ONLY": ["011111101x1xxxxx111001xxxxxxxxxx"]
        },
        "FCMGT_advsimd_zero": {
          "FCMGT_ASIMDMISCFP16_FZ": ["0x00111011111000110010xxxxxxxxxx"],
          "FCMGT_ASIMDMISC_FZ": ["0x0011101x100000110010xxxxxxxxxx"],
          "FCMGT_ASISDMISCFP16_FZ": ["0101111011111000110010xxxxxxxxxx"],
          "FCMGT_ASISDMISC_FZ": ["010111101x100000110010xxxxxxxxxx"]
        },
        "FCMLA_advsimd_elt": {
          "2REG_ELEMENT": ["0x101111xxxxxxxx0xx1x0xxxxxxxxxx"]
        },
        "FCMLA_advsimd_vec": {
          "FCMLA_ASIMDSAME2_C": ["0x101110xx0xxxxx110xx1xxxxxxxxxx"]
        },
        "FCMLE_advsimd": {
          "FCMLE_ASIMDMISCFP16_FZ": ["0x10111011111000110110xxxxxxxxxx"],
          "FCMLE_ASIMDMISC_FZ": ["0x1011101x100000110110xxxxxxxxxx"],
          "FCMLE_ASISDMISCFP16_FZ": ["0111111011111000110110xxxxxxxxxx"],
          "FCMLE_ASISDMISC_FZ": ["011111101x100000110110xxxxxxxxxx"]
        },
        "FCMLT_advsimd": {
          "FCMLT_ASIMDMISCFP16_FZ": ["0x00111011111000111010xxxxxxxxxx"],
          "FCMLT_ASIMDMISC_FZ": ["0x0011101x100000111010xxxxxxxxxx"],
          "FCMLT_ASISDMISCFP16_FZ": ["0101111011111000111010xxxxxxxxxx"],
          "FCMLT_ASISDMISC_FZ": ["010111101x100000111010xxxxxxxxxx"]
        },
        "FCMPE_float": {
          "FLOAT": ["00011110xx1xxxxx001000xxxxx1x000"]
        },
        "FCMP_float": {
          "FLOAT": ["00011110xx1xxxxx001000xxxxx0x000"]
        },
        "FCSEL_float": {
          "FLOAT": ["00011110xx1xxxxxxxxx11xxxxxxxxxx"]
        },
        "FCVTAS_advsimd": {
          "FCVTAS_ASIMDMISCFP16_R": ["0x00111001111001110010xxxxxxxxxx"],
          "FCVTAS_ASIMDMISC_R": ["0x0011100x100001110010xxxxxxxxxx"],
          "FCVTAS_ASISDMISCFP16_R": ["0101111001111001110010xxxxxxxxxx"],
          "FCVTAS_ASISDMISC_R": ["010111100x100001110010xxxxxxxxxx"]
        },
        "FCVTAS_float": {
          "FLOAT": ["x0011110xx100100000000xxxxxxxxxx"]
        },
        "FCVTAU_advsimd": {
          "FCVTAU_ASIMDMISCFP16_R": ["0x10111001111001110010xxxxxxxxxx"],
          "FCVTAU_ASIMDMISC_R": ["0x1011100x100001110010xxxxxxxxxx"],
          "FCVTAU_ASISDMISCFP16_R": ["0111111001111001110010xxxxxxxxxx"],
          "FCVTAU_ASISDMISC_R": ["011111100x100001110010xxxxxxxxxx"]
        },
        "FCVTAU_float": {
          "FLOAT": ["x0011110xx100101000000xxxxxxxxxx"]
        },
        "FCVTL_advsimd": {
          "FCVTL_ASIMDMISC_L": ["0x0011100x100001011110xxxxxxxxxx"]
        },
        "FCVTMS_advsimd": {
          "FCVTMS_ASIMDMISCFP16_R": ["0x00111001111001101110xxxxxxxxxx"],
          "FCVTMS_ASIMDMISC_R": ["0x0011100x100001101110xxxxxxxxxx"],
          "FCVTMS_ASISDMISCFP16_R": ["0101111001111001101110xxxxxxxxxx"],
          "FCVTMS_ASISDMISC_R": ["010111100x100001101110xxxxxxxxxx"]
        },
        "FCVTMS_float": {
          "FLOAT": ["x0011110xx110000000000xxxxxxxxxx"]
        },
        "FCVTMU_advsimd": {
          "FCVTMU_ASIMDMISCFP16_R": ["0x10111001111001101110xxxxxxxxxx"],
          "FCVTMU_ASIMDMISC_R": ["0x1011100x100001101110xxxxxxxxxx"],
          "FCVTMU_ASISDMISCFP16_R": ["0111111001111001101110xxxxxxxxxx"],
          "FCVTMU_ASISDMISC_R": ["011111100x100001101110xxxxxxxxxx"]
        },
        "FCVTMU_float": {
          "FLOAT": ["x0011110xx110001000000xxxxxxxxxx"]
        },
        "FCVTNS_advsimd": {
          "FCVTNS_ASIMDMISCFP16_R": ["0x00111001111001101010xxxxxxxxxx"],
          "FCVTNS_ASIMDMISC_R": ["0x0011100x100001101010xxxxxxxxxx"],
          "FCVTNS_ASISDMISCFP16_R": ["0101111001111001101010xxxxxxxxxx"],
          "FCVTNS_ASISDMISC_R": ["010111100x100001101010xxxxxxxxxx"]
        },
        "FCVTNS_float": {
          "FLOAT": ["x0011110xx100000000000xxxxxxxxxx"]
        },
        "FCVTNU_advsimd": {
          "FCVTNU_ASIMDMISCFP16_R": ["0x10111001111001101010xxxxxxxxxx"],
          "FCVTNU_ASIMDMISC_R": ["0x1011100x100001101010xxxxxxxxxx"],
          "FCVTNU_ASISDMISCFP16_R": ["0111111001111001101010xxxxxxxxxx"],
          "FCVTNU_ASISDMISC_R": ["011111100x100001101010xxxxxxxxxx"]
        },
        "FCVTNU_float": {
          "FLOAT": ["x0011110xx100001000000xxxxxxxxxx"]
        },
        "FCVTN_advsimd": {
          "FCVTN_ASIMDMISC_N": ["0x0011100x100001011010xxxxxxxxxx"]
        },
        "FCVTPS_advsimd": {
          "FCVTPS_ASIMDMISCFP16_R": ["0x00111011111001101010xxxxxxxxxx"],
          "FCVTPS_ASIMDMISC_R": ["0x0011101x100001101010xxxxxxxxxx"],
          "FCVTPS_ASISDMISCFP16_R": ["0101111011111001101010xxxxxxxxxx"],
          "FCVTPS_ASISDMISC_R": ["010111101x100001101010xxxxxxxxxx"]
        },
        "FCVTPS_float": {
          "FLOAT": ["x0011110xx101000000000xxxxxxxxxx"]
        },
        "FCVTPU_advsimd": {
          "FCVTPU_ASIMDMISCFP16_R": ["0x10111011111001101010xxxxxxxxxx"],
          "FCVTPU_ASIMDMISC_R": ["0x1011101x100001101010xxxxxxxxxx"],
          "FCVTPU_ASISDMISCFP16_R": ["0111111011111001101010xxxxxxxxxx"],
          "FCVTPU_ASISDMISC_R": ["011111101x100001101010xxxxxxxxxx"]
        },
        "FCVTPU_float": {
          "FLOAT": ["x0011110xx101001000000xxxxxxxxxx"]
        },
        "FCVTXN_advsimd": {
          "FCVTXN_ASIMDMISC_N": ["0x1011100x100001011010xxxxxxxxxx"],
          "FCVTXN_ASISDMISC_N": ["011111100x100001011010xxxxxxxxxx"]
        },
        "FCVTZS_advsimd_fix": {
          "FCVTZS_ASIMDSHF_C": ["0x0011110xxxxxxx111111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "FCVTZS_ASISDSHF_C": ["010111110xxxxxxx111111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "FCVTZS_advsimd_int": {
          "FCVTZS_ASIMDMISCFP16_R": ["0x00111011111001101110xxxxxxxxxx"],
          "FCVTZS_ASIMDMISC_R": ["0x0011101x100001101110xxxxxxxxxx"],
          "FCVTZS_ASISDMISCFP16_R": ["0101111011111001101110xxxxxxxxxx"],
          "FCVTZS_ASISDMISC_R": ["010111101x100001101110xxxxxxxxxx"]
        },
        "FCVTZS_float_fix": {
          "FLOAT": ["x0011110xx011000xxxxxxxxxxxxxxxx"]
        },
        "FCVTZS_float_int": {
          "FLOAT": ["x0011110xx111000000000xxxxxxxxxx"]
        },
        "FCVTZU_advsimd_fix": {
          "FCVTZU_ASIMDSHF_C": ["0x1011110xxxxxxx111111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "FCVTZU_ASISDSHF_C": ["011111110xxxxxxx111111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "FCVTZU_advsimd_int": {
          "FCVTZU_ASIMDMISCFP16_R": ["0x10111011111001101110xxxxxxxxxx"],
          "FCVTZU_ASIMDMISC_R": ["0x1011101x100001101110xxxxxxxxxx"],
          "FCVTZU_ASISDMISCFP16_R": ["0111111011111001101110xxxxxxxxxx"],
          "FCVTZU_ASISDMISC_R": ["011111101x100001101110xxxxxxxxxx"]
        },
        "FCVTZU_float_fix": {
          "FLOAT": ["x0011110xx011001xxxxxxxxxxxxxxxx"]
        },
        "FCVTZU_float_int": {
          "FLOAT": ["x0011110xx111001000000xxxxxxxxxx"]
        },
        "FCVT_float": {
          "FLOAT": ["00011110xx10001xx10000xxxxxxxxxx"]
        },
        "FDIV_advsimd": {
          "FDIV_ASIMDSAMEFP16_ONLY": ["0x101110010xxxxx001111xxxxxxxxxx"],
          "FDIV_ASIMDSAME_ONLY": ["0x1011100x1xxxxx111111xxxxxxxxxx"]
        },
        "FDIV_float": {
          "FLOAT": ["00011110xx1xxxxx000110xxxxxxxxxx"]
        },
        "FJCVTZS": {
          "FJCVTZS_32D_FLOAT2INT": ["0001111001111110000000xxxxxxxxxx"]
        },
        "FMADD_float": {
          "FLOAT": ["00011111xx0xxxxx0xxxxxxxxxxxxxxx"]
        },
        "FMAXNMP_advsimd_pair": {
          "FMAXNMP_ASISDPAIR_ONLY_H": ["0101111000110000110010xxxxxxxxxx"],
          "FMAXNMP_ASISDPAIR_ONLY_SD": ["011111100x110000110010xxxxxxxxxx"]
        },
        "FMAXNMP_advsimd_vec": {
          "FMAXNMP_ASIMDSAMEFP16_ONLY": ["0x101110010xxxxx000001xxxxxxxxxx"],
          "FMAXNMP_ASIMDSAME_ONLY": ["0x1011100x1xxxxx110001xxxxxxxxxx"]
        },
        "FMAXNMV_advsimd": {
          "FMAXNMV_ASIMDALL_ONLY_H": ["0x00111000110000110010xxxxxxxxxx"],
          "FMAXNMV_ASIMDALL_ONLY_SD": ["0x1011100x110000110010xxxxxxxxxx"]
        },
        "FMAXNM_advsimd": {
          "FMAXNM_ASIMDSAMEFP16_ONLY": ["0x001110010xxxxx000001xxxxxxxxxx"],
          "FMAXNM_ASIMDSAME_ONLY": ["0x0011100x1xxxxx110001xxxxxxxxxx"]
        },
        "FMAXNM_float": {
          "FLOAT": ["00011110xx1xxxxx011010xxxxxxxxxx"]
        },
        "FMAXP_advsimd_pair": {
          "FMAXP_ASISDPAIR_ONLY_H": ["0101111000110000111110xxxxxxxxxx"],
          "FMAXP_ASISDPAIR_ONLY_SD": ["011111100x110000111110xxxxxxxxxx"]
        },
        "FMAXP_advsimd_vec": {
          "FMAXP_ASIMDSAMEFP16_ONLY": ["0x101110010xxxxx001101xxxxxxxxxx"],
          "FMAXP_ASIMDSAME_ONLY": ["0x1011100x1xxxxx111101xxxxxxxxxx"]
        },
        "FMAXV_advsimd": {
          "FMAXV_ASIMDALL_ONLY_H": ["0x00111000110000111110xxxxxxxxxx"],
          "FMAXV_ASIMDALL_ONLY_SD": ["0x1011100x110000111110xxxxxxxxxx"]
        },
        "FMAX_advsimd": {
          "FMAX_ASIMDSAMEFP16_ONLY": ["0x001110010xxxxx001101xxxxxxxxxx"],
          "FMAX_ASIMDSAME_ONLY": ["0x0011100x1xxxxx111101xxxxxxxxxx"]
        },
        "FMAX_float": {
          "FLOAT": ["00011110xx1xxxxx010010xxxxxxxxxx"]
        },
        "FMINNMP_advsimd_pair": {
          "FMINNMP_ASISDPAIR_ONLY_H": ["0101111010110000110010xxxxxxxxxx"],
          "FMINNMP_ASISDPAIR_ONLY_SD": ["011111101x110000110010xxxxxxxxxx"]
        },
        "FMINNMP_advsimd_vec": {
          "FMINNMP_ASIMDSAMEFP16_ONLY": ["0x101110110xxxxx000001xxxxxxxxxx"],
          "FMINNMP_ASIMDSAME_ONLY": ["0x1011101x1xxxxx110001xxxxxxxxxx"]
        },
        "FMINNMV_advsimd": {
          "FMINNMV_ASIMDALL_ONLY_H": ["0x00111010110000110010xxxxxxxxxx"],
          "FMINNMV_ASIMDALL_ONLY_SD": ["0x1011101x110000110010xxxxxxxxxx"]
        },
        "FMINNM_advsimd": {
          "FMINNM_ASIMDSAMEFP16_ONLY": ["0x001110110xxxxx000001xxxxxxxxxx"],
          "FMINNM_ASIMDSAME_ONLY": ["0x0011101x1xxxxx110001xxxxxxxxxx"]
        },
        "FMINNM_float": {
          "FLOAT": ["00011110xx1xxxxx011110xxxxxxxxxx"]
        },
        "FMINP_advsimd_pair": {
          "FMINP_ASISDPAIR_ONLY_H": ["0101111010110000111110xxxxxxxxxx"],
          "FMINP_ASISDPAIR_ONLY_SD": ["011111101x110000111110xxxxxxxxxx"]
        },
        "FMINP_advsimd_vec": {
          "FMINP_ASIMDSAMEFP16_ONLY": ["0x101110110xxxxx001101xxxxxxxxxx"],
          "FMINP_ASIMDSAME_ONLY": ["0x1011101x1xxxxx111101xxxxxxxxxx"]
        },
        "FMINV_advsimd": {
          "FMINV_ASIMDALL_ONLY_H": ["0x00111010110000111110xxxxxxxxxx"],
          "FMINV_ASIMDALL_ONLY_SD": ["0x1011101x110000111110xxxxxxxxxx"]
        },
        "FMIN_advsimd": {
          "FMIN_ASIMDSAMEFP16_ONLY": ["0x001110110xxxxx001101xxxxxxxxxx"],
          "FMIN_ASIMDSAME_ONLY": ["0x0011101x1xxxxx111101xxxxxxxxxx"]
        },
        "FMIN_float": {
          "FLOAT": ["00011110xx1xxxxx010110xxxxxxxxxx"]
        },
        "FMLAL_advsimd_elt": {
          "FMLAL2_ASIMDELEM_LH": ["0x10111110xxxxxx1000x0xxxxxxxxxx"],
          "FMLAL_ASIMDELEM_LH": ["0x00111110xxxxxx0000x0xxxxxxxxxx"]
        },
        "FMLAL_advsimd_vec": {
          "FMLAL2_ASIMDSAME_F": ["0x101110001xxxxx110011xxxxxxxxxx"],
          "FMLAL_ASIMDSAME_F": ["0x001110001xxxxx111011xxxxxxxxxx"]
        },
        "FMLA_advsimd_elt": {
          "FMLA_ASIMDELEM_RH_H": ["0x00111100xxxxxx0001x0xxxxxxxxxx"],
          "FMLA_ASIMDELEM_R_SD": ["0x0011111xxxxxxx0001x0xxxxxxxxxx"],
          "FMLA_ASISDELEM_RH_H": ["0101111100xxxxxx0001x0xxxxxxxxxx"],
          "FMLA_ASISDELEM_R_SD": ["010111111xxxxxxx0001x0xxxxxxxxxx"]
        },
        "FMLA_advsimd_vec": {
          "FMLA_ASIMDSAMEFP16_ONLY": ["0x001110010xxxxx000011xxxxxxxxxx"],
          "FMLA_ASIMDSAME_ONLY": ["0x0011100x1xxxxx110011xxxxxxxxxx"]
        },
        "FMLSL_advsimd_elt": {
          "FMLSL2_ASIMDELEM_LH": ["0x10111110xxxxxx1100x0xxxxxxxxxx"],
          "FMLSL_ASIMDELEM_LH": ["0x00111110xxxxxx0100x0xxxxxxxxxx"]
        },
        "FMLSL_advsimd_vec": {
          "FMLSL2_ASIMDSAME_F": ["0x101110101xxxxx110011xxxxxxxxxx"],
          "FMLSL_ASIMDSAME_F": ["0x001110101xxxxx111011xxxxxxxxxx"]
        },
        "FMLS_advsimd_elt": {
          "FMLS_ASIMDELEM_RH_H": ["0x00111100xxxxxx0101x0xxxxxxxxxx"],
          "FMLS_ASIMDELEM_R_SD": ["0x0011111xxxxxxx0101x0xxxxxxxxxx"],
          "FMLS_ASISDELEM_RH_H": ["0101111100xxxxxx0101x0xxxxxxxxxx"],
          "FMLS_ASISDELEM_R_SD": ["010111111xxxxxxx0101x0xxxxxxxxxx"]
        },
        "FMLS_advsimd_vec": {
          "FMLS_ASIMDSAMEFP16_ONLY": ["0x001110110xxxxx000011xxxxxxxxxx"],
          "FMLS_ASIMDSAME_ONLY": ["0x0011101x1xxxxx110011xxxxxxxxxx"]
        },
        "FMOV_advsimd": {
          "FMOV_ASIMDIMM_H_H": ["0x00111100000xxx111111xxxxxxxxxx"],
          "SINGLE_AND_DOUBLE": ["0xx0111100000xxx111101xxxxxxxxxx"]
        },
        "FMOV_float": {
          "FLOAT": ["00011110xx100000010000xxxxxxxxxx"]
        },
        "FMOV_float_gen": {
          "FLOAT": ["x0011110xx10x11x000000xxxxxxxxxx"]
        },
        "FMOV_float_imm": {
          "IMM8F": ["00011110xx1xxxxxxxx10000000xxxxx"]
        },
        "FMSUB_float": {
          "FLOAT": ["00011111xx0xxxxx1xxxxxxxxxxxxxxx"]
        },
        "FMULX_advsimd_elt": {
          "FMULX_ASIMDELEM_RH_H": ["0x10111100xxxxxx1001x0xxxxxxxxxx"],
          "FMULX_ASIMDELEM_R_SD": ["0x1011111xxxxxxx1001x0xxxxxxxxxx"],
          "FMULX_ASISDELEM_RH_H": ["0111111100xxxxxx1001x0xxxxxxxxxx"],
          "FMULX_ASISDELEM_R_SD": ["011111111xxxxxxx1001x0xxxxxxxxxx"]
        },
        "FMULX_advsimd_vec": {
          "FMULX_ASIMDSAMEFP16_ONLY": ["0x001110010xxxxx000111xxxxxxxxxx"],
          "FMULX_ASIMDSAME_ONLY": ["0x0011100x1xxxxx110111xxxxxxxxxx"],
          "FMULX_ASISDSAMEFP16_ONLY": ["01011110010xxxxx000111xxxxxxxxxx"],
          "FMULX_ASISDSAME_ONLY": ["010111100x1xxxxx110111xxxxxxxxxx"]
        },
        "FMUL_advsimd_elt": {
          "FMUL_ASIMDELEM_RH_H": ["0x00111100xxxxxx1001x0xxxxxxxxxx"],
          "FMUL_ASIMDELEM_R_SD": ["0x0011111xxxxxxx1001x0xxxxxxxxxx"],
          "FMUL_ASISDELEM_RH_H": ["0101111100xxxxxx1001x0xxxxxxxxxx"],
          "FMUL_ASISDELEM_R_SD": ["010111111xxxxxxx1001x0xxxxxxxxxx"]
        },
        "FMUL_advsimd_vec": {
          "FMUL_ASIMDSAMEFP16_ONLY": ["0x101110010xxxxx000111xxxxxxxxxx"],
          "FMUL_ASIMDSAME_ONLY": ["0x1011100x1xxxxx110111xxxxxxxxxx"]
        },
        "FMUL_float": {
          "FLOAT": ["00011110xx1xxxxx000010xxxxxxxxxx"]
        },
        "FNEG_advsimd": {
          "FNEG_ASIMDMISCFP16_R": ["0x10111011111000111110xxxxxxxxxx"],
          "FNEG_ASIMDMISC_R": ["0x1011101x100000111110xxxxxxxxxx"]
        },
        "FNEG_float": {
          "FLOAT": ["00011110xx100001010000xxxxxxxxxx"]
        },
        "FNMADD_float": {
          "FLOAT": ["00011111xx1xxxxx0xxxxxxxxxxxxxxx"]
        },
        "FNMSUB_float": {
          "FLOAT": ["00011111xx1xxxxx1xxxxxxxxxxxxxxx"]
        },
        "FNMUL_float": {
          "FLOAT": ["00011110xx1xxxxx100010xxxxxxxxxx"]
        },
        "FRECPE_advsimd": {
          "FRECPE_ASIMDMISCFP16_R": ["0x00111011111001110110xxxxxxxxxx"],
          "FRECPE_ASIMDMISC_R": ["0x0011101x100001110110xxxxxxxxxx"],
          "FRECPE_ASISDMISCFP16_R": ["0101111011111001110110xxxxxxxxxx"],
          "FRECPE_ASISDMISC_R": ["010111101x100001110110xxxxxxxxxx"]
        },
        "FRECPS_advsimd": {
          "FRECPS_ASIMDSAMEFP16_ONLY": ["0x001110010xxxxx001111xxxxxxxxxx"],
          "FRECPS_ASIMDSAME_ONLY": ["0x0011100x1xxxxx111111xxxxxxxxxx"],
          "FRECPS_ASISDSAMEFP16_ONLY": ["01011110010xxxxx001111xxxxxxxxxx"],
          "FRECPS_ASISDSAME_ONLY": ["010111100x1xxxxx111111xxxxxxxxxx"]
        },
        "FRECPX_advsimd": {
          "FRECPX_ASISDMISCFP16_R": ["0101111011111001111110xxxxxxxxxx"],
          "FRECPX_ASISDMISC_R": ["010111101x100001111110xxxxxxxxxx"]
        },
        "FRINT32X_advsimd": {
          "FRINT32X_ASIMDMISC_R": ["0x1011100x100001111010xxxxxxxxxx"]
        },
        "FRINT32X_float": {
          "FLOAT": ["000111100x101000110000xxxxxxxxxx"]
        },
        "FRINT32Z_advsimd": {
          "FRINT32Z_ASIMDMISC_R": ["0x0011100x100001111010xxxxxxxxxx"]
        },
        "FRINT32Z_float": {
          "FLOAT": ["000111100x101000010000xxxxxxxxxx"]
        },
        "FRINT64X_advsimd": {
          "FRINT64X_ASIMDMISC_R": ["0x1011100x100001111110xxxxxxxxxx"]
        },
        "FRINT64X_float": {
          "FLOAT": ["000111100x101001110000xxxxxxxxxx"]
        },
        "FRINT64Z_advsimd": {
          "FRINT64Z_ASIMDMISC_R": ["0x0011100x100001111110xxxxxxxxxx"]
        },
        "FRINT64Z_float": {
          "FLOAT": ["000111100x101001010000xxxxxxxxxx"]
        },
        "FRINTA_advsimd": {
          "FRINTA_ASIMDMISCFP16_R": ["0x10111001111001100010xxxxxxxxxx"],
          "FRINTA_ASIMDMISC_R": ["0x1011100x100001100010xxxxxxxxxx"]
        },
        "FRINTA_float": {
          "FLOAT": ["00011110xx100110010000xxxxxxxxxx"]
        },
        "FRINTI_advsimd": {
          "FRINTI_ASIMDMISCFP16_R": ["0x10111011111001100110xxxxxxxxxx"],
          "FRINTI_ASIMDMISC_R": ["0x1011101x100001100110xxxxxxxxxx"]
        },
        "FRINTI_float": {
          "FLOAT": ["00011110xx100111110000xxxxxxxxxx"]
        },
        "FRINTM_advsimd": {
          "FRINTM_ASIMDMISCFP16_R": ["0x00111001111001100110xxxxxxxxxx"],
          "FRINTM_ASIMDMISC_R": ["0x0011100x100001100110xxxxxxxxxx"]
        },
        "FRINTM_float": {
          "FLOAT": ["00011110xx100101010000xxxxxxxxxx"]
        },
        "FRINTN_advsimd": {
          "FRINTN_ASIMDMISCFP16_R": ["0x00111001111001100010xxxxxxxxxx"],
          "FRINTN_ASIMDMISC_R": ["0x0011100x100001100010xxxxxxxxxx"]
        },
        "FRINTN_float": {
          "FLOAT": ["00011110xx100100010000xxxxxxxxxx"]
        },
        "FRINTP_advsimd": {
          "FRINTP_ASIMDMISCFP16_R": ["0x00111011111001100010xxxxxxxxxx"],
          "FRINTP_ASIMDMISC_R": ["0x0011101x100001100010xxxxxxxxxx"]
        },
        "FRINTP_float": {
          "FLOAT": ["00011110xx100100110000xxxxxxxxxx"]
        },
        "FRINTX_advsimd": {
          "FRINTX_ASIMDMISCFP16_R": ["0x10111001111001100110xxxxxxxxxx"],
          "FRINTX_ASIMDMISC_R": ["0x1011100x100001100110xxxxxxxxxx"]
        },
        "FRINTX_float": {
          "FLOAT": ["00011110xx100111010000xxxxxxxxxx"]
        },
        "FRINTZ_advsimd": {
          "FRINTZ_ASIMDMISCFP16_R": ["0x00111011111001100110xxxxxxxxxx"],
          "FRINTZ_ASIMDMISC_R": ["0x0011101x100001100110xxxxxxxxxx"]
        },
        "FRINTZ_float": {
          "FLOAT": ["00011110xx100101110000xxxxxxxxxx"]
        },
        "FRSQRTE_advsimd": {
          "FRSQRTE_ASIMDMISCFP16_R": ["0x10111011111001110110xxxxxxxxxx"],
          "FRSQRTE_ASIMDMISC_R": ["0x1011101x100001110110xxxxxxxxxx"],
          "FRSQRTE_ASISDMISCFP16_R": ["0111111011111001110110xxxxxxxxxx"],
          "FRSQRTE_ASISDMISC_R": ["011111101x100001110110xxxxxxxxxx"]
        },
        "FRSQRTS_advsimd": {
          "FRSQRTS_ASIMDSAMEFP16_ONLY": ["0x001110110xxxxx001111xxxxxxxxxx"],
          "FRSQRTS_ASIMDSAME_ONLY": ["0x0011101x1xxxxx111111xxxxxxxxxx"],
          "FRSQRTS_ASISDSAMEFP16_ONLY": ["01011110110xxxxx001111xxxxxxxxxx"],
          "FRSQRTS_ASISDSAME_ONLY": ["010111101x1xxxxx111111xxxxxxxxxx"]
        },
        "FSQRT_advsimd": {
          "FSQRT_ASIMDMISCFP16_R": ["0x10111011111001111110xxxxxxxxxx"],
          "FSQRT_ASIMDMISC_R": ["0x1011101x100001111110xxxxxxxxxx"]
        },
        "FSQRT_float": {
          "FLOAT": ["00011110xx100001110000xxxxxxxxxx"]
        },
        "FSUB_advsimd": {
          "FSUB_ASIMDSAMEFP16_ONLY": ["0x001110110xxxxx000101xxxxxxxxxx"],
          "FSUB_ASIMDSAME_ONLY": ["0x0011101x1xxxxx110101xxxxxxxxxx"]
        },
        "FSUB_float": {
          "FLOAT": ["00011110xx1xxxxx001110xxxxxxxxxx"]
        },
        "GMI": {
          "GMI_64G_DP_2SRC": ["10011010110xxxxx000101xxxxxxxxxx"]
        },
        "HINT": {
          "HINT_HM_HINTS": ["11010101000000110010xxxxxxx11111"]
        },
        "HLT": {
          "HLT_EX_EXCEPTION": ["11010100010xxxxxxxxxxxxxxxx00000"]
        },
        "HVC": {
          "HVC_EX_EXCEPTION": ["11010100000xxxxxxxxxxxxxxxx00010"]
        },
        "IC_SYS": {
          "SYS_CR_SYSTEMINSTRS": ["1101010100001xxx0111xxxxxxxxxxxx"]
        },
        "INS_advsimd_elt": {
          "INS_ASIMDINS_IV_V": ["01101110000xxxxx0xxxx1xxxxxxxxxx"]
        },
        "INS_advsimd_gen": {
          "INS_ASIMDINS_IR_R": ["01001110000xxxxx000111xxxxxxxxxx"]
        },
        "IRG": {
          "IRG_64I_DP_2SRC": ["10011010110xxxxx000100xxxxxxxxxx"]
        },
        "ISB": {
          "ISB_BI_BARRIERS": ["11010101000000110011xxxx11011111"]
        },
        "LD1R_advsimd": {
          "AS_POST_INDEX": ["0x001101110xxxxx1100xxxxxxxxxxxx"],
          "LD1R_ASISDLSO_R1": ["0x001101010000001100xxxxxxxxxxxx"]
        },
        "LD1_advsimd_mult": {
          "AS_NO_POST_INDEX": ["0x00110001000000xx1xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001100110xxxxxxx1xxxxxxxxxxxxx"]
        },
        "LD1_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110101000000xx0xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101110xxxxxxx0xxxxxxxxxxxxx"]
        },
        "LD2R_advsimd": {
          "AS_POST_INDEX": ["0x001101111xxxxx1100xxxxxxxxxxxx"],
          "LD2R_ASISDLSO_R2": ["0x001101011000001100xxxxxxxxxxxx"]
        },
        "LD2_advsimd_mult": {
          "AS_POST_INDEX": ["0x001100110xxxxx1000xxxxxxxxxxxx"],
          "LD2_ASISDLSE_R2": ["0x001100010000001000xxxxxxxxxxxx"]
        },
        "LD2_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110101100000xx0xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101111xxxxxxx0xxxxxxxxxxxxx"]
        },
        "LD3R_advsimd": {
          "AS_POST_INDEX": ["0x001101110xxxxx1110xxxxxxxxxxxx"],
          "LD3R_ASISDLSO_R3": ["0x001101010000001110xxxxxxxxxxxx"]
        },
        "LD3_advsimd_mult": {
          "AS_POST_INDEX": ["0x001100110xxxxx0100xxxxxxxxxxxx"],
          "LD3_ASISDLSE_R3": ["0x001100010000000100xxxxxxxxxxxx"]
        },
        "LD3_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110101000000xx1xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101110xxxxxxx1xxxxxxxxxxxxx"]
        },
        "LD4R_advsimd": {
          "AS_POST_INDEX": ["0x001101111xxxxx1110xxxxxxxxxxxx"],
          "LD4R_ASISDLSO_R4": ["0x001101011000001110xxxxxxxxxxxx"]
        },
        "LD4_advsimd_mult": {
          "AS_POST_INDEX": ["0x001100110xxxxx0000xxxxxxxxxxxx"],
          "LD4_ASISDLSE_R4": ["0x001100010000000000xxxxxxxxxxxx"]
        },
        "LD4_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110101100000xx1xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101111xxxxxxx1xxxxxxxxxxxxx"]
        },
        "LDADD": {
          "GENERAL": ["1x111000xx1xxxxx000000xxxxxxxxxx"]
        },
        "LDADDB": {
          "GENERAL": ["00111000xx1xxxxx000000xxxxxxxxxx"]
        },
        "LDADDH": {
          "GENERAL": ["01111000xx1xxxxx000000xxxxxxxxxx"]
        },
        "LDAPR": {
          "GENERAL": ["1x11100010111111110000xxxxxxxxxx"]
        },
        "LDAPRB": {
          "LDAPRB_32L_MEMOP": ["0011100010111111110000xxxxxxxxxx"]
        },
        "LDAPRH": {
          "LDAPRH_32L_MEMOP": ["0111100010111111110000xxxxxxxxxx"]
        },
        "LDAPURB": {
          "LDAPURB_32_LDAPSTL_UNSCALED": ["00011001010xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDAPURH": {
          "LDAPURH_32_LDAPSTL_UNSCALED": ["01011001010xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDAPURSB": {
          "BASE_PLUS_OFFSET": ["000110011x0xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDAPURSH": {
          "BASE_PLUS_OFFSET": ["010110011x0xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDAPURSW": {
          "LDAPURSW_64_LDAPSTL_UNSCALED": ["10011001100xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDAPUR_gen": {
          "BASE_PLUS_OFFSET": ["1x011001010xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDAR": {
          "BASE_REGISTER": ["1x00100011011111111111xxxxxxxxxx"]
        },
        "LDARB": {
          "LDARB_LR32_LDSTEXCL": ["0000100011011111111111xxxxxxxxxx"]
        },
        "LDARH": {
          "LDARH_LR32_LDSTEXCL": ["0100100011011111111111xxxxxxxxxx"]
        },
        "LDAXP": {
          "BASE_REGISTER": ["1x001000011111111xxxxxxxxxxxxxxx"]
        },
        "LDAXR": {
          "BASE_REGISTER": ["1x00100001011111111111xxxxxxxxxx"]
        },
        "LDAXRB": {
          "LDAXRB_LR32_LDSTEXCL": ["0000100001011111111111xxxxxxxxxx"]
        },
        "LDAXRH": {
          "LDAXRH_LR32_LDSTEXCL": ["0100100001011111111111xxxxxxxxxx"]
        },
        "LDCLR": {
          "GENERAL": ["1x111000xx1xxxxx000100xxxxxxxxxx"]
        },
        "LDCLRB": {
          "GENERAL": ["00111000xx1xxxxx000100xxxxxxxxxx"]
        },
        "LDCLRH": {
          "GENERAL": ["01111000xx1xxxxx000100xxxxxxxxxx"]
        },
        "LDEOR": {
          "GENERAL": ["1x111000xx1xxxxx001000xxxxxxxxxx"]
        },
        "LDEORB": {
          "GENERAL": ["00111000xx1xxxxx001000xxxxxxxxxx"]
        },
        "LDEORH": {
          "GENERAL": ["01111000xx1xxxxx001000xxxxxxxxxx"]
        },
        "LDG": {
          "LDG_64LOFFSET_LDSTTAGS": ["11011001011xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDGM": {
          "LDGM_64BULK_LDSTTAGS": ["1101100111100000000000xxxxxxxxxx"]
        },
        "LDLAR": {
          "BASE_REGISTER": ["1x00100011011111011111xxxxxxxxxx"]
        },
        "LDLARB": {
          "LDLARB_LR32_LDSTEXCL": ["0000100011011111011111xxxxxxxxxx"]
        },
        "LDLARH": {
          "LDLARH_LR32_LDSTEXCL": ["0100100011011111011111xxxxxxxxxx"]
        },
        "LDNP_fpsimd": {
          "SIGNED_SCALED_OFFSET": ["xx10110001xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDNP_gen": {
          "SIGNED_SCALED_OFFSET": ["x010100001xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDPSW": {
          "LDPSW_64_LDSTPAIR_OFF": ["0110100101xxxxxxxxxxxxxxxxxxxxxx"],
          "LDPSW_64_LDSTPAIR_POST": ["0110100011xxxxxxxxxxxxxxxxxxxxxx"],
          "LDPSW_64_LDSTPAIR_PRE": ["0110100111xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDP_fpsimd": {
          "POST_INDEXED": ["xx10110011xxxxxxxxxxxxxxxxxxxxxx"],
          "PRE_INDEXED": ["xx10110111xxxxxxxxxxxxxxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["xx10110101xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDP_gen": {
          "POST_INDEXED": ["x010100011xxxxxxxxxxxxxxxxxxxxxx"],
          "PRE_INDEXED": ["x010100111xxxxxxxxxxxxxxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["x010100101xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRA": {
          "BASE_PLUS_OFFSET": ["11111000xx1xxxxxxxxxx1xxxxxxxxxx"]
        },
        "LDRB_imm": {
          "LDRB_32_LDST_IMMPOST": ["00111000010xxxxxxxxx01xxxxxxxxxx"],
          "LDRB_32_LDST_IMMPRE": ["00111000010xxxxxxxxx11xxxxxxxxxx"],
          "LDRB_32_LDST_POS": ["0011100101xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRB_reg": {
          "32": ["00111000011xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDRH_imm": {
          "LDRH_32_LDST_IMMPOST": ["01111000010xxxxxxxxx01xxxxxxxxxx"],
          "LDRH_32_LDST_IMMPRE": ["01111000010xxxxxxxxx11xxxxxxxxxx"],
          "LDRH_32_LDST_POS": ["0111100101xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRH_reg": {
          "LDRH_32_LDST_REGOFF": ["01111000011xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDRSB_imm": {
          "POST_INDEXED": ["001110001x0xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["001110001x0xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["001110011xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSB_reg": {
          "GENERAL": ["001110001x1xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDRSH_imm": {
          "POST_INDEXED": ["011110001x0xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["011110001x0xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["011110011xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSH_reg": {
          "GENERAL": ["011110001x1xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDRSW_imm": {
          "LDRSW_64_LDST_IMMPOST": ["10111000100xxxxxxxxx01xxxxxxxxxx"],
          "LDRSW_64_LDST_IMMPRE": ["10111000100xxxxxxxxx11xxxxxxxxxx"],
          "LDRSW_64_LDST_POS": ["1011100110xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSW_lit": {
          "LDRSW_64_LOADLIT": ["10011000xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSW_reg": {
          "LDRSW_64_LDST_REGOFF": ["10111000101xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDR_imm_fpsimd": {
          "POST_INDEXED": ["xx111100x10xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["xx111100x10xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["xx111101x1xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDR_imm_gen": {
          "POST_INDEXED": ["1x111000010xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["1x111000010xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["1x11100101xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDR_lit_fpsimd": {
          "LITERAL": ["xx011100xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDR_lit_gen": {
          "LITERAL": ["0x011000xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDR_reg_fpsimd": {
          "FPSIMD": ["xx111100x11xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDR_reg_gen": {
          "GENERAL": ["1x111000011xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDSET": {
          "GENERAL": ["1x111000xx1xxxxx001100xxxxxxxxxx"]
        },
        "LDSETB": {
          "GENERAL": ["00111000xx1xxxxx001100xxxxxxxxxx"]
        },
        "LDSETH": {
          "GENERAL": ["01111000xx1xxxxx001100xxxxxxxxxx"]
        },
        "LDSMAX": {
          "GENERAL": ["1x111000xx1xxxxx010000xxxxxxxxxx"]
        },
        "LDSMAXB": {
          "GENERAL": ["00111000xx1xxxxx010000xxxxxxxxxx"]
        },
        "LDSMAXH": {
          "GENERAL": ["01111000xx1xxxxx010000xxxxxxxxxx"]
        },
        "LDSMIN": {
          "GENERAL": ["1x111000xx1xxxxx010100xxxxxxxxxx"]
        },
        "LDSMINB": {
          "GENERAL": ["00111000xx1xxxxx010100xxxxxxxxxx"]
        },
        "LDSMINH": {
          "GENERAL": ["01111000xx1xxxxx010100xxxxxxxxxx"]
        },
        "LDTR": {
          "BASE_PLUS_OFFSET": ["1x111000010xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDTRB": {
          "LDTRB_32_LDST_UNPRIV": ["00111000010xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDTRH": {
          "LDTRH_32_LDST_UNPRIV": ["01111000010xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDTRSB": {
          "BASE_PLUS_OFFSET": ["001110001x0xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDTRSH": {
          "BASE_PLUS_OFFSET": ["011110001x0xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDTRSW": {
          "LDTRSW_64_LDST_UNPRIV": ["10111000100xxxxxxxxx10xxxxxxxxxx"]
        },
        "LDUMAX": {
          "GENERAL": ["1x111000xx1xxxxx011000xxxxxxxxxx"]
        },
        "LDUMAXB": {
          "GENERAL": ["00111000xx1xxxxx011000xxxxxxxxxx"]
        },
        "LDUMAXH": {
          "GENERAL": ["01111000xx1xxxxx011000xxxxxxxxxx"]
        },
        "LDUMIN": {
          "GENERAL": ["1x111000xx1xxxxx011100xxxxxxxxxx"]
        },
        "LDUMINB": {
          "GENERAL": ["00111000xx1xxxxx011100xxxxxxxxxx"]
        },
        "LDUMINH": {
          "GENERAL": ["01111000xx1xxxxx011100xxxxxxxxxx"]
        },
        "LDURB": {
          "LDURB_32_LDST_UNSCALED": ["00111000010xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDURH": {
          "LDURH_32_LDST_UNSCALED": ["01111000010xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDURSB": {
          "BASE_PLUS_OFFSET": ["001110001x0xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDURSH": {
          "BASE_PLUS_OFFSET": ["011110001x0xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDURSW": {
          "LDURSW_64_LDST_UNSCALED": ["10111000100xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDUR_fpsimd": {
          "BASE_PLUS_OFFSET": ["xx111100x10xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDUR_gen": {
          "BASE_PLUS_OFFSET": ["1x111000010xxxxxxxxx00xxxxxxxxxx"]
        },
        "LDXP": {
          "BASE_REGISTER": ["1x001000011111110xxxxxxxxxxxxxxx"]
        },
        "LDXR": {
          "BASE_REGISTER": ["1x00100001011111011111xxxxxxxxxx"]
        },
        "LDXRB": {
          "LDXRB_LR32_LDSTEXCL": ["0000100001011111011111xxxxxxxxxx"]
        },
        "LDXRH": {
          "LDXRH_LR32_LDSTEXCL": ["0100100001011111011111xxxxxxxxxx"]
        },
        "LSLV": {
          "GENERAL": ["x0011010110xxxxx001000xxxxxxxxxx"]
        },
        "LSL_LSLV": {
          "GENERAL": ["x0011010110xxxxx001000xxxxxxxxxx"]
        },
        "LSL_UBFM": {
          "ZERO_FILL": ["x10100110xxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxx11111xxxxxxxxxx"]
        },
        "LSRV": {
          "GENERAL": ["x0011010110xxxxx001001xxxxxxxxxx"]
        },
        "LSR_LSRV": {
          "GENERAL": ["x0011010110xxxxx001001xxxxxxxxxx"]
        },
        "LSR_UBFM": {
          "ZERO_FILL": ["x10100110xxxxxxxx11111xxxxxxxxxx"]
        },
        "MADD": {
          "GENERAL": ["x0011011000xxxxx0xxxxxxxxxxxxxxx"]
        },
        "MLA_advsimd_elt": {
          "MLA_ASIMDELEM_R": ["0x101111xxxxxxxx0000x0xxxxxxxxxx"]
        },
        "MLA_advsimd_vec": {
          "MLA_ASIMDSAME_ONLY": ["0x001110xx1xxxxx100101xxxxxxxxxx"]
        },
        "MLS_advsimd_elt": {
          "MLS_ASIMDELEM_R": ["0x101111xxxxxxxx0100x0xxxxxxxxxx"]
        },
        "MLS_advsimd_vec": {
          "MLS_ASIMDSAME_ONLY": ["0x101110xx1xxxxx100101xxxxxxxxxx"]
        },
        "MNEG_MSUB": {
          "GENERAL": ["x0011011000xxxxx111111xxxxxxxxxx"]
        },
        "MOVI_advsimd": {
          "ADVSIMD": ["0xx0111100000xxxxxxx01xxxxxxxxxx"]
        },
        "MOVK": {
          "IMM18_PACKED": ["x11100101xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOVN": {
          "IMM18_PACKED": ["x00100101xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOVZ": {
          "IMM18_PACKED": ["x10100101xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOV_ADD_addsub_imm": {
          "NO_S": ["x001000100000000000000xxxxxxxxxx"]
        },
        "MOV_DUP_advsimd_elt": {
          "DUP_ASISDONE_ONLY": ["01011110000xxxxx000001xxxxxxxxxx"]
        },
        "MOV_INS_advsimd_elt": {
          "INS_ASIMDINS_IV_V": ["01101110000xxxxx0xxxx1xxxxxxxxxx"]
        },
        "MOV_INS_advsimd_gen": {
          "INS_ASIMDINS_IR_R": ["01001110000xxxxx000111xxxxxxxxxx"]
        },
        "MOV_MOVN": {
          "IMM18_PACKED": ["x00100101xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOV_MOVZ": {
          "IMM18_PACKED": ["x10100101xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOV_ORR_advsimd_reg": {
          "ORR_ASIMDSAME_ONLY": ["0x001110101xxxxx000111xxxxxxxxxx"]
        },
        "MOV_ORR_log_imm": {
          "NO_S": ["x01100100xxxxxxxxxxxxx11111xxxxx"]
        },
        "MOV_ORR_log_shift": {
          "NO_S": ["x0101010000xxxxx00000011111xxxxx"]
        },
        "MOV_UMOV_advsimd": {
          "ADVSIMD": ["0x001110000xxx00001111xxxxxxxxxx"]
        },
        "MRS": {
          "MRS_RS_SYSTEMMOVE": ["110101010011xxxxxxxxxxxxxxxxxxxx"]
        },
        "MSR_imm": {
          "MSR_SI_PSTATE": ["1101010100000xxx0100xxxxxxx11111"]
        },
        "MSR_reg": {
          "MSR_SR_SYSTEMMOVE": ["110101010001xxxxxxxxxxxxxxxxxxxx"]
        },
        "MSUB": {
          "GENERAL": ["x0011011000xxxxx1xxxxxxxxxxxxxxx"]
        },
        "MUL_MADD": {
          "GENERAL": ["x0011011000xxxxx011111xxxxxxxxxx"]
        },
        "MUL_advsimd_elt": {
          "MUL_ASIMDELEM_R": ["0x001111xxxxxxxx1000x0xxxxxxxxxx"]
        },
        "MUL_advsimd_vec": {
          "MUL_ASIMDSAME_ONLY": ["0x001110xx1xxxxx100111xxxxxxxxxx"]
        },
        "MVNI_advsimd": {
          "ADVSIMD": ["0x10111100000xxxxxxx01xxxxxxxxxx"]
        },
        "MVN_NOT_advsimd": {
          "NOT_ASIMDMISC_R": ["0x10111000100000010110xxxxxxxxxx"]
        },
        "MVN_ORN_log_shift": {
          "NO_S": ["x0101010xx1xxxxxxxxxxx11111xxxxx"]
        },
        "NEGS_SUBS_addsub_shift": {
          "S": ["x1101011xx0xxxxxxxxxxx11111xxxxx"]
        },
        "NEG_SUB_addsub_shift": {
          "NO_S": ["x1001011xx0xxxxxxxxxxx11111xxxxx"]
        },
        "NEG_advsimd": {
          "NEG_ASIMDMISC_R": ["0x101110xx100000101110xxxxxxxxxx"],
          "NEG_ASISDMISC_R": ["01111110xx100000101110xxxxxxxxxx"]
        },
        "NGCS_SBCS": {
          "S": ["x1111010000xxxxx00000011111xxxxx"]
        },
        "NGC_SBC": {
          "NO_S": ["x1011010000xxxxx00000011111xxxxx"]
        },
        "NOP": {
          "NOP_HI_HINTS": ["11010101000000110010000000011111"]
        },
        "NOT_advsimd": {
          "NOT_ASIMDMISC_R": ["0x10111000100000010110xxxxxxxxxx"]
        },
        "ORN_advsimd": {
          "ORN_ASIMDSAME_ONLY": ["0x001110111xxxxx000111xxxxxxxxxx"]
        },
        "ORN_log_shift": {
          "NO_S": ["x0101010xx1xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ORR_advsimd_imm": {
          "SHIFTED_IMMEDIATE": ["0x00111100000xxxxxx101xxxxxxxxxx"]
        },
        "ORR_advsimd_reg": {
          "ORR_ASIMDSAME_ONLY": ["0x001110101xxxxx000111xxxxxxxxxx"]
        },
        "ORR_log_imm": {
          "NO_S": ["x01100100xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ORR_log_shift": {
          "NO_S": ["x0101010xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "PACDA": {
          "GENERAL": ["110110101100000100x010xxxxxxxxxx"]
        },
        "PACDB": {
          "GENERAL": ["110110101100000100x011xxxxxxxxxx"]
        },
        "PACGA": {
          "PACGA_64P_DP_2SRC": ["10011010110xxxxx001100xxxxxxxxxx"]
        },
        "PACIA": {
          "GENERAL": ["110110101100000100x000xxxxxxxxxx"],
          "SYSTEM": ["1101010100000011001000x100x11111"]
        },
        "PACIB": {
          "GENERAL": ["110110101100000100x001xxxxxxxxxx"],
          "SYSTEM": ["1101010100000011001000x101x11111"]
        },
        "PMULL_advsimd": {
          "PMULL_ASIMDDIFF_L": ["0x001110xx1xxxxx111000xxxxxxxxxx"]
        },
        "PMUL_advsimd": {
          "PMUL_ASIMDSAME_ONLY": ["0x101110xx1xxxxx100111xxxxxxxxxx"]
        },
        "PRFM_imm": {
          "PRFM_P_LDST_POS": ["1111100110xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "PRFM_lit": {
          "PRFM_P_LOADLIT": ["11011000xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "PRFM_reg": {
          "PRFM_P_LDST_REGOFF": ["11111000101xxxxxxxxx10xxxxxxxxxx"]
        },
        "PRFUM": {
          "PRFUM_P_LDST_UNSCALED": ["11111000100xxxxxxxxx00xxxxxxxxxx"]
        },
        "PSB": {
          "PSB_HC_HINTS": ["11010101000000110010001000111111"]
        },
        "PSSBB": {
          "PSSBB_ONLY_BARRIERS": ["11010101000000110011010010011111"]
        },
        "RADDHN_advsimd": {
          "RADDHN_ASIMDDIFF_N": ["0x101110xx1xxxxx010000xxxxxxxxxx"]
        },
        "RAX1_advsimd": {
          "RAX1_VVV2_CRYPTOSHA512_3": ["11001110011xxxxx100011xxxxxxxxxx"]
        },
        "RBIT_advsimd": {
          "RBIT_ASIMDMISC_R": ["0x10111001100000010110xxxxxxxxxx"]
        },
        "RBIT_int": {
          "GENERAL": ["x101101011000000000000xxxxxxxxxx"]
        },
        "RET": {
          "RET_64R_BRANCH_REG": ["1101011001011111000000xxxxx00000"]
        },
        "RETA": {
          "GENERAL": ["110101100101111100001x1111111111"]
        },
        "REV": {
          "GENERAL": ["x10110101100000000001xxxxxxxxxxx"]
        },
        "REV16_advsimd": {
          "REV16_ASIMDMISC_R": ["0x001110xx100000000110xxxxxxxxxx"]
        },
        "REV16_int": {
          "GENERAL": ["x101101011000000000001xxxxxxxxxx"]
        },
        "REV32_advsimd": {
          "REV32_ASIMDMISC_R": ["0x101110xx100000000010xxxxxxxxxx"]
        },
        "REV32_int": {
          "REV32_64_DP_1SRC": ["1101101011000000000010xxxxxxxxxx"]
        },
        "REV64_REV": {
          "GENERAL": ["1101101011000000000011xxxxxxxxxx"]
        },
        "REV64_advsimd": {
          "REV64_ASIMDMISC_R": ["0x001110xx100000000010xxxxxxxxxx"]
        },
        "RMIF": {
          "RMIF_ONLY_RMIF": ["10111010000xxxxxx00001xxxxx0xxxx"]
        },
        "RORV": {
          "GENERAL": ["x0011010110xxxxx001011xxxxxxxxxx"]
        },
        "ROR_EXTR": {
          "GENERAL": ["x00100111x0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "ROR_RORV": {
          "GENERAL": ["x0011010110xxxxx001011xxxxxxxxxx"]
        },
        "RSHRN_advsimd": {
          "RSHRN_ASIMDSHF_N": ["0x0011110xxxxxxx100011xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "RSUBHN_advsimd": {
          "RSUBHN_ASIMDDIFF_N": ["0x101110xx1xxxxx011000xxxxxxxxxx"]
        },
        "SABAL_advsimd": {
          "SABAL_ASIMDDIFF_L": ["0x001110xx1xxxxx010100xxxxxxxxxx"]
        },
        "SABA_advsimd": {
          "SABA_ASIMDSAME_ONLY": ["0x001110xx1xxxxx011111xxxxxxxxxx"]
        },
        "SABDL_advsimd": {
          "SABDL_ASIMDDIFF_L": ["0x001110xx1xxxxx011100xxxxxxxxxx"]
        },
        "SABD_advsimd": {
          "SABD_ASIMDSAME_ONLY": ["0x001110xx1xxxxx011101xxxxxxxxxx"]
        },
        "SADALP_advsimd": {
          "SADALP_ASIMDMISC_P": ["0x001110xx100000011010xxxxxxxxxx"]
        },
        "SADDLP_advsimd": {
          "SADDLP_ASIMDMISC_P": ["0x001110xx100000001010xxxxxxxxxx"]
        },
        "SADDLV_advsimd": {
          "SADDLV_ASIMDALL_ONLY": ["0x001110xx110000001110xxxxxxxxxx"]
        },
        "SADDL_advsimd": {
          "SADDL_ASIMDDIFF_L": ["0x001110xx1xxxxx000000xxxxxxxxxx"]
        },
        "SADDW_advsimd": {
          "SADDW_ASIMDDIFF_W": ["0x001110xx1xxxxx000100xxxxxxxxxx"]
        },
        "SB": {
          "SB_ONLY_BARRIERS": ["11010101000000110011000011111111"]
        },
        "SBC": {
          "NO_S": ["x1011010000xxxxx000000xxxxxxxxxx"]
        },
        "SBCS": {
          "S": ["x1111010000xxxxx000000xxxxxxxxxx"]
        },
        "SBFIZ_SBFM": {
          "SIGNED_FILL": ["x00100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SBFM": {
          "SIGNED_FILL": ["x00100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SBFX_SBFM": {
          "SIGNED_FILL": ["x00100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SCVTF_advsimd_fix": {
          "SCVTF_ASIMDSHF_C": ["0x0011110xxxxxxx111001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SCVTF_ASISDSHF_C": ["010111110xxxxxxx111001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SCVTF_advsimd_int": {
          "SCVTF_ASIMDMISCFP16_R": ["0x00111001111001110110xxxxxxxxxx"],
          "SCVTF_ASIMDMISC_R": ["0x0011100x100001110110xxxxxxxxxx"],
          "SCVTF_ASISDMISCFP16_R": ["0101111001111001110110xxxxxxxxxx"],
          "SCVTF_ASISDMISC_R": ["010111100x100001110110xxxxxxxxxx"]
        },
        "SCVTF_float_fix": {
          "FLOAT": ["x0011110xx000010xxxxxxxxxxxxxxxx"]
        },
        "SCVTF_float_int": {
          "FLOAT": ["x0011110xx100010000000xxxxxxxxxx"]
        },
        "SDIV": {
          "GENERAL": ["x0011010110xxxxx000011xxxxxxxxxx"]
        },
        "SDOT_advsimd_elt": {
          "SDOT_ASIMDELEM_D": ["0x001111xxxxxxxx1110x0xxxxxxxxxx"]
        },
        "SDOT_advsimd_vec": {
          "SDOT_ASIMDSAME2_D": ["0x001110xx0xxxxx100101xxxxxxxxxx"]
        },
        "SETF": {
          "GENERAL": ["00111010000000000x0010xxxxx01101"]
        },
        "SEV": {
          "SEV_HI_HINTS": ["11010101000000110010000010011111"]
        },
        "SEVL": {
          "SEVL_HI_HINTS": ["11010101000000110010000010111111"]
        },
        "SHA1C_advsimd": {
          "SHA1C_QSV_CRYPTOSHA3": ["01011110000xxxxx000000xxxxxxxxxx"]
        },
        "SHA1H_advsimd": {
          "SHA1H_SS_CRYPTOSHA2": ["0101111000101000000010xxxxxxxxxx"]
        },
        "SHA1M_advsimd": {
          "SHA1M_QSV_CRYPTOSHA3": ["01011110000xxxxx001000xxxxxxxxxx"]
        },
        "SHA1P_advsimd": {
          "SHA1P_QSV_CRYPTOSHA3": ["01011110000xxxxx000100xxxxxxxxxx"]
        },
        "SHA1SU0_advsimd": {
          "SHA1SU0_VVV_CRYPTOSHA3": ["01011110000xxxxx001100xxxxxxxxxx"]
        },
        "SHA1SU1_advsimd": {
          "SHA1SU1_VV_CRYPTOSHA2": ["0101111000101000000110xxxxxxxxxx"]
        },
        "SHA256H2_advsimd": {
          "SHA256H2_QQV_CRYPTOSHA3": ["01011110000xxxxx010100xxxxxxxxxx"]
        },
        "SHA256H_advsimd": {
          "SHA256H_QQV_CRYPTOSHA3": ["01011110000xxxxx010000xxxxxxxxxx"]
        },
        "SHA256SU0_advsimd": {
          "SHA256SU0_VV_CRYPTOSHA2": ["0101111000101000001010xxxxxxxxxx"]
        },
        "SHA256SU1_advsimd": {
          "SHA256SU1_VVV_CRYPTOSHA3": ["01011110000xxxxx011000xxxxxxxxxx"]
        },
        "SHA512H2_advsimd": {
          "SHA512H2_QQV_CRYPTOSHA512_3": ["11001110011xxxxx100001xxxxxxxxxx"]
        },
        "SHA512H_advsimd": {
          "SHA512H_QQV_CRYPTOSHA512_3": ["11001110011xxxxx100000xxxxxxxxxx"]
        },
        "SHA512SU0_advsimd": {
          "SHA512SU0_VV2_CRYPTOSHA512_2": ["1100111011000000100000xxxxxxxxxx"]
        },
        "SHA512SU1_advsimd": {
          "SHA512SU1_VVV2_CRYPTOSHA512_3": ["11001110011xxxxx100010xxxxxxxxxx"]
        },
        "SHADD_advsimd": {
          "SHADD_ASIMDSAME_ONLY": ["0x001110xx1xxxxx000001xxxxxxxxxx"]
        },
        "SHLL_advsimd": {
          "SHLL_ASIMDMISC_S": ["0x101110xx100001001110xxxxxxxxxx"]
        },
        "SHL_advsimd": {
          "SHL_ASIMDSHF_R": ["0x0011110xxxxxxx010101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SHL_ASISDSHF_R": ["010111110xxxxxxx010101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SHRN_advsimd": {
          "SHRN_ASIMDSHF_N": ["0x0011110xxxxxxx100001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SHSUB_advsimd": {
          "SHSUB_ASIMDSAME_ONLY": ["0x001110xx1xxxxx001001xxxxxxxxxx"]
        },
        "SLI_advsimd": {
          "SLI_ASIMDSHF_R": ["0x1011110xxxxxxx010101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SLI_ASISDSHF_R": ["011111110xxxxxxx010101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SM3PARTW1_advsimd": {
          "SM3PARTW1_VVV4_CRYPTOSHA512_3": ["11001110011xxxxx110000xxxxxxxxxx"]
        },
        "SM3PARTW2_advsimd": {
          "SM3PARTW2_VVV4_CRYPTOSHA512_3": ["11001110011xxxxx110001xxxxxxxxxx"]
        },
        "SM3SS1_advsimd": {
          "SM3SS1_VVV4_CRYPTO4": ["11001110010xxxxx0xxxxxxxxxxxxxxx"]
        },
        "SM3TT1A_advsimd": {
          "SM3TT1A_VVV4_CRYPTO3_IMM2": ["11001110010xxxxx10xx00xxxxxxxxxx"]
        },
        "SM3TT1B_advsimd": {
          "SM3TT1B_VVV4_CRYPTO3_IMM2": ["11001110010xxxxx10xx01xxxxxxxxxx"]
        },
        "SM3TT2A_advsimd": {
          "SM3TT2A_VVV4_CRYPTO3_IMM2": ["11001110010xxxxx10xx10xxxxxxxxxx"]
        },
        "SM3TT2B_advsimd": {
          "SM3TT2B_VVV_CRYPTO3_IMM2": ["11001110010xxxxx10xx11xxxxxxxxxx"]
        },
        "SM4EKEY_advsimd": {
          "SM4EKEY_VVV4_CRYPTOSHA512_3": ["11001110011xxxxx110010xxxxxxxxxx"]
        },
        "SM4E_advsimd": {
          "SM4E_VV4_CRYPTOSHA512_2": ["1100111011000000100001xxxxxxxxxx"]
        },
        "SMADDL": {
          "SMADDL_64WA_DP_3SRC": ["10011011001xxxxx0xxxxxxxxxxxxxxx"]
        },
        "SMAXP_advsimd": {
          "SMAXP_ASIMDSAME_ONLY": ["0x001110xx1xxxxx101001xxxxxxxxxx"]
        },
        "SMAXV_advsimd": {
          "SMAXV_ASIMDALL_ONLY": ["0x001110xx110000101010xxxxxxxxxx"]
        },
        "SMAX_advsimd": {
          "SMAX_ASIMDSAME_ONLY": ["0x001110xx1xxxxx011001xxxxxxxxxx"]
        },
        "SMC": {
          "SMC_EX_EXCEPTION": ["11010100000xxxxxxxxxxxxxxxx00011"]
        },
        "SMINP_advsimd": {
          "SMINP_ASIMDSAME_ONLY": ["0x001110xx1xxxxx101011xxxxxxxxxx"]
        },
        "SMINV_advsimd": {
          "SMINV_ASIMDALL_ONLY": ["0x001110xx110001101010xxxxxxxxxx"]
        },
        "SMIN_advsimd": {
          "SMIN_ASIMDSAME_ONLY": ["0x001110xx1xxxxx011011xxxxxxxxxx"]
        },
        "SMLAL_advsimd_elt": {
          "SMLAL_ASIMDELEM_L": ["0x001111xxxxxxxx0010x0xxxxxxxxxx"]
        },
        "SMLAL_advsimd_vec": {
          "SMLAL_ASIMDDIFF_L": ["0x001110xx1xxxxx100000xxxxxxxxxx"]
        },
        "SMLSL_advsimd_elt": {
          "SMLSL_ASIMDELEM_L": ["0x001111xxxxxxxx0110x0xxxxxxxxxx"]
        },
        "SMLSL_advsimd_vec": {
          "SMLSL_ASIMDDIFF_L": ["0x001110xx1xxxxx101000xxxxxxxxxx"]
        },
        "SMMLA_advsimd_vec": {
          "SMMLA_ASIMDSAME2_G": ["01001110100xxxxx101001xxxxxxxxxx"]
        },
        "SMNEGL_SMSUBL": {
          "SMSUBL_64WA_DP_3SRC": ["10011011001xxxxx111111xxxxxxxxxx"]
        },
        "SMOV_advsimd": {
          "ADVSIMD": ["0x001110000xxxxx001011xxxxxxxxxx"]
        },
        "SMSUBL": {
          "SMSUBL_64WA_DP_3SRC": ["10011011001xxxxx1xxxxxxxxxxxxxxx"]
        },
        "SMULH": {
          "SMULH_64_DP_3SRC": ["10011011010xxxxx011111xxxxxxxxxx"]
        },
        "SMULL_SMADDL": {
          "SMADDL_64WA_DP_3SRC": ["10011011001xxxxx011111xxxxxxxxxx"]
        },
        "SMULL_advsimd_elt": {
          "SMULL_ASIMDELEM_L": ["0x001111xxxxxxxx1010x0xxxxxxxxxx"]
        },
        "SMULL_advsimd_vec": {
          "SMULL_ASIMDDIFF_L": ["0x001110xx1xxxxx110000xxxxxxxxxx"]
        },
        "SQABS_advsimd": {
          "SQABS_ASIMDMISC_R": ["0x001110xx100000011110xxxxxxxxxx"],
          "SQABS_ASISDMISC_R": ["01011110xx100000011110xxxxxxxxxx"]
        },
        "SQADD_advsimd": {
          "SQADD_ASIMDSAME_ONLY": ["0x001110xx1xxxxx000011xxxxxxxxxx"],
          "SQADD_ASISDSAME_ONLY": ["01011110xx1xxxxx000011xxxxxxxxxx"]
        },
        "SQDMLAL_advsimd_elt": {
          "SQDMLAL_ASIMDELEM_L": ["0x001111xxxxxxxx0011x0xxxxxxxxxx"],
          "SQDMLAL_ASISDELEM_L": ["01011111xxxxxxxx0011x0xxxxxxxxxx"]
        },
        "SQDMLAL_advsimd_vec": {
          "SQDMLAL_ASIMDDIFF_L": ["0x001110xx1xxxxx100100xxxxxxxxxx"],
          "SQDMLAL_ASISDDIFF_ONLY": ["01011110xx1xxxxx100100xxxxxxxxxx"]
        },
        "SQDMLSL_advsimd_elt": {
          "SQDMLSL_ASIMDELEM_L": ["0x001111xxxxxxxx0111x0xxxxxxxxxx"],
          "SQDMLSL_ASISDELEM_L": ["01011111xxxxxxxx0111x0xxxxxxxxxx"]
        },
        "SQDMLSL_advsimd_vec": {
          "SQDMLSL_ASIMDDIFF_L": ["0x001110xx1xxxxx101100xxxxxxxxxx"],
          "SQDMLSL_ASISDDIFF_ONLY": ["01011110xx1xxxxx101100xxxxxxxxxx"]
        },
        "SQDMULH_advsimd_elt": {
          "SQDMULH_ASIMDELEM_R": ["0x001111xxxxxxxx1100x0xxxxxxxxxx"],
          "SQDMULH_ASISDELEM_R": ["01011111xxxxxxxx1100x0xxxxxxxxxx"]
        },
        "SQDMULH_advsimd_vec": {
          "SQDMULH_ASIMDSAME_ONLY": ["0x001110xx1xxxxx101101xxxxxxxxxx"],
          "SQDMULH_ASISDSAME_ONLY": ["01011110xx1xxxxx101101xxxxxxxxxx"]
        },
        "SQDMULL_advsimd_elt": {
          "SQDMULL_ASIMDELEM_L": ["0x001111xxxxxxxx1011x0xxxxxxxxxx"],
          "SQDMULL_ASISDELEM_L": ["01011111xxxxxxxx1011x0xxxxxxxxxx"]
        },
        "SQDMULL_advsimd_vec": {
          "SQDMULL_ASIMDDIFF_L": ["0x001110xx1xxxxx110100xxxxxxxxxx"],
          "SQDMULL_ASISDDIFF_ONLY": ["01011110xx1xxxxx110100xxxxxxxxxx"]
        },
        "SQNEG_advsimd": {
          "SQNEG_ASIMDMISC_R": ["0x101110xx100000011110xxxxxxxxxx"],
          "SQNEG_ASISDMISC_R": ["01111110xx100000011110xxxxxxxxxx"]
        },
        "SQRDMLAH_advsimd_elt": {
          "SQRDMLAH_ASIMDELEM_R": ["0x101111xxxxxxxx1101x0xxxxxxxxxx"],
          "SQRDMLAH_ASISDELEM_R": ["01111111xxxxxxxx1101x0xxxxxxxxxx"]
        },
        "SQRDMLAH_advsimd_vec": {
          "SQRDMLAH_ASIMDSAME2_ONLY": ["0x101110xx0xxxxx100001xxxxxxxxxx"],
          "SQRDMLAH_ASISDSAME2_ONLY": ["01111110xx0xxxxx100001xxxxxxxxxx"]
        },
        "SQRDMLSH_advsimd_elt": {
          "SQRDMLSH_ASIMDELEM_R": ["0x101111xxxxxxxx1111x0xxxxxxxxxx"],
          "SQRDMLSH_ASISDELEM_R": ["01111111xxxxxxxx1111x0xxxxxxxxxx"]
        },
        "SQRDMLSH_advsimd_vec": {
          "SQRDMLSH_ASIMDSAME2_ONLY": ["0x101110xx0xxxxx100011xxxxxxxxxx"],
          "SQRDMLSH_ASISDSAME2_ONLY": ["01111110xx0xxxxx100011xxxxxxxxxx"]
        },
        "SQRDMULH_advsimd_elt": {
          "SQRDMULH_ASIMDELEM_R": ["0x001111xxxxxxxx1101x0xxxxxxxxxx"],
          "SQRDMULH_ASISDELEM_R": ["01011111xxxxxxxx1101x0xxxxxxxxxx"]
        },
        "SQRDMULH_advsimd_vec": {
          "SQRDMULH_ASIMDSAME_ONLY": ["0x101110xx1xxxxx101101xxxxxxxxxx"],
          "SQRDMULH_ASISDSAME_ONLY": ["01111110xx1xxxxx101101xxxxxxxxxx"]
        },
        "SQRSHL_advsimd": {
          "SQRSHL_ASIMDSAME_ONLY": ["0x001110xx1xxxxx010111xxxxxxxxxx"],
          "SQRSHL_ASISDSAME_ONLY": ["01011110xx1xxxxx010111xxxxxxxxxx"]
        },
        "SQRSHRN_advsimd": {
          "SQRSHRN_ASIMDSHF_N": ["0x0011110xxxxxxx100111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SQRSHRN_ASISDSHF_N": ["010111110xxxxxxx100111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SQRSHRUN_advsimd": {
          "SQRSHRUN_ASIMDSHF_N": ["0x1011110xxxxxxx100011xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SQRSHRUN_ASISDSHF_N": ["011111110xxxxxxx100011xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SQSHLU_advsimd": {
          "SQSHLU_ASIMDSHF_R": ["0x1011110xxxxxxx011001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SQSHLU_ASISDSHF_R": ["011111110xxxxxxx011001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SQSHL_advsimd_imm": {
          "SQSHL_ASIMDSHF_R": ["0x0011110xxxxxxx011101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SQSHL_ASISDSHF_R": ["010111110xxxxxxx011101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SQSHL_advsimd_reg": {
          "SQSHL_ASIMDSAME_ONLY": ["0x001110xx1xxxxx010011xxxxxxxxxx"],
          "SQSHL_ASISDSAME_ONLY": ["01011110xx1xxxxx010011xxxxxxxxxx"]
        },
        "SQSHRN_advsimd": {
          "SQSHRN_ASIMDSHF_N": ["0x0011110xxxxxxx100101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SQSHRN_ASISDSHF_N": ["010111110xxxxxxx100101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SQSHRUN_advsimd": {
          "SQSHRUN_ASIMDSHF_N": ["0x1011110xxxxxxx100001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SQSHRUN_ASISDSHF_N": ["011111110xxxxxxx100001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SQSUB_advsimd": {
          "SQSUB_ASIMDSAME_ONLY": ["0x001110xx1xxxxx001011xxxxxxxxxx"],
          "SQSUB_ASISDSAME_ONLY": ["01011110xx1xxxxx001011xxxxxxxxxx"]
        },
        "SQXTN_advsimd": {
          "SQXTN_ASIMDMISC_N": ["0x001110xx100001010010xxxxxxxxxx"],
          "SQXTN_ASISDMISC_N": ["01011110xx100001010010xxxxxxxxxx"]
        },
        "SQXTUN_advsimd": {
          "SQXTUN_ASIMDMISC_N": ["0x101110xx100001001010xxxxxxxxxx"],
          "SQXTUN_ASISDMISC_N": ["01111110xx100001001010xxxxxxxxxx"]
        },
        "SRHADD_advsimd": {
          "SRHADD_ASIMDSAME_ONLY": ["0x001110xx1xxxxx000101xxxxxxxxxx"]
        },
        "SRI_advsimd": {
          "SRI_ASIMDSHF_R": ["0x1011110xxxxxxx010001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SRI_ASISDSHF_R": ["011111110xxxxxxx010001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SRSHL_advsimd": {
          "SRSHL_ASIMDSAME_ONLY": ["0x001110xx1xxxxx010101xxxxxxxxxx"],
          "SRSHL_ASISDSAME_ONLY": ["01011110xx1xxxxx010101xxxxxxxxxx"]
        },
        "SRSHR_advsimd": {
          "SRSHR_ASIMDSHF_R": ["0x0011110xxxxxxx001001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SRSHR_ASISDSHF_R": ["010111110xxxxxxx001001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SRSRA_advsimd": {
          "SRSRA_ASIMDSHF_R": ["0x0011110xxxxxxx001101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SRSRA_ASISDSHF_R": ["010111110xxxxxxx001101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SSBB": {
          "SSBB_ONLY_BARRIERS": ["11010101000000110011000010011111"]
        },
        "SSHLL_advsimd": {
          "SSHLL_ASIMDSHF_L": ["0x0011110xxxxxxx101001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SSHL_advsimd": {
          "SSHL_ASIMDSAME_ONLY": ["0x001110xx1xxxxx010001xxxxxxxxxx"],
          "SSHL_ASISDSAME_ONLY": ["01011110xx1xxxxx010001xxxxxxxxxx"]
        },
        "SSHR_advsimd": {
          "SSHR_ASIMDSHF_R": ["0x0011110xxxxxxx000001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SSHR_ASISDSHF_R": ["010111110xxxxxxx000001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SSRA_advsimd": {
          "SSRA_ASIMDSHF_R": ["0x0011110xxxxxxx000101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "SSRA_ASISDSHF_R": ["010111110xxxxxxx000101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SSUBL_advsimd": {
          "SSUBL_ASIMDDIFF_L": ["0x001110xx1xxxxx001000xxxxxxxxxx"]
        },
        "SSUBW_advsimd": {
          "SSUBW_ASIMDDIFF_W": ["0x001110xx1xxxxx001100xxxxxxxxxx"]
        },
        "ST1_advsimd_mult": {
          "AS_NO_POST_INDEX": ["0x00110000000000xx1xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001100100xxxxxxx1xxxxxxxxxxxxx"]
        },
        "ST1_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110100000000xx0xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101100xxxxxxx0xxxxxxxxxxxxx"]
        },
        "ST2G": {
          "ST2G_64SOFFSET_LDSTTAGS": ["11011001101xxxxxxxxx10xxxxxxxxxx"],
          "ST2G_64SPOST_LDSTTAGS": ["11011001101xxxxxxxxx01xxxxxxxxxx"],
          "ST2G_64SPRE_LDSTTAGS": ["11011001101xxxxxxxxx11xxxxxxxxxx"]
        },
        "ST2_advsimd_mult": {
          "AS_POST_INDEX": ["0x001100100xxxxx1000xxxxxxxxxxxx"],
          "ST2_ASISDLSE_R2": ["0x001100000000001000xxxxxxxxxxxx"]
        },
        "ST2_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110100100000xx0xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101101xxxxxxx0xxxxxxxxxxxxx"]
        },
        "ST3_advsimd_mult": {
          "AS_POST_INDEX": ["0x001100100xxxxx0100xxxxxxxxxxxx"],
          "ST3_ASISDLSE_R3": ["0x001100000000000100xxxxxxxxxxxx"]
        },
        "ST3_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110100000000xx1xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101100xxxxxxx1xxxxxxxxxxxxx"]
        },
        "ST4_advsimd_mult": {
          "AS_POST_INDEX": ["0x001100100xxxxx0000xxxxxxxxxxxx"],
          "ST4_ASISDLSE_R4": ["0x001100000000000000xxxxxxxxxxxx"]
        },
        "ST4_advsimd_sngl": {
          "AS_NO_POST_INDEX": ["0x00110100100000xx1xxxxxxxxxxxxx"],
          "AS_POST_INDEX": ["0x001101101xxxxxxx1xxxxxxxxxxxxx"]
        },
        "STADDB_LDADDB": {
          "GENERAL": ["001110000x1xxxxx000000xxxxx11111"]
        },
        "STADDH_LDADDH": {
          "GENERAL": ["011110000x1xxxxx000000xxxxx11111"]
        },
        "STADD_LDADD": {
          "GENERAL": ["1x1110000x1xxxxx000000xxxxx11111"]
        },
        "STCLRB_LDCLRB": {
          "GENERAL": ["001110000x1xxxxx000100xxxxx11111"]
        },
        "STCLRH_LDCLRH": {
          "GENERAL": ["011110000x1xxxxx000100xxxxx11111"]
        },
        "STCLR_LDCLR": {
          "GENERAL": ["1x1110000x1xxxxx000100xxxxx11111"]
        },
        "STEORB_LDEORB": {
          "GENERAL": ["001110000x1xxxxx001000xxxxx11111"]
        },
        "STEORH_LDEORH": {
          "GENERAL": ["011110000x1xxxxx001000xxxxx11111"]
        },
        "STEOR_LDEOR": {
          "GENERAL": ["1x1110000x1xxxxx001000xxxxx11111"]
        },
        "STG": {
          "STG_64SOFFSET_LDSTTAGS": ["11011001001xxxxxxxxx10xxxxxxxxxx"],
          "STG_64SPOST_LDSTTAGS": ["11011001001xxxxxxxxx01xxxxxxxxxx"],
          "STG_64SPRE_LDSTTAGS": ["11011001001xxxxxxxxx11xxxxxxxxxx"]
        },
        "STGM": {
          "STGM_64BULK_LDSTTAGS": ["1101100110100000000000xxxxxxxxxx"]
        },
        "STGP": {
          "STGP_64_LDSTPAIR_OFF": ["0110100100xxxxxxxxxxxxxxxxxxxxxx"],
          "STGP_64_LDSTPAIR_POST": ["0110100010xxxxxxxxxxxxxxxxxxxxxx"],
          "STGP_64_LDSTPAIR_PRE": ["0110100110xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STLLR": {
          "BASE_REGISTER": ["1x00100010011111011111xxxxxxxxxx"]
        },
        "STLLRB": {
          "STLLRB_SL32_LDSTEXCL": ["0000100010011111011111xxxxxxxxxx"]
        },
        "STLLRH": {
          "STLLRH_SL32_LDSTEXCL": ["0100100010011111011111xxxxxxxxxx"]
        },
        "STLR": {
          "BASE_REGISTER": ["1x00100010011111111111xxxxxxxxxx"]
        },
        "STLRB": {
          "STLRB_SL32_LDSTEXCL": ["0000100010011111111111xxxxxxxxxx"]
        },
        "STLRH": {
          "STLRH_SL32_LDSTEXCL": ["0100100010011111111111xxxxxxxxxx"]
        },
        "STLURB": {
          "STLURB_32_LDAPSTL_UNSCALED": ["00011001000xxxxxxxxx00xxxxxxxxxx"]
        },
        "STLURH": {
          "STLURH_32_LDAPSTL_UNSCALED": ["01011001000xxxxxxxxx00xxxxxxxxxx"]
        },
        "STLUR_gen": {
          "BASE_PLUS_OFFSET": ["1x011001000xxxxxxxxx00xxxxxxxxxx"]
        },
        "STLXP": {
          "BASE_REGISTER": ["1x001000001xxxxx1xxxxxxxxxxxxxxx"]
        },
        "STLXR": {
          "BASE_REGISTER": ["1x001000000xxxxx111111xxxxxxxxxx"]
        },
        "STLXRB": {
          "STLXRB_SR32_LDSTEXCL": ["00001000000xxxxx111111xxxxxxxxxx"]
        },
        "STLXRH": {
          "STLXRH_SR32_LDSTEXCL": ["01001000000xxxxx111111xxxxxxxxxx"]
        },
        "STNP_fpsimd": {
          "SIGNED_SCALED_OFFSET": ["xx10110000xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STNP_gen": {
          "SIGNED_SCALED_OFFSET": ["x010100000xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STP_fpsimd": {
          "POST_INDEXED": ["xx10110010xxxxxxxxxxxxxxxxxxxxxx"],
          "PRE_INDEXED": ["xx10110110xxxxxxxxxxxxxxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["xx10110100xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STP_gen": {
          "POST_INDEXED": ["x010100010xxxxxxxxxxxxxxxxxxxxxx"],
          "PRE_INDEXED": ["x010100110xxxxxxxxxxxxxxxxxxxxxx"],
          "SIGNED_SCALED_OFFSET": ["x010100100xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRB_imm": {
          "STRB_32_LDST_IMMPOST": ["00111000000xxxxxxxxx01xxxxxxxxxx"],
          "STRB_32_LDST_IMMPRE": ["00111000000xxxxxxxxx11xxxxxxxxxx"],
          "STRB_32_LDST_POS": ["0011100100xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRB_reg": {
          "32": ["00111000001xxxxxxxxx10xxxxxxxxxx"]
        },
        "STRH_imm": {
          "STRH_32_LDST_IMMPOST": ["01111000000xxxxxxxxx01xxxxxxxxxx"],
          "STRH_32_LDST_IMMPRE": ["01111000000xxxxxxxxx11xxxxxxxxxx"],
          "STRH_32_LDST_POS": ["0111100100xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRH_reg": {
          "STRH_32_LDST_REGOFF": ["01111000001xxxxxxxxx10xxxxxxxxxx"]
        },
        "STR_imm_fpsimd": {
          "POST_INDEXED": ["xx111100x00xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["xx111100x00xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["xx111101x0xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STR_imm_gen": {
          "POST_INDEXED": ["1x111000000xxxxxxxxx01xxxxxxxxxx"],
          "PRE_INDEXED": ["1x111000000xxxxxxxxx11xxxxxxxxxx"],
          "UNSIGNED_SCALED_OFFSET": ["1x11100100xxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STR_reg_fpsimd": {
          "FPSIMD": ["xx111100x01xxxxxxxxx10xxxxxxxxxx"]
        },
        "STR_reg_gen": {
          "GENERAL": ["1x111000001xxxxxxxxx10xxxxxxxxxx"]
        },
        "STSETB_LDSETB": {
          "GENERAL": ["001110000x1xxxxx001100xxxxx11111"]
        },
        "STSETH_LDSETH": {
          "GENERAL": ["011110000x1xxxxx001100xxxxx11111"]
        },
        "STSET_LDSET": {
          "GENERAL": ["1x1110000x1xxxxx001100xxxxx11111"]
        },
        "STSMAXB_LDSMAXB": {
          "GENERAL": ["001110000x1xxxxx010000xxxxx11111"]
        },
        "STSMAXH_LDSMAXH": {
          "GENERAL": ["011110000x1xxxxx010000xxxxx11111"]
        },
        "STSMAX_LDSMAX": {
          "GENERAL": ["1x1110000x1xxxxx010000xxxxx11111"]
        },
        "STSMINB_LDSMINB": {
          "GENERAL": ["001110000x1xxxxx010100xxxxx11111"]
        },
        "STSMINH_LDSMINH": {
          "GENERAL": ["011110000x1xxxxx010100xxxxx11111"]
        },
        "STSMIN_LDSMIN": {
          "GENERAL": ["1x1110000x1xxxxx010100xxxxx11111"]
        },
        "STTR": {
          "BASE_PLUS_OFFSET": ["1x111000000xxxxxxxxx10xxxxxxxxxx"]
        },
        "STTRB": {
          "STTRB_32_LDST_UNPRIV": ["00111000000xxxxxxxxx10xxxxxxxxxx"]
        },
        "STTRH": {
          "STTRH_32_LDST_UNPRIV": ["01111000000xxxxxxxxx10xxxxxxxxxx"]
        },
        "STUMAXB_LDUMAXB": {
          "GENERAL": ["001110000x1xxxxx011000xxxxx11111"]
        },
        "STUMAXH_LDUMAXH": {
          "GENERAL": ["011110000x1xxxxx011000xxxxx11111"]
        },
        "STUMAX_LDUMAX": {
          "GENERAL": ["1x1110000x1xxxxx011000xxxxx11111"]
        },
        "STUMINB_LDUMINB": {
          "GENERAL": ["001110000x1xxxxx011100xxxxx11111"]
        },
        "STUMINH_LDUMINH": {
          "GENERAL": ["011110000x1xxxxx011100xxxxx11111"]
        },
        "STUMIN_LDUMIN": {
          "GENERAL": ["1x1110000x1xxxxx011100xxxxx11111"]
        },
        "STURB": {
          "STURB_32_LDST_UNSCALED": ["00111000000xxxxxxxxx00xxxxxxxxxx"]
        },
        "STURH": {
          "STURH_32_LDST_UNSCALED": ["01111000000xxxxxxxxx00xxxxxxxxxx"]
        },
        "STUR_fpsimd": {
          "BASE_PLUS_OFFSET": ["xx111100x00xxxxxxxxx00xxxxxxxxxx"]
        },
        "STUR_gen": {
          "BASE_PLUS_OFFSET": ["1x111000000xxxxxxxxx00xxxxxxxxxx"]
        },
        "STXP": {
          "BASE_REGISTER": ["1x001000001xxxxx0xxxxxxxxxxxxxxx"]
        },
        "STXR": {
          "BASE_REGISTER": ["1x001000000xxxxx011111xxxxxxxxxx"]
        },
        "STXRB": {
          "STXRB_SR32_LDSTEXCL": ["00001000000xxxxx011111xxxxxxxxxx"]
        },
        "STXRH": {
          "STXRH_SR32_LDSTEXCL": ["01001000000xxxxx011111xxxxxxxxxx"]
        },
        "STZ2G": {
          "STZ2G_64SOFFSET_LDSTTAGS": ["11011001111xxxxxxxxx10xxxxxxxxxx"],
          "STZ2G_64SPOST_LDSTTAGS": ["11011001111xxxxxxxxx01xxxxxxxxxx"],
          "STZ2G_64SPRE_LDSTTAGS": ["11011001111xxxxxxxxx11xxxxxxxxxx"]
        },
        "STZG": {
          "STZG_64SOFFSET_LDSTTAGS": ["11011001011xxxxxxxxx10xxxxxxxxxx"],
          "STZG_64SPOST_LDSTTAGS": ["11011001011xxxxxxxxx01xxxxxxxxxx"],
          "STZG_64SPRE_LDSTTAGS": ["11011001011xxxxxxxxx11xxxxxxxxxx"]
        },
        "STZGM": {
          "STZGM_64BULK_LDSTTAGS": ["1101100100100000000000xxxxxxxxxx"]
        },
        "SUBG": {
          "SUBG_64_ADDSUB_IMMTAGS": ["1101000110xxxxxx00xxxxxxxxxxxxxx"]
        },
        "SUBHN_advsimd": {
          "SUBHN_ASIMDDIFF_N": ["0x001110xx1xxxxx011000xxxxxxxxxx"]
        },
        "SUBP": {
          "SUBP_64S_DP_2SRC": ["10011010110xxxxx000000xxxxxxxxxx"]
        },
        "SUBPS": {
          "SUBPS_64S_DP_2SRC": ["10111010110xxxxx000000xxxxxxxxxx"]
        },
        "SUBS_addsub_ext": {
          "S": ["x1101011001xxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUBS_addsub_imm": {
          "S": ["x11100010xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUBS_addsub_shift": {
          "S": ["x1101011xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_addsub_ext": {
          "NO_S": ["x1001011001xxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_addsub_imm": {
          "NO_S": ["x10100010xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_addsub_shift": {
          "NO_S": ["x1001011xx0xxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_advsimd": {
          "SUB_ASIMDSAME_ONLY": ["0x101110xx1xxxxx100001xxxxxxxxxx"],
          "SUB_ASISDSAME_ONLY": ["01111110xx1xxxxx100001xxxxxxxxxx"]
        },
        "SUDOT_advsimd_elt": {
          "SUDOT_ASIMDELEM_D": ["0x00111100xxxxxx1111x0xxxxxxxxxx"]
        },
        "SUQADD_advsimd": {
          "SUQADD_ASIMDMISC_R": ["0x001110xx100000001110xxxxxxxxxx"],
          "SUQADD_ASISDMISC_R": ["01011110xx100000001110xxxxxxxxxx"]
        },
        "SVC": {
          "SVC_EX_EXCEPTION": ["11010100000xxxxxxxxxxxxxxxx00001"]
        },
        "SWP": {
          "GENERAL": ["1x111000xx1xxxxx100000xxxxxxxxxx"]
        },
        "SWPB": {
          "GENERAL": ["00111000xx1xxxxx100000xxxxxxxxxx"]
        },
        "SWPH": {
          "GENERAL": ["01111000xx1xxxxx100000xxxxxxxxxx"]
        },
        "SXTB_SBFM": {
          "SIGNED_FILL": ["x00100110x000000000111xxxxxxxxxx"]
        },
        "SXTH_SBFM": {
          "SIGNED_FILL": ["x00100110x000000001111xxxxxxxxxx"]
        },
        "SXTL_SSHLL_advsimd": {
          "SSHLL_ASIMDSHF_L": ["0x0011110xxxx000101001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "SXTW_SBFM": {
          "SIGNED_FILL": ["1001001101000000011111xxxxxxxxxx"]
        },
        "SYS": {
          "SYS_CR_SYSTEMINSTRS": ["1101010100001xxxxxxxxxxxxxxxxxxx"]
        },
        "SYSL": {
          "SYSL_RC_SYSTEMINSTRS": ["1101010100101xxxxxxxxxxxxxxxxxxx"]
        },
        "TBL_advsimd": {
          "ADVSIMD": ["0x001110000xxxxx0xx000xxxxxxxxxx"]
        },
        "TBNZ": {
          "TBNZ_ONLY_TESTBRANCH": ["x0110111xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "TBX_advsimd": {
          "ADVSIMD": ["0x001110000xxxxx0xx100xxxxxxxxxx"]
        },
        "TBZ": {
          "TBZ_ONLY_TESTBRANCH": ["x0110110xxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "TLBI_SYS": {
          "SYS_CR_SYSTEMINSTRS": ["1101010100001xxx1000xxxxxxxxxxxx"]
        },
        "TRN1_advsimd": {
          "TRN1_ASIMDPERM_ONLY": ["0x001110xx0xxxxx001010xxxxxxxxxx"]
        },
        "TRN2_advsimd": {
          "TRN2_ASIMDPERM_ONLY": ["0x001110xx0xxxxx011010xxxxxxxxxx"]
        },
        "TSB": {
          "TSB_HC_HINTS": ["11010101000000110010001001011111"]
        },
        "TST_ANDS_log_imm": {
          "S": ["x11100100xxxxxxxxxxxxxxxxxx11111"]
        },
        "TST_ANDS_log_shift": {
          "S": ["x1101010xx0xxxxxxxxxxxxxxxx11111"]
        },
        "UABAL_advsimd": {
          "UABAL_ASIMDDIFF_L": ["0x101110xx1xxxxx010100xxxxxxxxxx"]
        },
        "UABA_advsimd": {
          "UABA_ASIMDSAME_ONLY": ["0x101110xx1xxxxx011111xxxxxxxxxx"]
        },
        "UABDL_advsimd": {
          "UABDL_ASIMDDIFF_L": ["0x101110xx1xxxxx011100xxxxxxxxxx"]
        },
        "UABD_advsimd": {
          "UABD_ASIMDSAME_ONLY": ["0x101110xx1xxxxx011101xxxxxxxxxx"]
        },
        "UADALP_advsimd": {
          "UADALP_ASIMDMISC_P": ["0x101110xx100000011010xxxxxxxxxx"]
        },
        "UADDLP_advsimd": {
          "UADDLP_ASIMDMISC_P": ["0x101110xx100000001010xxxxxxxxxx"]
        },
        "UADDLV_advsimd": {
          "UADDLV_ASIMDALL_ONLY": ["0x101110xx110000001110xxxxxxxxxx"]
        },
        "UADDL_advsimd": {
          "UADDL_ASIMDDIFF_L": ["0x101110xx1xxxxx000000xxxxxxxxxx"]
        },
        "UADDW_advsimd": {
          "UADDW_ASIMDDIFF_W": ["0x101110xx1xxxxx000100xxxxxxxxxx"]
        },
        "UBFIZ_UBFM": {
          "ZERO_FILL": ["x10100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UBFM": {
          "ZERO_FILL": ["x10100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UBFX_UBFM": {
          "ZERO_FILL": ["x10100110xxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UCVTF_advsimd_fix": {
          "UCVTF_ASIMDSHF_C": ["0x1011110xxxxxxx111001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "UCVTF_ASISDSHF_C": ["011111110xxxxxxx111001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "UCVTF_advsimd_int": {
          "UCVTF_ASIMDMISCFP16_R": ["0x10111001111001110110xxxxxxxxxx"],
          "UCVTF_ASIMDMISC_R": ["0x1011100x100001110110xxxxxxxxxx"],
          "UCVTF_ASISDMISCFP16_R": ["0111111001111001110110xxxxxxxxxx"],
          "UCVTF_ASISDMISC_R": ["011111100x100001110110xxxxxxxxxx"]
        },
        "UCVTF_float_fix": {
          "FLOAT": ["x0011110xx000011xxxxxxxxxxxxxxxx"]
        },
        "UCVTF_float_int": {
          "FLOAT": ["x0011110xx100011000000xxxxxxxxxx"]
        },
        "UDF_perm_undef": {
          "UDF_ONLY_PERM_UNDEF": ["0000000000000000xxxxxxxxxxxxxxxx"]
        },
        "UDIV": {
          "GENERAL": ["x0011010110xxxxx000010xxxxxxxxxx"]
        },
        "UDOT_advsimd_elt": {
          "UDOT_ASIMDELEM_D": ["0x101111xxxxxxxx1110x0xxxxxxxxxx"]
        },
        "UDOT_advsimd_vec": {
          "UDOT_ASIMDSAME2_D": ["0x101110xx0xxxxx100101xxxxxxxxxx"]
        },
        "UHADD_advsimd": {
          "UHADD_ASIMDSAME_ONLY": ["0x101110xx1xxxxx000001xxxxxxxxxx"]
        },
        "UHSUB_advsimd": {
          "UHSUB_ASIMDSAME_ONLY": ["0x101110xx1xxxxx001001xxxxxxxxxx"]
        },
        "UMADDL": {
          "UMADDL_64WA_DP_3SRC": ["10011011101xxxxx0xxxxxxxxxxxxxxx"]
        },
        "UMAXP_advsimd": {
          "UMAXP_ASIMDSAME_ONLY": ["0x101110xx1xxxxx101001xxxxxxxxxx"]
        },
        "UMAXV_advsimd": {
          "UMAXV_ASIMDALL_ONLY": ["0x101110xx110000101010xxxxxxxxxx"]
        },
        "UMAX_advsimd": {
          "UMAX_ASIMDSAME_ONLY": ["0x101110xx1xxxxx011001xxxxxxxxxx"]
        },
        "UMINP_advsimd": {
          "UMINP_ASIMDSAME_ONLY": ["0x101110xx1xxxxx101011xxxxxxxxxx"]
        },
        "UMINV_advsimd": {
          "UMINV_ASIMDALL_ONLY": ["0x101110xx110001101010xxxxxxxxxx"]
        },
        "UMIN_advsimd": {
          "UMIN_ASIMDSAME_ONLY": ["0x101110xx1xxxxx011011xxxxxxxxxx"]
        },
        "UMLAL_advsimd_elt": {
          "UMLAL_ASIMDELEM_L": ["0x101111xxxxxxxx0010x0xxxxxxxxxx"]
        },
        "UMLAL_advsimd_vec": {
          "UMLAL_ASIMDDIFF_L": ["0x101110xx1xxxxx100000xxxxxxxxxx"]
        },
        "UMLSL_advsimd_elt": {
          "UMLSL_ASIMDELEM_L": ["0x101111xxxxxxxx0110x0xxxxxxxxxx"]
        },
        "UMLSL_advsimd_vec": {
          "UMLSL_ASIMDDIFF_L": ["0x101110xx1xxxxx101000xxxxxxxxxx"]
        },
        "UMMLA_advsimd_vec": {
          "UMMLA_ASIMDSAME2_G": ["01101110100xxxxx101001xxxxxxxxxx"]
        },
        "UMNEGL_UMSUBL": {
          "UMSUBL_64WA_DP_3SRC": ["10011011101xxxxx111111xxxxxxxxxx"]
        },
        "UMOV_advsimd": {
          "ADVSIMD": ["0x001110000xxxxx001111xxxxxxxxxx"]
        },
        "UMSUBL": {
          "UMSUBL_64WA_DP_3SRC": ["10011011101xxxxx1xxxxxxxxxxxxxxx"]
        },
        "UMULH": {
          "UMULH_64_DP_3SRC": ["10011011110xxxxx011111xxxxxxxxxx"]
        },
        "UMULL_UMADDL": {
          "UMADDL_64WA_DP_3SRC": ["10011011101xxxxx011111xxxxxxxxxx"]
        },
        "UMULL_advsimd_elt": {
          "UMULL_ASIMDELEM_L": ["0x101111xxxxxxxx1010x0xxxxxxxxxx"]
        },
        "UMULL_advsimd_vec": {
          "UMULL_ASIMDDIFF_L": ["0x101110xx1xxxxx110000xxxxxxxxxx"]
        },
        "UQADD_advsimd": {
          "UQADD_ASIMDSAME_ONLY": ["0x101110xx1xxxxx000011xxxxxxxxxx"],
          "UQADD_ASISDSAME_ONLY": ["01111110xx1xxxxx000011xxxxxxxxxx"]
        },
        "UQRSHL_advsimd": {
          "UQRSHL_ASIMDSAME_ONLY": ["0x101110xx1xxxxx010111xxxxxxxxxx"],
          "UQRSHL_ASISDSAME_ONLY": ["01111110xx1xxxxx010111xxxxxxxxxx"]
        },
        "UQRSHRN_advsimd": {
          "UQRSHRN_ASIMDSHF_N": ["0x1011110xxxxxxx100111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "UQRSHRN_ASISDSHF_N": ["011111110xxxxxxx100111xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "UQSHL_advsimd_imm": {
          "UQSHL_ASIMDSHF_R": ["0x1011110xxxxxxx011101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "UQSHL_ASISDSHF_R": ["011111110xxxxxxx011101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "UQSHL_advsimd_reg": {
          "UQSHL_ASIMDSAME_ONLY": ["0x101110xx1xxxxx010011xxxxxxxxxx"],
          "UQSHL_ASISDSAME_ONLY": ["01111110xx1xxxxx010011xxxxxxxxxx"]
        },
        "UQSHRN_advsimd": {
          "UQSHRN_ASIMDSHF_N": ["0x1011110xxxxxxx100101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "UQSHRN_ASISDSHF_N": ["011111110xxxxxxx100101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "UQSUB_advsimd": {
          "UQSUB_ASIMDSAME_ONLY": ["0x101110xx1xxxxx001011xxxxxxxxxx"],
          "UQSUB_ASISDSAME_ONLY": ["01111110xx1xxxxx001011xxxxxxxxxx"]
        },
        "UQXTN_advsimd": {
          "UQXTN_ASIMDMISC_N": ["0x101110xx100001010010xxxxxxxxxx"],
          "UQXTN_ASISDMISC_N": ["01111110xx100001010010xxxxxxxxxx"]
        },
        "URECPE_advsimd": {
          "URECPE_ASIMDMISC_R": ["0x0011101x100001110010xxxxxxxxxx"]
        },
        "URHADD_advsimd": {
          "URHADD_ASIMDSAME_ONLY": ["0x101110xx1xxxxx000101xxxxxxxxxx"]
        },
        "URSHL_advsimd": {
          "URSHL_ASIMDSAME_ONLY": ["0x101110xx1xxxxx010101xxxxxxxxxx"],
          "URSHL_ASISDSAME_ONLY": ["01111110xx1xxxxx010101xxxxxxxxxx"]
        },
        "URSHR_advsimd": {
          "URSHR_ASIMDSHF_R": ["0x1011110xxxxxxx001001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "URSHR_ASISDSHF_R": ["011111110xxxxxxx001001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "URSQRTE_advsimd": {
          "URSQRTE_ASIMDMISC_R": ["0x1011101x100001110010xxxxxxxxxx"]
        },
        "URSRA_advsimd": {
          "URSRA_ASIMDSHF_R": ["0x1011110xxxxxxx001101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "URSRA_ASISDSHF_R": ["011111110xxxxxxx001101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "USDOT_advsimd_elt": {
          "USDOT_ASIMDELEM_D": ["0x00111110xxxxxx1111x0xxxxxxxxxx"]
        },
        "USDOT_advsimd_vec": {
          "USDOT_ASIMDSAME2_D": ["0x001110100xxxxx100111xxxxxxxxxx"]
        },
        "USHLL_advsimd": {
          "USHLL_ASIMDSHF_L": ["0x1011110xxxxxxx101001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "USHL_advsimd": {
          "USHL_ASIMDSAME_ONLY": ["0x101110xx1xxxxx010001xxxxxxxxxx"],
          "USHL_ASISDSAME_ONLY": ["01111110xx1xxxxx010001xxxxxxxxxx"]
        },
        "USHR_advsimd": {
          "USHR_ASIMDSHF_R": ["0x1011110xxxxxxx000001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "USHR_ASISDSHF_R": ["011111110xxxxxxx000001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "USMMLA_advsimd_vec": {
          "USMMLA_ASIMDSAME2_G": ["01001110100xxxxx101011xxxxxxxxxx"]
        },
        "USQADD_advsimd": {
          "USQADD_ASIMDMISC_R": ["0x101110xx100000001110xxxxxxxxxx"],
          "USQADD_ASISDMISC_R": ["01111110xx100000001110xxxxxxxxxx"]
        },
        "USRA_advsimd": {
          "USRA_ASIMDSHF_R": ["0x1011110xxxxxxx000101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"],
          "USRA_ASISDSHF_R": ["011111110xxxxxxx000101xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "USUBL_advsimd": {
          "USUBL_ASIMDDIFF_L": ["0x101110xx1xxxxx001000xxxxxxxxxx"]
        },
        "USUBW_advsimd": {
          "USUBW_ASIMDDIFF_W": ["0x101110xx1xxxxx001100xxxxxxxxxx"]
        },
        "UXTB_UBFM": {
          "ZERO_FILL": ["0101001100000000000111xxxxxxxxxx"]
        },
        "UXTH_UBFM": {
          "ZERO_FILL": ["0101001100000000001111xxxxxxxxxx"]
        },
        "UXTL_USHLL_advsimd": {
          "USHLL_ASIMDSHF_L": ["0x1011110xxxx000101001xxxxxxxxxx", "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"]
        },
        "UZP1_advsimd": {
          "UZP1_ASIMDPERM_ONLY": ["0x001110xx0xxxxx000110xxxxxxxxxx"]
        },
        "UZP2_advsimd": {
          "UZP2_ASIMDPERM_ONLY": ["0x001110xx0xxxxx010110xxxxxxxxxx"]
        },
        "WFE": {
          "WFE_HI_HINTS": ["11010101000000110010000001011111"]
        },
        "WFI": {
          "WFI_HI_HINTS": ["11010101000000110010000001111111"]
        },
        "XAFLAG": {
          "XAFLAG_M_PSTATE": ["11010101000000000100000000111111"]
        },
        "XAR_advsimd": {
          "XAR_VVV2_CRYPTO3_IMM6": ["11001110100xxxxxxxxxxxxxxxxxxxxx"]
        },
        "XPAC": {
          "GENERAL": ["110110101100000101000x11111xxxxx"],
          "XPACLRI_HI_HINTS": ["11010101000000110010000011111111"]
        },
        "XTN_advsimd": {
          "XTN_ASIMDMISC_N": ["0x001110xx100001001010xxxxxxxxxx"]
        },
        "YIELD": {
          "YIELD_HI_HINTS": ["11010101000000110010000000111111"]
        },
        "ZIP1_advsimd": {
          "ZIP1_ASIMDPERM_ONLY": ["0x001110xx0xxxxx001110xxxxxxxxxx"]
        },
        "ZIP2_advsimd": {
          "ZIP2_ASIMDPERM_ONLY": ["0x001110xx0xxxxx011110xxxxxxxxxx"]
        }
      }
    },
    "simd_fp": {
      "ABS_advsimd": {
        "authored": "Absolute value (vector). This instruction calculates the absolute value of each\nvector element in the source SIMD&FP register, puts the result into a vector,\nand writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ABS",
        "templates": {
          "ABS_ASIMDMISC_R": [
            "ABS  <Vd>.<T>, <Vn>.<T>"
          ],
          "ABS_ASISDMISC_R": [
            "ABS  <V><d>, <V><n>"
          ]
        }
      },
      "ADDHN_advsimd": {
        "authored": "Add returning High Narrow. This instruction adds each vector element in the\nfirst source SIMD&FP register to the corresponding vector element in the second\nsource SIMD&FP register, places the most significant half of the result into a\nvector, and writes the vector to the lower or upper half of the destination\nSIMD&FP register.\n\nThe results are truncated. For rounded results, see RADDHN.\n\nThe ADDHN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the ADDHN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ADDHN, ADDHN2",
        "templates": {
          "ADDHN_ASIMDDIFF_N": [
            "ADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
          ]
        }
      },
      "ADDP_advsimd_pair": {
        "authored": "Add Pair of elements (scalar). This instruction adds two vector elements in the\nsource SIMD&FP register and writes the scalar result into the destination\nSIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ADDP (scalar)",
        "templates": {
          "ADDP_ASISDPAIR_ONLY": [
            "ADDP  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "ADDP_advsimd_vec": {
        "authored": "Add Pairwise (vector). This instruction creates a vector by concatenating the\nvector elements of the first source SIMD&FP register after the vector elements\nof the second source SIMD&FP register, reads each pair of adjacent vector\nelements from the concatenated vector, adds each pair of values together, places\nthe result into a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ADDP (vector)",
        "templates": {
          "ADDP_ASIMDSAME_ONLY": [
            "ADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "ADDV_advsimd": {
        "authored": "Add across Vector. This instruction adds every vector element in the source\nSIMD&FP register together, and writes the scalar result to the destination\nSIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ADDV",
        "templates": {
          "ADDV_ASIMDALL_ONLY": [
            "ADDV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "ADD_advsimd": {
        "authored": "Add (vector). This instruction adds corresponding elements in the two source\nSIMD&FP registers, places the results into a vector, and writes the vector to\nthe destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ADD (vector)",
        "templates": {
          "ADD_ASIMDSAME_ONLY": [
            "ADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "ADD_ASISDSAME_ONLY": [
            "ADD  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "AESD_advsimd": {
        "authored": "AES single round decryption.",
        "heading": "AESD",
        "templates": {
          "AESD_B_CRYPTOAES": [
            "AESD  <Vd>.16B, <Vn>.16B"
          ]
        }
      },
      "AESE_advsimd": {
        "authored": "AES single round encryption.",
        "heading": "AESE",
        "templates": {
          "AESE_B_CRYPTOAES": [
            "AESE  <Vd>.16B, <Vn>.16B"
          ]
        }
      },
      "AESIMC_advsimd": {
        "authored": "AES inverse mix columns.",
        "heading": "AESIMC",
        "templates": {
          "AESIMC_B_CRYPTOAES": [
            "AESIMC  <Vd>.16B, <Vn>.16B"
          ]
        }
      },
      "AESMC_advsimd": {
        "authored": "AES mix columns.",
        "heading": "AESMC",
        "templates": {
          "AESMC_B_CRYPTOAES": [
            "AESMC  <Vd>.16B, <Vn>.16B"
          ]
        }
      },
      "AND_advsimd": {
        "authored": "Bitwise AND (vector). This instruction performs a bitwise AND between the two\nsource SIMD&FP registers, and writes the result to the destination SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "AND (vector)",
        "templates": {
          "AND_ASIMDSAME_ONLY": [
            "AND  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "BCAX_advsimd": {
        "authored": "Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a\nsource SIMD&FP register and the complement of the vector in another source\nSIMD&FP register, then performs a bitwise exclusive OR of the resulting vector\nand the vector in a third source SIMD&FP register, and writes the result to the\ndestination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.",
        "heading": "BCAX",
        "templates": {
          "BCAX_VVV16_CRYPTO4": [
            "BCAX  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B"
          ]
        }
      },
      "BFCVTN_advsimd": {
        "authored": "Floating-point convert from single-precision to BFloat16 format (vector) reads\neach single-precision element in the SIMD&FP source vector, converts each value\nto BFloat16 format, and writes the results in the lower or upper half of the\nSIMD&FP destination vector. The result elements are half the width of the source\nelements.\n\nThe BFCVTN instruction writes the half-width results to the lower half of the\ndestination vector and clears the upper half to zero, while the BFCVTN2\ninstruction writes the results to the upper half of the destination vector\nwithout affecting the other bits in the register.\n\nUnlike the BFloat16 multiplication instructions, this instruction honors all of\nthe control bits in the FPCR that apply to single-precision arithmetic,\nincluding the rounding mode. It can also generate a floating-point exception\nthat causes cumulative exception bits in the FPSR to be set, or a synchronous\nexception to be taken, depending on the enable bits in the FPCR.",
        "heading": "BFCVTN, BFCVTN2",
        "templates": {
          "BFCVTN_ASIMDMISC_4S": [
            "BFCVTN{2}  <Vd>.<Ta>, <Vn>.4S"
          ]
        }
      },
      "BFCVT_float": {
        "authored": "Floating-point convert from single-precision to BFloat16 format (scalar)\nconverts the single-precision floating-point value in the 32-bit SIMD&FP source\nregister to BFloat16 format and writes the result in the 16-bit SIMD&FP\ndestination register.\n\nUnlike the BFloat16 multiplication instructions, this instruction honors all the\ncontrol bits in the FPCR that apply to single-precision arithmetic, including\nthe rounding mode. This instruction can generate a floating-point exception that\ncauses a cumulative exception bit in the FPSR to be set, or a synchronous\nexception to be taken, depending on the enable bits in the FPCR.\nID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.",
        "heading": "BFCVT",
        "templates": {
          "BFCVT_BS_FLOATDP1": [
            "BFCVT  <Hd>, <Sn>"
          ]
        }
      },
      "BFDOT_advsimd_elt": {
        "authored": "BFloat16 floating-point dot product (vector, by element). This instruction\ndelimits the source vectors into pairs of 16-bit BF16 elements. Each pair of\nelements in the first source vector is multiplied by the specified pair of\nelements in the second source vector. The resulting single-precision products\nare then summed and added destructively to the single-precision element of the\ndestination vector that aligns with the pair of BF16 values in the first source\nvector. The instruction ignores the FPCR and does not update the FPSR exception\nstatus.\n\nThe BF16 pair within the second source vector is specified using an immediate\nindex. The index range is from 0 to 3 inclusive. ID_AA64ISAR1_EL1.BF16 indicates\nwhether this instruction is supported.",
        "heading": "BFDOT (by element)",
        "templates": {
          "BFDOT_ASIMDELEM_E": [
            "BFDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.2H[<index>]"
          ]
        }
      },
      "BFDOT_advsimd_vec": {
        "authored": "BFloat16 floating-point dot product (vector). This instruction delimits the\nsource vectors into pairs of 16-bit BF16 elements. Within each pair, the\nelements in the first source vector are multiplied by the corresponding elements\nin the second source vector. The resulting single-precision products are then\nsummed and added destructively to the single-precision element of the\ndestination vector that aligns with the pair of BF16 values in the first source\nvector. The instruction ignores the FPCR and does not update the FPSR exception\nstatus.",
        "heading": "BFDOT (vector)",
        "templates": {
          "BFDOT_ASIMDSAME2_D": [
            "BFDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "BFMLAL_advsimd_elt": {
        "authored": "BFloat16 floating-point widening multiply-add long (by element) widens the even-\nnumbered (bottom) or odd-numbered (top) 16-bit elements in the first source\nvector, and the indexed element in the second source vector from Bfloat16 to\nsingle-precision format. The instruction then multiplies and adds these values\nto the overlapping single-precision elements of the destination vector.\n\nThis performs a fused multiply-add without intermediate rounding that honors all\nof the control bits in the FPCR that apply to single-precision arithmetic,\nincluding the rounding mode. It can also generate a floating-point exception\nthat causes cumulative exception bits in the FPSR to be set, or a synchronous\nexception to be taken, depending on the enable bits in the FPCR.\nID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.",
        "heading": "BFMLALB, BFMLALT (by element)",
        "templates": {
          "BFMLAL_ASIMDELEM_F": [
            "BFMLAL<bt>  <Vd>.4S, <Vn>.8H, <Vm>.H[<index>]"
          ]
        }
      },
      "BFMLAL_advsimd_vec": {
        "authored": "BFloat16 floating-point widening multiply-add long (vector) widens the even-\nnumbered (bottom) or odd-numbered (top) 16-bit elements in the first and second\nsource vectors from Bfloat16 to single-precision format. The instruction then\nmultiplies and adds these values to the overlapping single-precision elements of\nthe destination vector.\n\nThis performs a fused multiply-add without intermediate rounding that honors all\nof the control bits in the FPCR that apply to single-precision arithmetic,\nincluding the rounding mode. It can also generate a floating-point exception\nthat causes cumulative exception bits in the FPSR to be set, or a synchronous\nexception to be taken, depending on the enable bits in the FPCR.\nID_AA64ISAR1_EL1.BF16 indicates whether these instruction is supported.",
        "heading": "BFMLALB, BFMLALT (vector)",
        "templates": {
          "BFMLAL_ASIMDSAME2_F_": [
            "BFMLAL<bt>  <Vd>.4S, <Vn>.8H, <Vm>.8H"
          ]
        }
      },
      "BFMMLA_advsimd": {
        "authored": "BFloat16 floating-point matrix multiply-accumulate into 2x2 matrix. This\ninstruction multiplies the 2x4 matrix of BF16 values held in the first 128-bit\nsource vector by the 4x2 BF16 matrix in the second 128-bit source vector. The\nresulting 2x2 single-precision matrix product is then added destructively to the\n2x2 single-precision matrix in the 128-bit destination vector. This is\nequivalent to performing a 4-way dot product per destination element. The\ninstruction ignores the FPCR and does not update the FPSR exception status.\n\nArm expects that the BFMMLA instruction will deliver a peak BF16 multiply\nthroughput that is at least as high as can be achieved using two BFDOT\ninstructions, with a goal that it should have significantly higher throughput.",
        "heading": "BFMMLA",
        "templates": {
          "BFMMLA_ASIMDSAME2_E": [
            "BFMMLA  <Vd>.4S, <Vn>.8H, <Vm>.8H"
          ]
        }
      },
      "BIC_advsimd_imm": {
        "authored": "Bitwise bit Clear (vector, immediate). This instruction reads each vector\nelement from the destination SIMD&FP register, performs a bitwise AND between\neach result and the complement of an immediate constant, places the result into\na vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "BIC (vector, immediate)",
        "templates": {
          "SHIFTED_IMMEDIATE": [
            "BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}",
            "BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}"
          ]
        }
      },
      "BIC_advsimd_reg": {
        "authored": "Bitwise bit Clear (vector, register). This instruction performs a bitwise AND\nbetween the first source SIMD&FP register and the complement of the second\nsource SIMD&FP register, and writes the result to the destination SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "BIC (vector, register)",
        "templates": {
          "BIC_ASIMDSAME_ONLY": [
            "BIC  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "BIF_advsimd": {
        "authored": "Bitwise Insert if False. This instruction inserts each bit from the first source\nSIMD&FP register into the destination SIMD&FP register if the corresponding bit\nof the second source SIMD&FP register is 0, otherwise leaves the bit in the\ndestination register unchanged.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "BIF",
        "templates": {
          "BIF_ASIMDSAME_ONLY": [
            "BIF  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "BIT_advsimd": {
        "authored": "Bitwise Insert if True. This instruction inserts each bit from the first source\nSIMD&FP register into the SIMD&FP destination register if the corresponding bit\nof the second source SIMD&FP register is 1, otherwise leaves the bit in the\ndestination register unchanged.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "BIT",
        "templates": {
          "BIT_ASIMDSAME_ONLY": [
            "BIT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "BSL_advsimd": {
        "authored": "Bitwise Select. This instruction sets each bit in the destination SIMD&FP\nregister to the corresponding bit from the first source SIMD&FP register when\nthe original destination bit was 1, otherwise from the second source SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "BSL",
        "templates": {
          "BSL_ASIMDSAME_ONLY": [
            "BSL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "CLS_advsimd": {
        "authored": "Count Leading Sign bits (vector). This instruction counts the number of\nconsecutive bits following the most significant bit that are the same as the\nmost significant bit in each vector element in the source SIMD&FP register,\nplaces the result into a vector, and writes the vector to the destination\nSIMD&FP register. The count does not include the most significant bit itself.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CLS (vector)",
        "templates": {
          "CLS_ASIMDMISC_R": [
            "CLS  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "CLZ_advsimd": {
        "authored": "Count Leading Zero bits (vector). This instruction counts the number of\nconsecutive zeros, starting from the most significant bit, in each vector\nelement in the source SIMD&FP register, places the result into a vector, and\nwrites the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CLZ (vector)",
        "templates": {
          "CLZ_ASIMDMISC_R": [
            "CLZ  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "CMEQ_advsimd_reg": {
        "authored": "Compare bitwise Equal (vector). This instruction compares each vector element\nfrom the first source SIMD&FP register with the corresponding vector element\nfrom the second source SIMD&FP register, and if the comparison is equal sets\nevery bit of the corresponding vector element in the destination SIMD&FP\nregister to one, otherwise sets every bit of the corresponding vector element in\nthe destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMEQ (register)",
        "templates": {
          "CMEQ_ASIMDSAME_ONLY": [
            "CMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "CMEQ_ASISDSAME_ONLY": [
            "CMEQ  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "CMEQ_advsimd_zero": {
        "authored": "Compare bitwise Equal to zero (vector). This instruction reads each vector\nelement in the source SIMD&FP register and if the value is equal to zero sets\nevery bit of the corresponding vector element in the destination SIMD&FP\nregister to one, otherwise sets every bit of the corresponding vector element in\nthe destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMEQ (zero)",
        "templates": {
          "CMEQ_ASIMDMISC_Z": [
            "CMEQ  <Vd>.<T>, <Vn>.<T>, #0"
          ],
          "CMEQ_ASISDMISC_Z": [
            "CMEQ  <V><d>, <V><n>, #0"
          ]
        }
      },
      "CMGE_advsimd_reg": {
        "authored": "Compare signed Greater than or Equal (vector). This instruction compares each\nvector element in the first source SIMD&FP register with the corresponding\nvector element in the second source SIMD&FP register and if the first signed\ninteger value is greater than or equal to the second signed integer value sets\nevery bit of the corresponding vector element in the destination SIMD&FP\nregister to one, otherwise sets every bit of the corresponding vector element in\nthe destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMGE (register)",
        "templates": {
          "CMGE_ASIMDSAME_ONLY": [
            "CMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "CMGE_ASISDSAME_ONLY": [
            "CMGE  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "CMGE_advsimd_zero": {
        "authored": "Compare signed Greater than or Equal to zero (vector). This instruction reads\neach vector element in the source SIMD&FP register and if the signed integer\nvalue is greater than or equal to zero sets every bit of the corresponding\nvector element in the destination SIMD&FP register to one, otherwise sets every\nbit of the corresponding vector element in the destination SIMD&FP register to\nzero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMGE (zero)",
        "templates": {
          "CMGE_ASIMDMISC_Z": [
            "CMGE  <Vd>.<T>, <Vn>.<T>, #0"
          ],
          "CMGE_ASISDMISC_Z": [
            "CMGE  <V><d>, <V><n>, #0"
          ]
        }
      },
      "CMGT_advsimd_reg": {
        "authored": "Compare signed Greater than (vector). This instruction compares each vector\nelement in the first source SIMD&FP register with the corresponding vector\nelement in the second source SIMD&FP register and if the first signed integer\nvalue is greater than the second signed integer value sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to one,\notherwise sets every bit of the corresponding vector element in the destination\nSIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMGT (register)",
        "templates": {
          "CMGT_ASIMDSAME_ONLY": [
            "CMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "CMGT_ASISDSAME_ONLY": [
            "CMGT  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "CMGT_advsimd_zero": {
        "authored": "Compare signed Greater than zero (vector). This instruction reads each vector\nelement in the source SIMD&FP register and if the signed integer value is\ngreater than zero sets every bit of the corresponding vector element in the\ndestination SIMD&FP register to one, otherwise sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMGT (zero)",
        "templates": {
          "CMGT_ASIMDMISC_Z": [
            "CMGT  <Vd>.<T>, <Vn>.<T>, #0"
          ],
          "CMGT_ASISDMISC_Z": [
            "CMGT  <V><d>, <V><n>, #0"
          ]
        }
      },
      "CMHI_advsimd": {
        "authored": "Compare unsigned Higher (vector). This instruction compares each vector element\nin the first source SIMD&FP register with the corresponding vector element in\nthe second source SIMD&FP register and if the first unsigned integer value is\ngreater than the second unsigned integer value sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to one,\notherwise sets every bit of the corresponding vector element in the destination\nSIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMHI (register)",
        "templates": {
          "CMHI_ASIMDSAME_ONLY": [
            "CMHI  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "CMHI_ASISDSAME_ONLY": [
            "CMHI  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "CMHS_advsimd": {
        "authored": "Compare unsigned Higher or Same (vector). This instruction compares each vector\nelement in the first source SIMD&FP register with the corresponding vector\nelement in the second source SIMD&FP register and if the first unsigned integer\nvalue is greater than or equal to the second unsigned integer value sets every\nbit of the corresponding vector element in the destination SIMD&FP register to\none, otherwise sets every bit of the corresponding vector element in the\ndestination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMHS (register)",
        "templates": {
          "CMHS_ASIMDSAME_ONLY": [
            "CMHS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "CMHS_ASISDSAME_ONLY": [
            "CMHS  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "CMLE_advsimd": {
        "authored": "Compare signed Less than or Equal to zero (vector). This instruction reads each\nvector element in the source SIMD&FP register and if the signed integer value is\nless than or equal to zero sets every bit of the corresponding vector element in\nthe destination SIMD&FP register to one, otherwise sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMLE (zero)",
        "templates": {
          "CMLE_ASIMDMISC_Z": [
            "CMLE  <Vd>.<T>, <Vn>.<T>, #0"
          ],
          "CMLE_ASISDMISC_Z": [
            "CMLE  <V><d>, <V><n>, #0"
          ]
        }
      },
      "CMLT_advsimd": {
        "authored": "Compare signed Less than zero (vector). This instruction reads each vector\nelement in the source SIMD&FP register and if the signed integer value is less\nthan zero sets every bit of the corresponding vector element in the destination\nSIMD&FP register to one, otherwise sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMLT (zero)",
        "templates": {
          "CMLT_ASIMDMISC_Z": [
            "CMLT  <Vd>.<T>, <Vn>.<T>, #0"
          ],
          "CMLT_ASISDMISC_Z": [
            "CMLT  <V><d>, <V><n>, #0"
          ]
        }
      },
      "CMTST_advsimd": {
        "authored": "Compare bitwise Test bits nonzero (vector). This instruction reads each vector\nelement in the first source SIMD&FP register, performs an AND with the\ncorresponding vector element in the second source SIMD&FP register, and if the\nresult is not zero, sets every bit of the corresponding vector element in the\ndestination SIMD&FP register to one, otherwise sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CMTST",
        "templates": {
          "CMTST_ASIMDSAME_ONLY": [
            "CMTST  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "CMTST_ASISDSAME_ONLY": [
            "CMTST  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "CNT_advsimd": {
        "authored": "Population Count per byte. This instruction counts the number of bits that have\na value of one in each vector element in the source SIMD&FP register, places the\nresult into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "CNT",
        "templates": {
          "CNT_ASIMDMISC_R": [
            "CNT  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "DUP_advsimd_elt": {
        "authored": "Duplicate vector element to vector or scalar. This instruction duplicates the\nvector element at the specified element index in the source SIMD&FP register\ninto a scalar or each element in a vector, and writes the result to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "DUP (element)",
        "templates": {
          "DUP_ASIMDINS_DV_V": [
            "DUP  <Vd>.<T>, <Vn>.<Ts>[<index>]"
          ],
          "DUP_ASISDONE_ONLY": [
            "DUP  <V><d>, <Vn>.<T>[<index>]"
          ]
        }
      },
      "DUP_advsimd_gen": {
        "authored": "Duplicate general-purpose register to vector. This instruction duplicates the\ncontents of the source general-purpose register into a scalar or each element in\na vector, and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "DUP (general)",
        "templates": {
          "DUP_ASIMDINS_DR_R": [
            "DUP  <Vd>.<T>, <R><n>"
          ]
        }
      },
      "EOR3_advsimd": {
        "authored": "Three-way Exclusive OR performs a three-way exclusive OR of the values in the\nthree source SIMD&FP registers, and writes the result to the destination SIMD&FP\nregister.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.",
        "heading": "EOR3",
        "templates": {
          "EOR3_VVV16_CRYPTO4": [
            "EOR3  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B"
          ]
        }
      },
      "EOR_advsimd": {
        "authored": "Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR\noperation between the two source SIMD&FP registers, and places the result in the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "EOR (vector)",
        "templates": {
          "EOR_ASIMDSAME_ONLY": [
            "EOR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "EXT_advsimd": {
        "authored": "Extract vector from pair of vectors. This instruction extracts the lowest vector\nelements from the second source SIMD&FP register and the highest vector elements\nfrom the first source SIMD&FP register, concatenates the results into a vector,\nand writes the vector to the destination SIMD&FP register vector. The index\nvalue specifies the lowest vector element to extract from the first source\nregister, and consecutive elements are extracted from the first, then second,\nsource registers until the destination vector is filled.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "EXT",
        "templates": {
          "EXT_ASIMDEXT_ONLY": [
            "EXT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<index>"
          ]
        }
      },
      "FABD_advsimd": {
        "authored": "Floating-point Absolute Difference (vector). This instruction subtracts the\nfloating-point values in the elements of the second source SIMD&FP register,\nfrom the corresponding floating-point values in the elements of the first source\nSIMD&FP register, places the absolute value of each result in a vector, and\nwrites the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FABD",
        "templates": {
          "FABD_ASIMDSAMEFP16_ONLY": [
            "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FABD_ASIMDSAME_ONLY": [
            "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FABD_ASISDSAMEFP16_ONLY": [
            "FABD  <Hd>, <Hn>, <Hm>"
          ],
          "FABD_ASISDSAME_ONLY": [
            "FABD  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FABS_advsimd": {
        "authored": "Floating-point Absolute value (vector). This instruction calculates the absolute\nvalue of each vector element in the source SIMD&FP register, writes the result\nto a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FABS (vector)",
        "templates": {
          "FABS_ASIMDMISCFP16_R": [
            "FABS  <Vd>.<T>, <Vn>.<T>"
          ],
          "FABS_ASIMDMISC_R": [
            "FABS  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FABS_float": {
        "authored": "Floating-point Absolute value (scalar). This instruction calculates the absolute\nvalue in the SIMD&FP source register and writes the result to the SIMD&FP\ndestination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FABS (scalar)",
        "templates": {
          "FLOAT": [
            "FABS  <Hd>, <Hn>",
            "FABS  <Sd>, <Sn>",
            "FABS  <Dd>, <Dn>"
          ]
        }
      },
      "FACGE_advsimd": {
        "authored": "Floating-point Absolute Compare Greater than or Equal (vector). This instruction\ncompares the absolute value of each floating-point value in the first source\nSIMD&FP register with the absolute value of the corresponding floating-point\nvalue in the second source SIMD&FP register and if the first value is greater\nthan or equal to the second value sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to one, otherwise sets every bit of\nthe corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FACGE",
        "templates": {
          "FACGE_ASIMDSAMEFP16_ONLY": [
            "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FACGE_ASIMDSAME_ONLY": [
            "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FACGE_ASISDSAMEFP16_ONLY": [
            "FACGE  <Hd>, <Hn>, <Hm>"
          ],
          "FACGE_ASISDSAME_ONLY": [
            "FACGE  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FACGT_advsimd": {
        "authored": "Floating-point Absolute Compare Greater than (vector). This instruction compares\nthe absolute value of each vector element in the first source SIMD&FP register\nwith the absolute value of the corresponding vector element in the second source\nSIMD&FP register and if the first value is greater than the second value sets\nevery bit of the corresponding vector element in the destination SIMD&FP\nregister to one, otherwise sets every bit of the corresponding vector element in\nthe destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FACGT",
        "templates": {
          "FACGT_ASIMDSAMEFP16_ONLY": [
            "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FACGT_ASIMDSAME_ONLY": [
            "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FACGT_ASISDSAMEFP16_ONLY": [
            "FACGT  <Hd>, <Hn>, <Hm>"
          ],
          "FACGT_ASISDSAME_ONLY": [
            "FACGT  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FADDP_advsimd_pair": {
        "authored": "Floating-point Add Pair of elements (scalar). This instruction adds two\nfloating-point vector elements in the source SIMD&FP register and writes the\nscalar result into the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FADDP (scalar)",
        "templates": {
          "FADDP_ASISDPAIR_ONLY_H": [
            "FADDP  <V><d>, <Vn>.<T>"
          ],
          "FADDP_ASISDPAIR_ONLY_SD": [
            "FADDP  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FADDP_advsimd_vec": {
        "authored": "Floating-point Add Pairwise (vector). This instruction creates a vector by\nconcatenating the vector elements of the first source SIMD&FP register after the\nvector elements of the second source SIMD&FP register, reads each pair of\nadjacent vector elements from the concatenated vector, adds each pair of values\ntogether, places the result into a vector, and writes the vector to the\ndestination SIMD&FP register. All the values in this instruction are floating-\npoint values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FADDP (vector)",
        "templates": {
          "FADDP_ASIMDSAMEFP16_ONLY": [
            "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FADDP_ASIMDSAME_ONLY": [
            "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FADD_advsimd": {
        "authored": "Floating-point Add (vector). This instruction adds corresponding vector elements\nin the two source SIMD&FP registers, writes the result into a vector, and writes\nthe vector to the destination SIMD&FP register. All the values in this\ninstruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FADD (vector)",
        "templates": {
          "FADD_ASIMDSAMEFP16_ONLY": [
            "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FADD_ASIMDSAME_ONLY": [
            "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FADD_float": {
        "authored": "Floating-point Add (scalar). This instruction adds the floating-point values of\nthe two source SIMD&FP registers, and writes the result to the destination\nSIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FADD (scalar)",
        "templates": {
          "FLOAT": [
            "FADD  <Hd>, <Hn>, <Hm>",
            "FADD  <Sd>, <Sn>, <Sm>",
            "FADD  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FCADD_advsimd_vec": {
        "authored": "Floating-point Complex Add.\n\nThis instruction operates on complex numbers that are represented in SIMD&FP\nregisters as pairs of elements, with the more significant element holding the\nimaginary part of the number and the less significant element holding the real\npart of the number. Each element holds a floating-point value. It performs the\nfollowing computation on the corresponding complex number element pairs from the\ntwo source registers:\n  - Considering the complex number from the second source register on an Argand\ndiagram, the number is rotated counterclockwise by 90 or 270 degrees.\n  - The rotated complex number is added to the complex number from the first\nsource register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCADD",
        "templates": {
          "FCADD_ASIMDSAME2_C": [
            "FCADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>"
          ]
        }
      },
      "FCCMPE_float": {
        "authored": "Floating-point Conditional signaling Compare (scalar). This instruction compares\nthe two SIMD&FP source register values and writes the result to the PSTATE.{N,\nZ, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V}\nflags are set to the flag bit specifier.\n\nIf either operand is any type of NaN, or if either operand is a signaling NaN,\nthe instruction raises an Invalid Operation exception.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCCMPE",
        "templates": {
          "FLOAT": [
            "FCCMPE  <Hn>, <Hm>, #<nzcv>, <cond>",
            "FCCMPE  <Sn>, <Sm>, #<nzcv>, <cond>",
            "FCCMPE  <Dn>, <Dm>, #<nzcv>, <cond>"
          ]
        }
      },
      "FCCMP_float": {
        "authored": "Floating-point Conditional quiet Compare (scalar). This instruction compares the\ntwo SIMD&FP source register values and writes the result to the PSTATE.{N, Z, C,\nV} flags. If the condition does not pass then the PSTATE.{N, Z, C, V} flags are\nset to the flag bit specifier.\n\nIt raises an Invalid Operation exception only if either operand is a signaling\nNaN.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCCMP",
        "templates": {
          "FLOAT": [
            "FCCMP  <Hn>, <Hm>, #<nzcv>, <cond>",
            "FCCMP  <Sn>, <Sm>, #<nzcv>, <cond>",
            "FCCMP  <Dn>, <Dm>, #<nzcv>, <cond>"
          ]
        }
      },
      "FCMEQ_advsimd_reg": {
        "authored": "Floating-point Compare Equal (vector). This instruction compares each floating-\npoint value from the first source SIMD&FP register, with the corresponding\nfloating-point value from the second source SIMD&FP register, and if the\ncomparison is equal sets every bit of the corresponding vector element in the\ndestination SIMD&FP register to one, otherwise sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMEQ (register)",
        "templates": {
          "FCMEQ_ASIMDSAMEFP16_ONLY": [
            "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FCMEQ_ASIMDSAME_ONLY": [
            "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FCMEQ_ASISDSAMEFP16_ONLY": [
            "FCMEQ  <Hd>, <Hn>, <Hm>"
          ],
          "FCMEQ_ASISDSAME_ONLY": [
            "FCMEQ  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FCMEQ_advsimd_zero": {
        "authored": "Floating-point Compare Equal to zero (vector). This instruction reads each\nfloating-point value in the source SIMD&FP register and if the value is equal to\nzero sets every bit of the corresponding vector element in the destination\nSIMD&FP register to one, otherwise sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMEQ (zero)",
        "templates": {
          "FCMEQ_ASIMDMISCFP16_FZ": [
            "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "FCMEQ_ASIMDMISC_FZ": [
            "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "FCMEQ_ASISDMISCFP16_FZ": [
            "FCMEQ  <Hd>, <Hn>, #0.0"
          ],
          "FCMEQ_ASISDMISC_FZ": [
            "FCMEQ  <V><d>, <V><n>, #0.0"
          ]
        }
      },
      "FCMGE_advsimd_reg": {
        "authored": "Floating-point Compare Greater than or Equal (vector). This instruction reads\neach floating-point value in the first source SIMD&FP register and if the value\nis greater than or equal to the corresponding floating-point value in the second\nsource SIMD&FP register sets every bit of the corresponding vector element in\nthe destination SIMD&FP register to one, otherwise sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMGE (register)",
        "templates": {
          "FCMGE_ASIMDSAMEFP16_ONLY": [
            "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FCMGE_ASIMDSAME_ONLY": [
            "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FCMGE_ASISDSAMEFP16_ONLY": [
            "FCMGE  <Hd>, <Hn>, <Hm>"
          ],
          "FCMGE_ASISDSAME_ONLY": [
            "FCMGE  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FCMGE_advsimd_zero": {
        "authored": "Floating-point Compare Greater than or Equal to zero (vector). This instruction\nreads each floating-point value in the source SIMD&FP register and if the value\nis greater than or equal to zero sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to one, otherwise sets every bit of\nthe corresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMGE (zero)",
        "templates": {
          "FCMGE_ASIMDMISCFP16_FZ": [
            "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "FCMGE_ASIMDMISC_FZ": [
            "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "FCMGE_ASISDMISCFP16_FZ": [
            "FCMGE  <Hd>, <Hn>, #0.0"
          ],
          "FCMGE_ASISDMISC_FZ": [
            "FCMGE  <V><d>, <V><n>, #0.0"
          ]
        }
      },
      "FCMGT_advsimd_reg": {
        "authored": "Floating-point Compare Greater than (vector). This instruction reads each\nfloating-point value in the first source SIMD&FP register and if the value is\ngreater than the corresponding floating-point value in the second source SIMD&FP\nregister sets every bit of the corresponding vector element in the destination\nSIMD&FP register to one, otherwise sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMGT (register)",
        "templates": {
          "FCMGT_ASIMDSAMEFP16_ONLY": [
            "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FCMGT_ASIMDSAME_ONLY": [
            "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FCMGT_ASISDSAMEFP16_ONLY": [
            "FCMGT  <Hd>, <Hn>, <Hm>"
          ],
          "FCMGT_ASISDSAME_ONLY": [
            "FCMGT  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FCMGT_advsimd_zero": {
        "authored": "Floating-point Compare Greater than zero (vector). This instruction reads each\nfloating-point value in the source SIMD&FP register and if the value is greater\nthan zero sets every bit of the corresponding vector element in the destination\nSIMD&FP register to one, otherwise sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMGT (zero)",
        "templates": {
          "FCMGT_ASIMDMISCFP16_FZ": [
            "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "FCMGT_ASIMDMISC_FZ": [
            "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "FCMGT_ASISDMISCFP16_FZ": [
            "FCMGT  <Hd>, <Hn>, #0.0"
          ],
          "FCMGT_ASISDMISC_FZ": [
            "FCMGT  <V><d>, <V><n>, #0.0"
          ]
        }
      },
      "FCMLA_advsimd_elt": {
        "authored": "Floating-point Complex Multiply Accumulate (by element).\n\nThis instruction operates on complex numbers that are represented in SIMD&FP\nregisters as pairs of elements, with the more significant element holding the\nimaginary part of the number and the less significant element holding the real\npart of the number. Each element holds a floating-point value. It performs the\nfollowing computation on complex numbers from the first source register and the\ndestination register with the specified complex number from the second source\nregister:\n  - Considering the complex number from the second source register on an Argand\ndiagram, the number is rotated counterclockwise by 0, 90, 180, or 270 degrees.\n  - The two elements of the transformed complex number are multiplied by:\n    - The real element of the complex number from the first source register, if\nthe transformation was a rotation by 0 or 180 degrees.\n    - The imaginary element of the complex number from the first source\nregister, if the transformation was a rotation by 90 or 270 degrees.\n  - The complex number resulting from that multiplication is added to the\ncomplex number from the destination register.\n\nThe multiplication and addition operations are performed as a fused multiply-\nadd, without any intermediate rounding.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMLA (by element)",
        "templates": {
          "2REG_ELEMENT": [
            "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>",
            "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>"
          ]
        }
      },
      "FCMLA_advsimd_vec": {
        "authored": "Floating-point Complex Multiply Accumulate.\n\nThis instruction operates on complex numbers that are represented in SIMD&FP\nregisters as pairs of elements, with the more significant element holding the\nimaginary part of the number and the less significant element holding the real\npart of the number. Each element holds a floating-point value. It performs the\nfollowing computation on the corresponding complex number element pairs from the\ntwo source registers and the destination register:\n  - Considering the complex number from the second source register on an Argand\ndiagram, the number is rotated counterclockwise by 0, 90, 180, or 270 degrees.\n  - The two elements of the transformed complex number are multiplied by:\n    - The real element of the complex number from the first source register, if\nthe transformation was a rotation by 0 or 180 degrees.\n    - The imaginary element of the complex number from the first source\nregister, if the transformation was a rotation by 90 or 270 degrees.\n  - The complex number resulting from that multiplication is added to the\ncomplex number from the destination register.\n\nThe multiplication and addition operations are performed as a fused multiply-\nadd, without any intermediate rounding.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMLA",
        "templates": {
          "FCMLA_ASIMDSAME2_C": [
            "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>"
          ]
        }
      },
      "FCMLE_advsimd": {
        "authored": "Floating-point Compare Less than or Equal to zero (vector). This instruction\nreads each floating-point value in the source SIMD&FP register and if the value\nis less than or equal to zero sets every bit of the corresponding vector element\nin the destination SIMD&FP register to one, otherwise sets every bit of the\ncorresponding vector element in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMLE (zero)",
        "templates": {
          "FCMLE_ASIMDMISCFP16_FZ": [
            "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "FCMLE_ASIMDMISC_FZ": [
            "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "FCMLE_ASISDMISCFP16_FZ": [
            "FCMLE  <Hd>, <Hn>, #0.0"
          ],
          "FCMLE_ASISDMISC_FZ": [
            "FCMLE  <V><d>, <V><n>, #0.0"
          ]
        }
      },
      "FCMLT_advsimd": {
        "authored": "Floating-point Compare Less than zero (vector). This instruction reads each\nfloating-point value in the source SIMD&FP register and if the value is less\nthan zero sets every bit of the corresponding vector element in the destination\nSIMD&FP register to one, otherwise sets every bit of the corresponding vector\nelement in the destination SIMD&FP register to zero.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMLT (zero)",
        "templates": {
          "FCMLT_ASIMDMISCFP16_FZ": [
            "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "FCMLT_ASIMDMISC_FZ": [
            "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0"
          ],
          "FCMLT_ASISDMISCFP16_FZ": [
            "FCMLT  <Hd>, <Hn>, #0.0"
          ],
          "FCMLT_ASISDMISC_FZ": [
            "FCMLT  <V><d>, <V><n>, #0.0"
          ]
        }
      },
      "FCMPE_float": {
        "authored": "Floating-point signaling Compare (scalar). This instruction compares the two\nSIMD&FP source register values, or the first SIMD&FP source register value and\nzero. It writes the result to the PSTATE.{N, Z, C, V} flags.\n\nIf either operand is any type of NaN, or if either operand is a signaling NaN,\nthe instruction raises an Invalid Operation exception.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMPE",
        "templates": {
          "FLOAT": [
            "FCMPE  <Hn>, <Hm>",
            "FCMPE  <Hn>, #0.0",
            "FCMPE  <Sn>, <Sm>",
            "FCMPE  <Sn>, #0.0",
            "FCMPE  <Dn>, <Dm>",
            "FCMPE  <Dn>, #0.0"
          ]
        }
      },
      "FCMP_float": {
        "authored": "Floating-point quiet Compare (scalar). This instruction compares the two SIMD&FP\nsource register values, or the first SIMD&FP source register value and zero. It\nwrites the result to the PSTATE.{N, Z, C, V} flags.\n\nIt raises an Invalid Operation exception only if either operand is a signaling\nNaN.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCMP",
        "templates": {
          "FLOAT": [
            "FCMP  <Hn>, <Hm>",
            "FCMP  <Hn>, #0.0",
            "FCMP  <Sn>, <Sm>",
            "FCMP  <Sn>, #0.0",
            "FCMP  <Dn>, <Dm>",
            "FCMP  <Dn>, #0.0"
          ]
        }
      },
      "FCSEL_float": {
        "authored": "Floating-point Conditional Select (scalar). This instruction allows the SIMD&FP\ndestination register to take the value from either one or the other of two\nSIMD&FP source registers. If the condition passes, the first SIMD&FP source\nregister value is taken, otherwise the second SIMD&FP source register value is\ntaken.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCSEL",
        "templates": {
          "FLOAT": [
            "FCSEL  <Hd>, <Hn>, <Hm>, <cond>",
            "FCSEL  <Sd>, <Sn>, <Sm>, <cond>",
            "FCSEL  <Dd>, <Dn>, <Dm>, <cond>"
          ]
        }
      },
      "FCVTAS_advsimd": {
        "authored": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away\n(vector). This instruction converts each element in a vector from a floating-\npoint value to a signed integer value using the Round to Nearest with Ties to\nAway rounding mode and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTAS (vector)",
        "templates": {
          "FCVTAS_ASIMDMISCFP16_R": [
            "FCVTAS  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTAS_ASIMDMISC_R": [
            "FCVTAS  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTAS_ASISDMISCFP16_R": [
            "FCVTAS  <Hd>, <Hn>"
          ],
          "FCVTAS_ASISDMISC_R": [
            "FCVTAS  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTAS_float": {
        "authored": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away\n(scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit signed integer using the Round to Nearest\nwith Ties to Away rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTAS (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTAS  <Wd>, <Hn>",
            "FCVTAS  <Xd>, <Hn>",
            "FCVTAS  <Wd>, <Sn>",
            "FCVTAS  <Xd>, <Sn>",
            "FCVTAS  <Wd>, <Dn>",
            "FCVTAS  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTAU_advsimd": {
        "authored": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to\nAway (vector). This instruction converts each element in a vector from a\nfloating-point value to an unsigned integer value using the Round to Nearest\nwith Ties to Away rounding mode and writes the result to the SIMD&FP destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTAU (vector)",
        "templates": {
          "FCVTAU_ASIMDMISCFP16_R": [
            "FCVTAU  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTAU_ASIMDMISC_R": [
            "FCVTAU  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTAU_ASISDMISCFP16_R": [
            "FCVTAU  <Hd>, <Hn>"
          ],
          "FCVTAU_ASISDMISC_R": [
            "FCVTAU  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTAU_float": {
        "authored": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to\nAway (scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit unsigned integer using the Round to\nNearest with Ties to Away rounding mode, and writes the result to the general-\npurpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTAU (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTAU  <Wd>, <Hn>",
            "FCVTAU  <Xd>, <Hn>",
            "FCVTAU  <Wd>, <Sn>",
            "FCVTAU  <Xd>, <Sn>",
            "FCVTAU  <Wd>, <Dn>",
            "FCVTAU  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTL_advsimd": {
        "authored": "Floating-point Convert to higher precision Long (vector). This instruction reads\neach element in a vector in the SIMD&FP source register, converts each value to\ndouble the precision of the source element using the rounding mode that is\ndetermined by the FPCR, and writes each result to the equivalent element of the\nvector in the SIMD&FP destination register.\n\nWhere the operation lengthens a 64-bit vector to a 128-bit vector, the FCVTL2\nvariant operates on the elements in the top 64 bits of the source register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTL, FCVTL2",
        "templates": {
          "FCVTL_ASIMDMISC_L": [
            "FCVTL{2}  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "FCVTMS_advsimd": {
        "authored": "Floating-point Convert to Signed integer, rounding toward Minus infinity\n(vector). This instruction converts a scalar or each element in a vector from a\nfloating-point value to a signed integer value using the Round towards Minus\nInfinity rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTMS (vector)",
        "templates": {
          "FCVTMS_ASIMDMISCFP16_R": [
            "FCVTMS  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTMS_ASIMDMISC_R": [
            "FCVTMS  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTMS_ASISDMISCFP16_R": [
            "FCVTMS  <Hd>, <Hn>"
          ],
          "FCVTMS_ASISDMISC_R": [
            "FCVTMS  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTMS_float": {
        "authored": "Floating-point Convert to Signed integer, rounding toward Minus infinity\n(scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit signed integer using the Round towards\nMinus Infinity rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTMS (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTMS  <Wd>, <Hn>",
            "FCVTMS  <Xd>, <Hn>",
            "FCVTMS  <Wd>, <Sn>",
            "FCVTMS  <Xd>, <Sn>",
            "FCVTMS  <Wd>, <Dn>",
            "FCVTMS  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTMU_advsimd": {
        "authored": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity\n(vector). This instruction converts a scalar or each element in a vector from a\nfloating-point value to an unsigned integer value using the Round towards Minus\nInfinity rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTMU (vector)",
        "templates": {
          "FCVTMU_ASIMDMISCFP16_R": [
            "FCVTMU  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTMU_ASIMDMISC_R": [
            "FCVTMU  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTMU_ASISDMISCFP16_R": [
            "FCVTMU  <Hd>, <Hn>"
          ],
          "FCVTMU_ASISDMISC_R": [
            "FCVTMU  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTMU_float": {
        "authored": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity\n(scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit unsigned integer using the Round towards\nMinus Infinity rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTMU (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTMU  <Wd>, <Hn>",
            "FCVTMU  <Xd>, <Hn>",
            "FCVTMU  <Wd>, <Sn>",
            "FCVTMU  <Xd>, <Sn>",
            "FCVTMU  <Wd>, <Dn>",
            "FCVTMU  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTNS_advsimd": {
        "authored": "Floating-point Convert to Signed integer, rounding to nearest with ties to even\n(vector). This instruction converts a scalar or each element in a vector from a\nfloating-point value to a signed integer value using the Round to Nearest\nrounding mode, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTNS (vector)",
        "templates": {
          "FCVTNS_ASIMDMISCFP16_R": [
            "FCVTNS  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTNS_ASIMDMISC_R": [
            "FCVTNS  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTNS_ASISDMISCFP16_R": [
            "FCVTNS  <Hd>, <Hn>"
          ],
          "FCVTNS_ASISDMISC_R": [
            "FCVTNS  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTNS_float": {
        "authored": "Floating-point Convert to Signed integer, rounding to nearest with ties to even\n(scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit signed integer using the Round to Nearest\nrounding mode, and writes the result to the general-purpose destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTNS (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTNS  <Wd>, <Hn>",
            "FCVTNS  <Xd>, <Hn>",
            "FCVTNS  <Wd>, <Sn>",
            "FCVTNS  <Xd>, <Sn>",
            "FCVTNS  <Wd>, <Dn>",
            "FCVTNS  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTNU_advsimd": {
        "authored": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to\neven (vector). This instruction converts a scalar or each element in a vector\nfrom a floating-point value to an unsigned integer value using the Round to\nNearest rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTNU (vector)",
        "templates": {
          "FCVTNU_ASIMDMISCFP16_R": [
            "FCVTNU  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTNU_ASIMDMISC_R": [
            "FCVTNU  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTNU_ASISDMISCFP16_R": [
            "FCVTNU  <Hd>, <Hn>"
          ],
          "FCVTNU_ASISDMISC_R": [
            "FCVTNU  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTNU_float": {
        "authored": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to\neven (scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit unsigned integer using the Round to\nNearest rounding mode, and writes the result to the general-purpose destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTNU (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTNU  <Wd>, <Hn>",
            "FCVTNU  <Xd>, <Hn>",
            "FCVTNU  <Wd>, <Sn>",
            "FCVTNU  <Xd>, <Sn>",
            "FCVTNU  <Wd>, <Dn>",
            "FCVTNU  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTN_advsimd": {
        "authored": "Floating-point Convert to lower precision Narrow (vector). This instruction\nreads each vector element in the SIMD&FP source register, converts each result\nto half the precision of the source element, writes the final result to a\nvector, and writes the vector to the lower or upper half of the destination\nSIMD&FP register. The destination vector elements are half as long as the source\nvector elements. The rounding mode is determined by the FPCR.\n\nThe FCVTN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the FCVTN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTN, FCVTN2",
        "templates": {
          "FCVTN_ASIMDMISC_N": [
            "FCVTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
          ]
        }
      },
      "FCVTPS_advsimd": {
        "authored": "Floating-point Convert to Signed integer, rounding toward Plus infinity\n(vector). This instruction converts a scalar or each element in a vector from a\nfloating-point value to a signed integer value using the Round towards Plus\nInfinity rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTPS (vector)",
        "templates": {
          "FCVTPS_ASIMDMISCFP16_R": [
            "FCVTPS  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTPS_ASIMDMISC_R": [
            "FCVTPS  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTPS_ASISDMISCFP16_R": [
            "FCVTPS  <Hd>, <Hn>"
          ],
          "FCVTPS_ASISDMISC_R": [
            "FCVTPS  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTPS_float": {
        "authored": "Floating-point Convert to Signed integer, rounding toward Plus infinity\n(scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit signed integer using the Round towards\nPlus Infinity rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTPS (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTPS  <Wd>, <Hn>",
            "FCVTPS  <Xd>, <Hn>",
            "FCVTPS  <Wd>, <Sn>",
            "FCVTPS  <Xd>, <Sn>",
            "FCVTPS  <Wd>, <Dn>",
            "FCVTPS  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTPU_advsimd": {
        "authored": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity\n(vector). This instruction converts a scalar or each element in a vector from a\nfloating-point value to an unsigned integer value using the Round towards Plus\nInfinity rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTPU (vector)",
        "templates": {
          "FCVTPU_ASIMDMISCFP16_R": [
            "FCVTPU  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTPU_ASIMDMISC_R": [
            "FCVTPU  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTPU_ASISDMISCFP16_R": [
            "FCVTPU  <Hd>, <Hn>"
          ],
          "FCVTPU_ASISDMISC_R": [
            "FCVTPU  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTPU_float": {
        "authored": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity\n(scalar). This instruction converts the floating-point value in the SIMD&FP\nsource register to a 32-bit or 64-bit unsigned integer using the Round towards\nPlus Infinity rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTPU (scalar)",
        "templates": {
          "FLOAT": [
            "FCVTPU  <Wd>, <Hn>",
            "FCVTPU  <Xd>, <Hn>",
            "FCVTPU  <Wd>, <Sn>",
            "FCVTPU  <Xd>, <Sn>",
            "FCVTPU  <Wd>, <Dn>",
            "FCVTPU  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTXN_advsimd": {
        "authored": "Floating-point Convert to lower precision Narrow, rounding to odd (vector). This\ninstruction reads each vector element in the source SIMD&FP register, narrows\neach value to half the precision of the source element using the Round to Odd\nrounding mode, writes the result to a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThis instruction uses the Round to Odd rounding mode which is not defined by the\nIEEE 754-2008 standard. This rounding mode ensures that if the result of the\nconversion is inexact the least significant bit of the mantissa is forced to 1.\nThis rounding mode enables a floating-point value to be converted to a lower\nprecision format via an intermediate precision format while avoiding double\nrounding errors. For example, a 64-bit floating-point value can be converted to\na correctly rounded 16-bit floating-point value by first using this instruction\nto produce a 32-bit value and then using another instruction with the wanted\nrounding mode to convert the 32-bit value to the final 16-bit floating-point\nvalue.\n\nThe FCVTXN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the FCVTXN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTXN, FCVTXN2",
        "templates": {
          "FCVTXN_ASIMDMISC_N": [
            "FCVTXN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
          ],
          "FCVTXN_ASISDMISC_N": [
            "FCVTXN  <Vb><d>, <Va><n>"
          ]
        }
      },
      "FCVTZS_advsimd_fix": {
        "authored": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector).\nThis instruction converts a scalar or each element in a vector from floating-\npoint to fixed-point signed integer using the Round towards Zero rounding mode,\nand writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTZS (vector, fixed-point)",
        "templates": {
          "FCVTZS_ASIMDSHF_C": [
            "FCVTZS  <Vd>.<T>, <Vn>.<T>, #<fbits>"
          ],
          "FCVTZS_ASISDSHF_C": [
            "FCVTZS  <V><d>, <V><n>, #<fbits>"
          ]
        }
      },
      "FCVTZS_advsimd_int": {
        "authored": "Floating-point Convert to Signed integer, rounding toward Zero (vector). This\ninstruction converts a scalar or each element in a vector from a floating-point\nvalue to a signed integer value using the Round towards Zero rounding mode, and\nwrites the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTZS (vector, integer)",
        "templates": {
          "FCVTZS_ASIMDMISCFP16_R": [
            "FCVTZS  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTZS_ASIMDMISC_R": [
            "FCVTZS  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTZS_ASISDMISCFP16_R": [
            "FCVTZS  <Hd>, <Hn>"
          ],
          "FCVTZS_ASISDMISC_R": [
            "FCVTZS  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTZS_float_fix": {
        "authored": "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar).\nThis instruction converts the floating-point value in the SIMD&FP source\nregister to a 32-bit or 64-bit fixed-point signed integer using the Round\ntowards Zero rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTZS (scalar, fixed-point)",
        "templates": {
          "FLOAT": [
            "FCVTZS  <Wd>, <Hn>, #<fbits>",
            "FCVTZS  <Xd>, <Hn>, #<fbits>",
            "FCVTZS  <Wd>, <Sn>, #<fbits>",
            "FCVTZS  <Xd>, <Sn>, #<fbits>",
            "FCVTZS  <Wd>, <Dn>, #<fbits>",
            "FCVTZS  <Xd>, <Dn>, #<fbits>"
          ]
        }
      },
      "FCVTZS_float_int": {
        "authored": "Floating-point Convert to Signed integer, rounding toward Zero (scalar). This\ninstruction converts the floating-point value in the SIMD&FP source register to\na 32-bit or 64-bit signed integer using the Round towards Zero rounding mode,\nand writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTZS (scalar, integer)",
        "templates": {
          "FLOAT": [
            "FCVTZS  <Wd>, <Hn>",
            "FCVTZS  <Xd>, <Hn>",
            "FCVTZS  <Wd>, <Sn>",
            "FCVTZS  <Xd>, <Sn>",
            "FCVTZS  <Wd>, <Dn>",
            "FCVTZS  <Xd>, <Dn>"
          ]
        }
      },
      "FCVTZU_advsimd_fix": {
        "authored": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector).\nThis instruction converts a scalar or each element in a vector from floating-\npoint to fixed-point unsigned integer using the Round towards Zero rounding\nmode, and writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTZU (vector, fixed-point)",
        "templates": {
          "FCVTZU_ASIMDSHF_C": [
            "FCVTZU  <Vd>.<T>, <Vn>.<T>, #<fbits>"
          ],
          "FCVTZU_ASISDSHF_C": [
            "FCVTZU  <V><d>, <V><n>, #<fbits>"
          ]
        }
      },
      "FCVTZU_advsimd_int": {
        "authored": "Floating-point Convert to Unsigned integer, rounding toward Zero (vector). This\ninstruction converts a scalar or each element in a vector from a floating-point\nvalue to an unsigned integer value using the Round towards Zero rounding mode,\nand writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTZU (vector, integer)",
        "templates": {
          "FCVTZU_ASIMDMISCFP16_R": [
            "FCVTZU  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTZU_ASIMDMISC_R": [
            "FCVTZU  <Vd>.<T>, <Vn>.<T>"
          ],
          "FCVTZU_ASISDMISCFP16_R": [
            "FCVTZU  <Hd>, <Hn>"
          ],
          "FCVTZU_ASISDMISC_R": [
            "FCVTZU  <V><d>, <V><n>"
          ]
        }
      },
      "FCVTZU_float_fix": {
        "authored": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar).\nThis instruction converts the floating-point value in the SIMD&FP source\nregister to a 32-bit or 64-bit fixed-point unsigned integer using the Round\ntowards Zero rounding mode, and writes the result to the general-purpose\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "FCVTZU (scalar, fixed-point)",
        "templates": {
          "FLOAT": [
            "FCVTZU  <Wd>, <Hn>, #<fbits>",
            "FCVTZU  <Xd>, <Hn>, #<fbits>",
            "FCVTZU  <Wd>, <Sn>, #<fbits>",
            "FCVTZU  <Xd>, <Sn>, #<fbits>",
            "FCVTZU  <Wd>, <Dn>, #<fbits>",
            "FCVTZU  <Xd>, <Dn>, #<fbits>"
          ]
        }
      },
      "FCVTZU_float_int": {
        "authored": "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar). This\ninstruction converts the floating-point value in the SIMD&FP source register to\na 32-bit or 64-bit unsigned integer using the Round towards Zero rounding mode,\nand writes the result to the general-purpose destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVTZU (scalar, integer)",
        "templates": {
          "FLOAT": [
            "FCVTZU  <Wd>, <Hn>",
            "FCVTZU  <Xd>, <Hn>",
            "FCVTZU  <Wd>, <Sn>",
            "FCVTZU  <Xd>, <Sn>",
            "FCVTZU  <Wd>, <Dn>",
            "FCVTZU  <Xd>, <Dn>"
          ]
        }
      },
      "FCVT_float": {
        "authored": "Floating-point Convert precision (scalar). This instruction converts the\nfloating-point value in the SIMD&FP source register to the precision for the\ndestination register data type using the rounding mode that is determined by the\nFPCR and writes the result to the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FCVT",
        "templates": {
          "FLOAT": [
            "FCVT  <Sd>, <Hn>",
            "FCVT  <Dd>, <Hn>",
            "FCVT  <Hd>, <Sn>",
            "FCVT  <Dd>, <Sn>",
            "FCVT  <Hd>, <Dn>",
            "FCVT  <Sd>, <Dn>"
          ]
        }
      },
      "FDIV_advsimd": {
        "authored": "Floating-point Divide (vector). This instruction divides the floating-point\nvalues in the elements in the first source SIMD&FP register, by the floating-\npoint values in the corresponding elements in the second source SIMD&FP\nregister, places the results in a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FDIV (vector)",
        "templates": {
          "FDIV_ASIMDSAMEFP16_ONLY": [
            "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FDIV_ASIMDSAME_ONLY": [
            "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FDIV_float": {
        "authored": "Floating-point Divide (scalar). This instruction divides the floating-point\nvalue of the first source SIMD&FP register by the floating-point value of the\nsecond source SIMD&FP register, and writes the result to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FDIV (scalar)",
        "templates": {
          "FLOAT": [
            "FDIV  <Hd>, <Hn>, <Hm>",
            "FDIV  <Sd>, <Sn>, <Sm>",
            "FDIV  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FJCVTZS": {
        "authored": "Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero.\nThis instruction converts the double-precision floating-point value in the\nSIMD&FP source register to a 32-bit signed integer using the Round towards Zero\nrounding mode, and writes the result to the general-purpose destination\nregister. If the result is too large to be accommodated as a signed 32-bit\ninteger, then the result is the integer modulo 2^32, as held in a 32-bit signed\ninteger.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FJCVTZS",
        "templates": {
          "FJCVTZS_32D_FLOAT2INT": [
            "FJCVTZS  <Wd>, <Dn>"
          ]
        }
      },
      "FMADD_float": {
        "authored": "Floating-point fused Multiply-Add (scalar). This instruction multiplies the\nvalues of the first two SIMD&FP source registers, adds the product to the value\nof the third SIMD&FP source register, and writes the result to the SIMD&FP\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMADD",
        "templates": {
          "FLOAT": [
            "FMADD  <Hd>, <Hn>, <Hm>, <Ha>",
            "FMADD  <Sd>, <Sn>, <Sm>, <Sa>",
            "FMADD  <Dd>, <Dn>, <Dm>, <Da>"
          ]
        }
      },
      "FMAXNMP_advsimd_pair": {
        "authored": "Floating-point Maximum Number of Pair of elements (scalar). This instruction\ncompares two vector elements in the source SIMD&FP register and writes the\nlargest of the floating-point values as a scalar to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXNMP (scalar)",
        "templates": {
          "FMAXNMP_ASISDPAIR_ONLY_H": [
            "FMAXNMP  <V><d>, <Vn>.<T>"
          ],
          "FMAXNMP_ASISDPAIR_ONLY_SD": [
            "FMAXNMP  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMAXNMP_advsimd_vec": {
        "authored": "Floating-point Maximum Number Pairwise (vector). This instruction creates a\nvector by concatenating the vector elements of the first source SIMD&FP register\nafter the vector elements of the second source SIMD&FP register, reads each pair\nof adjacent vector elements in the two source SIMD&FP registers, writes the\nlargest of each pair of values into a vector, and writes the vector to the\ndestination SIMD&FP register. All the values in this instruction are floating-\npoint values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result is the numerical value,\notherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXNMP (vector)",
        "templates": {
          "FMAXNMP_ASIMDSAMEFP16_ONLY": [
            "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMAXNMP_ASIMDSAME_ONLY": [
            "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMAXNMV_advsimd": {
        "authored": "Floating-point Maximum Number across Vector. This instruction compares all the\nvector elements in the source SIMD&FP register, and writes the largest of the\nvalues as a scalar to the destination SIMD&FP register. All the values in this\ninstruction are floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result of the comparison is the\nnumerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXNMV",
        "templates": {
          "FMAXNMV_ASIMDALL_ONLY_H": [
            "FMAXNMV  <V><d>, <Vn>.<T>"
          ],
          "FMAXNMV_ASIMDALL_ONLY_SD": [
            "FMAXNMV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMAXNM_advsimd": {
        "authored": "Floating-point Maximum Number (vector). This instruction compares corresponding\nvector elements in the two source SIMD&FP registers, writes the larger of the\ntwo floating-point values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result placed in the vector is the\nnumerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXNM (vector)",
        "templates": {
          "FMAXNM_ASIMDSAMEFP16_ONLY": [
            "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMAXNM_ASIMDSAME_ONLY": [
            "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMAXNM_float": {
        "authored": "Floating-point Maximum Number (scalar). This instruction compares the first and\nsecond source SIMD&FP register values, and writes the larger of the two\nfloating-point values to the destination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result that is placed in the vector\nis the numerical value, otherwise the result is identical to FMAX (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXNM (scalar)",
        "templates": {
          "FLOAT": [
            "FMAXNM  <Hd>, <Hn>, <Hm>",
            "FMAXNM  <Sd>, <Sn>, <Sm>",
            "FMAXNM  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FMAXP_advsimd_pair": {
        "authored": "Floating-point Maximum of Pair of elements (scalar). This instruction compares\ntwo vector elements in the source SIMD&FP register and writes the largest of the\nfloating-point values as a scalar to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXP (scalar)",
        "templates": {
          "FMAXP_ASISDPAIR_ONLY_H": [
            "FMAXP  <V><d>, <Vn>.<T>"
          ],
          "FMAXP_ASISDPAIR_ONLY_SD": [
            "FMAXP  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMAXP_advsimd_vec": {
        "authored": "Floating-point Maximum Pairwise (vector). This instruction creates a vector by\nconcatenating the vector elements of the first source SIMD&FP register after the\nvector elements of the second source SIMD&FP register, reads each pair of\nadjacent vector elements from the concatenated vector, writes the larger of each\npair of values into a vector, and writes the vector to the destination SIMD&FP\nregister. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXP (vector)",
        "templates": {
          "FMAXP_ASIMDSAMEFP16_ONLY": [
            "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMAXP_ASIMDSAME_ONLY": [
            "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMAXV_advsimd": {
        "authored": "Floating-point Maximum across Vector. This instruction compares all the vector\nelements in the source SIMD&FP register, and writes the largest of the values as\na scalar to the destination SIMD&FP register. All the values in this instruction\nare floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAXV",
        "templates": {
          "FMAXV_ASIMDALL_ONLY_H": [
            "FMAXV  <V><d>, <Vn>.<T>"
          ],
          "FMAXV_ASIMDALL_ONLY_SD": [
            "FMAXV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMAX_advsimd": {
        "authored": "Floating-point Maximum (vector). This instruction compares corresponding vector\nelements in the two source SIMD&FP registers, places the larger of each of the\ntwo floating-point values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAX (vector)",
        "templates": {
          "FMAX_ASIMDSAMEFP16_ONLY": [
            "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMAX_ASIMDSAME_ONLY": [
            "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMAX_float": {
        "authored": "Floating-point Maximum (scalar). This instruction compares the two source\nSIMD&FP registers, and writes the larger of the two floating-point values to the\ndestination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMAX (scalar)",
        "templates": {
          "FLOAT": [
            "FMAX  <Hd>, <Hn>, <Hm>",
            "FMAX  <Sd>, <Sn>, <Sm>",
            "FMAX  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FMINNMP_advsimd_pair": {
        "authored": "Floating-point Minimum Number of Pair of elements (scalar). This instruction\ncompares two vector elements in the source SIMD&FP register and writes the\nsmallest of the floating-point values as a scalar to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINNMP (scalar)",
        "templates": {
          "FMINNMP_ASISDPAIR_ONLY_H": [
            "FMINNMP  <V><d>, <Vn>.<T>"
          ],
          "FMINNMP_ASISDPAIR_ONLY_SD": [
            "FMINNMP  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMINNMP_advsimd_vec": {
        "authored": "Floating-point Minimum Number Pairwise (vector). This instruction creates a\nvector by concatenating the vector elements of the first source SIMD&FP register\nafter the vector elements of the second source SIMD&FP register, reads each pair\nof adjacent vector elements in the two source SIMD&FP registers, writes the\nsmallest of each pair of floating-point values into a vector, and writes the\nvector to the destination SIMD&FP register. All the values in this instruction\nare floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result is the numerical value,\notherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINNMP (vector)",
        "templates": {
          "FMINNMP_ASIMDSAMEFP16_ONLY": [
            "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMINNMP_ASIMDSAME_ONLY": [
            "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMINNMV_advsimd": {
        "authored": "Floating-point Minimum Number across Vector. This instruction compares all the\nvector elements in the source SIMD&FP register, and writes the smallest of the\nvalues as a scalar to the destination SIMD&FP register. All the values in this\ninstruction are floating-point values.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result of the comparison is the\nnumerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINNMV",
        "templates": {
          "FMINNMV_ASIMDALL_ONLY_H": [
            "FMINNMV  <V><d>, <Vn>.<T>"
          ],
          "FMINNMV_ASIMDALL_ONLY_SD": [
            "FMINNMV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMINNM_advsimd": {
        "authored": "Floating-point Minimum Number (vector). This instruction compares corresponding\nvector elements in the two source SIMD&FP registers, writes the smaller of the\ntwo floating-point values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result placed in the vector is the\nnumerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINNM (vector)",
        "templates": {
          "FMINNM_ASIMDSAMEFP16_ONLY": [
            "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMINNM_ASIMDSAME_ONLY": [
            "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMINNM_float": {
        "authored": "Floating-point Minimum Number (scalar). This instruction compares the first and\nsecond source SIMD&FP register values, and writes the smaller of the two\nfloating-point values to the destination SIMD&FP register.\n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector element\nis numeric and the other is a quiet NaN, the result that is placed in the vector\nis the numerical value, otherwise the result is identical to FMIN (scalar).\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINNM (scalar)",
        "templates": {
          "FLOAT": [
            "FMINNM  <Hd>, <Hn>, <Hm>",
            "FMINNM  <Sd>, <Sn>, <Sm>",
            "FMINNM  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FMINP_advsimd_pair": {
        "authored": "Floating-point Minimum of Pair of elements (scalar). This instruction compares\ntwo vector elements in the source SIMD&FP register and writes the smallest of\nthe floating-point values as a scalar to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINP (scalar)",
        "templates": {
          "FMINP_ASISDPAIR_ONLY_H": [
            "FMINP  <V><d>, <Vn>.<T>"
          ],
          "FMINP_ASISDPAIR_ONLY_SD": [
            "FMINP  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMINP_advsimd_vec": {
        "authored": "Floating-point Minimum Pairwise (vector). This instruction creates a vector by\nconcatenating the vector elements of the first source SIMD&FP register after the\nvector elements of the second source SIMD&FP register, reads each pair of\nadjacent vector elements from the concatenated vector, writes the smaller of\neach pair of values into a vector, and writes the vector to the destination\nSIMD&FP register. All the values in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINP (vector)",
        "templates": {
          "FMINP_ASIMDSAMEFP16_ONLY": [
            "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMINP_ASIMDSAME_ONLY": [
            "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMINV_advsimd": {
        "authored": "Floating-point Minimum across Vector. This instruction compares all the vector\nelements in the source SIMD&FP register, and writes the smallest of the values\nas a scalar to the destination SIMD&FP register. All the values in this\ninstruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMINV",
        "templates": {
          "FMINV_ASIMDALL_ONLY_H": [
            "FMINV  <V><d>, <Vn>.<T>"
          ],
          "FMINV_ASIMDALL_ONLY_SD": [
            "FMINV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "FMIN_advsimd": {
        "authored": "Floating-point minimum (vector). This instruction compares corresponding\nelements in the vectors in the two source SIMD&FP registers, places the smaller\nof each of the two floating-point values into a vector, and writes the vector to\nthe destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMIN (vector)",
        "templates": {
          "FMIN_ASIMDSAMEFP16_ONLY": [
            "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMIN_ASIMDSAME_ONLY": [
            "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMIN_float": {
        "authored": "Floating-point Minimum (scalar). This instruction compares the first and second\nsource SIMD&FP register values, and writes the smaller of the two floating-point\nvalues to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMIN (scalar)",
        "templates": {
          "FLOAT": [
            "FMIN  <Hd>, <Hn>, <Hm>",
            "FMIN  <Sd>, <Sn>, <Sm>",
            "FMIN  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FMLAL_advsimd_elt": {
        "authored": "Floating-point fused Multiply-Add Long to accumulator (by element). This\ninstruction multiplies the vector elements in the first source SIMD&FP register\nby the specified value in the second source SIMD&FP register, and accumulates\nthe product to the corresponding vector element of the destination SIMD&FP\nregister. The instruction does not round the result of the multiply before the\naccumulation.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.",
        "heading": "FMLAL, FMLAL2 (by element)",
        "templates": {
          "FMLAL2_ASIMDELEM_LH": [
            "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]"
          ],
          "FMLAL_ASIMDELEM_LH": [
            "FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]"
          ]
        }
      },
      "FMLAL_advsimd_vec": {
        "authored": "Floating-point fused Multiply-Add Long to accumulator (vector). This instruction\nmultiplies corresponding half-precision floating-point values in the vectors in\nthe two source SIMD&FP registers, and accumulates the product to the\ncorresponding vector element of the destination SIMD&FP register. The\ninstruction does not round the result of the multiply before the accumulation.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.",
        "heading": "FMLAL, FMLAL2 (vector)",
        "templates": {
          "FMLAL2_ASIMDSAME_F": [
            "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ],
          "FMLAL_ASIMDSAME_F": [
            "FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "FMLA_advsimd_elt": {
        "authored": "Floating-point fused Multiply-Add to accumulator (by element). This instruction\nmultiplies the vector elements in the first source SIMD&FP register by the\nspecified value in the second source SIMD&FP register, and accumulates the\nresults in the vector elements of the destination SIMD&FP register. All the\nvalues in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMLA (by element)",
        "templates": {
          "FMLA_ASIMDELEM_RH_H": [
            "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
          ],
          "FMLA_ASIMDELEM_R_SD": [
            "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "FMLA_ASISDELEM_RH_H": [
            "FMLA  <Hd>, <Hn>, <Vm>.H[<index>]"
          ],
          "FMLA_ASISDELEM_R_SD": [
            "FMLA  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "FMLA_advsimd_vec": {
        "authored": "Floating-point fused Multiply-Add to accumulator (vector). This instruction\nmultiplies corresponding floating-point values in the vectors in the two source\nSIMD&FP registers, adds the product to the corresponding vector element of the\ndestination SIMD&FP register, and writes the result to the destination SIMD&FP\nregister.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMLA (vector)",
        "templates": {
          "FMLA_ASIMDSAMEFP16_ONLY": [
            "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMLA_ASIMDSAME_ONLY": [
            "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMLSL_advsimd_elt": {
        "authored": "Floating-point fused Multiply-Subtract Long from accumulator (by element). This\ninstruction multiplies the negated vector elements in the first source SIMD&FP\nregister by the specified value in the second source SIMD&FP register, and\naccumulates the product to the corresponding vector element of the destination\nSIMD&FP register. The instruction does not round the result of the multiply\nbefore the accumulation.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.",
        "heading": "FMLSL, FMLSL2 (by element)",
        "templates": {
          "FMLSL2_ASIMDELEM_LH": [
            "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]"
          ],
          "FMLSL_ASIMDELEM_LH": [
            "FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]"
          ]
        }
      },
      "FMLSL_advsimd_vec": {
        "authored": "Floating-point fused Multiply-Subtract Long from accumulator (vector). This\ninstruction negates the values in the vector of one SIMD&FP register, multiplies\nthese with the corresponding values in another vector, and accumulates the\nproduct to the corresponding vector element of the destination SIMD&FP register.\nThe instruction does not round the result of the multiply before the\naccumulation.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.",
        "heading": "FMLSL, FMLSL2 (vector)",
        "templates": {
          "FMLSL2_ASIMDSAME_F": [
            "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ],
          "FMLSL_ASIMDSAME_F": [
            "FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "FMLS_advsimd_elt": {
        "authored": "Floating-point fused Multiply-Subtract from accumulator (by element). This\ninstruction multiplies the vector elements in the first source SIMD&FP register\nby the specified value in the second source SIMD&FP register, and subtracts the\nresults from the vector elements of the destination SIMD&FP register. All the\nvalues in this instruction are floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMLS (by element)",
        "templates": {
          "FMLS_ASIMDELEM_RH_H": [
            "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
          ],
          "FMLS_ASIMDELEM_R_SD": [
            "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "FMLS_ASISDELEM_RH_H": [
            "FMLS  <Hd>, <Hn>, <Vm>.H[<index>]"
          ],
          "FMLS_ASISDELEM_R_SD": [
            "FMLS  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "FMLS_advsimd_vec": {
        "authored": "Floating-point fused Multiply-Subtract from accumulator (vector). This\ninstruction multiplies corresponding floating-point values in the vectors in the\ntwo source SIMD&FP registers, negates the product, adds the result to the\ncorresponding vector element of the destination SIMD&FP register, and writes the\nresult to the destination SIMD&FP register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMLS (vector)",
        "templates": {
          "FMLS_ASIMDSAMEFP16_ONLY": [
            "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMLS_ASIMDSAME_ONLY": [
            "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMOV_advsimd": {
        "authored": "Floating-point move immediate (vector). This instruction copies an immediate\nfloating-point constant into every element of the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMOV (vector, immediate)",
        "templates": {
          "FMOV_ASIMDIMM_H_H": [
            "FMOV  <Vd>.<T>, #<imm>"
          ],
          "SINGLE_AND_DOUBLE": [
            "FMOV  <Vd>.<T>, #<imm>",
            "FMOV  <Vd>.2D, #<imm>"
          ]
        }
      },
      "FMOV_float": {
        "authored": "Floating-point Move register without conversion. This instruction copies the\nfloating-point value in the SIMD&FP source register to the SIMD&FP destination\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMOV (register)",
        "templates": {
          "FLOAT": [
            "FMOV  <Hd>, <Hn>",
            "FMOV  <Sd>, <Sn>",
            "FMOV  <Dd>, <Dn>"
          ]
        }
      },
      "FMOV_float_gen": {
        "authored": "Floating-point Move to or from general-purpose register without conversion. This\ninstruction transfers the contents of a SIMD&FP register to a general-purpose\nregister, or the contents of a general-purpose register to a SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMOV (general)",
        "templates": {
          "FLOAT": [
            "FMOV  <Wd>, <Hn>",
            "FMOV  <Xd>, <Hn>",
            "FMOV  <Hd>, <Wn>",
            "FMOV  <Sd>, <Wn>",
            "FMOV  <Wd>, <Sn>",
            "FMOV  <Hd>, <Xn>",
            "FMOV  <Dd>, <Xn>",
            "FMOV  <Vd>.D[1], <Xn>",
            "FMOV  <Xd>, <Dn>",
            "FMOV  <Xd>, <Vn>.D[1]"
          ]
        }
      },
      "FMOV_float_imm": {
        "authored": "Floating-point move immediate (scalar). This instruction copies a floating-point\nimmediate constant into the SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMOV (scalar, immediate)",
        "templates": {
          "IMM8F": [
            "FMOV  <Hd>, #<imm>",
            "FMOV  <Sd>, #<imm>",
            "FMOV  <Dd>, #<imm>"
          ]
        }
      },
      "FMSUB_float": {
        "authored": "Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies the\nvalues of the first two SIMD&FP source registers, negates the product, adds that\nto the value of the third SIMD&FP source register, and writes the result to the\nSIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMSUB",
        "templates": {
          "FLOAT": [
            "FMSUB  <Hd>, <Hn>, <Hm>, <Ha>",
            "FMSUB  <Sd>, <Sn>, <Sm>, <Sa>",
            "FMSUB  <Dd>, <Dn>, <Dm>, <Da>"
          ]
        }
      },
      "FMULX_advsimd_elt": {
        "authored": "Floating-point Multiply extended (by element). This instruction multiplies the\nfloating-point values in the vector elements in the first source SIMD&FP\nregister by the specified floating-point value in the second source SIMD&FP\nregister, places the results in a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nIf one value is zero and the other value is infinite, the result is 2.0. In this\ncase, the result is negative if only one of the values is negative, otherwise\nthe result is positive.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMULX (by element)",
        "templates": {
          "FMULX_ASIMDELEM_RH_H": [
            "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
          ],
          "FMULX_ASIMDELEM_R_SD": [
            "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "FMULX_ASISDELEM_RH_H": [
            "FMULX  <Hd>, <Hn>, <Vm>.H[<index>]"
          ],
          "FMULX_ASISDELEM_R_SD": [
            "FMULX  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "FMULX_advsimd_vec": {
        "authored": "Floating-point Multiply extended. This instruction multiplies corresponding\nfloating-point values in the vectors of the two source SIMD&FP registers, places\nthe resulting floating-point values in a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nIf one value is zero and the other value is infinite, the result is 2.0. In this\ncase, the result is negative if only one of the values is negative, otherwise\nthe result is positive.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMULX",
        "templates": {
          "FMULX_ASIMDSAMEFP16_ONLY": [
            "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMULX_ASIMDSAME_ONLY": [
            "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMULX_ASISDSAMEFP16_ONLY": [
            "FMULX  <Hd>, <Hn>, <Hm>"
          ],
          "FMULX_ASISDSAME_ONLY": [
            "FMULX  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FMUL_advsimd_elt": {
        "authored": "Floating-point Multiply (by element). This instruction multiplies the vector\nelements in the first source SIMD&FP register by the specified value in the\nsecond source SIMD&FP register, places the results in a vector, and writes the\nvector to the destination SIMD&FP register. All the values in this instruction\nare floating-point values.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMUL (by element)",
        "templates": {
          "FMUL_ASIMDELEM_RH_H": [
            "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
          ],
          "FMUL_ASIMDELEM_R_SD": [
            "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "FMUL_ASISDELEM_RH_H": [
            "FMUL  <Hd>, <Hn>, <Vm>.H[<index>]"
          ],
          "FMUL_ASISDELEM_R_SD": [
            "FMUL  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "FMUL_advsimd_vec": {
        "authored": "Floating-point Multiply (vector). This instruction multiplies corresponding\nfloating-point values in the vectors in the two source SIMD&FP registers, places\nthe result in a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMUL (vector)",
        "templates": {
          "FMUL_ASIMDSAMEFP16_ONLY": [
            "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FMUL_ASIMDSAME_ONLY": [
            "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FMUL_float": {
        "authored": "Floating-point Multiply (scalar). This instruction multiplies the floating-point\nvalues of the two source SIMD&FP registers, and writes the result to the\ndestination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FMUL (scalar)",
        "templates": {
          "FLOAT": [
            "FMUL  <Hd>, <Hn>, <Hm>",
            "FMUL  <Sd>, <Sn>, <Sm>",
            "FMUL  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FNEG_advsimd": {
        "authored": "Floating-point Negate (vector). This instruction negates the value of each\nvector element in the source SIMD&FP register, writes the result to a vector,\nand writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FNEG (vector)",
        "templates": {
          "FNEG_ASIMDMISCFP16_R": [
            "FNEG  <Vd>.<T>, <Vn>.<T>"
          ],
          "FNEG_ASIMDMISC_R": [
            "FNEG  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FNEG_float": {
        "authored": "Floating-point Negate (scalar). This instruction negates the value in the\nSIMD&FP source register and writes the result to the SIMD&FP destination\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FNEG (scalar)",
        "templates": {
          "FLOAT": [
            "FNEG  <Hd>, <Hn>",
            "FNEG  <Sd>, <Sn>",
            "FNEG  <Dd>, <Dn>"
          ]
        }
      },
      "FNMADD_float": {
        "authored": "Floating-point Negated fused Multiply-Add (scalar). This instruction multiplies\nthe values of the first two SIMD&FP source registers, negates the product,\nsubtracts the value of the third SIMD&FP source register, and writes the result\nto the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FNMADD",
        "templates": {
          "FLOAT": [
            "FNMADD  <Hd>, <Hn>, <Hm>, <Ha>",
            "FNMADD  <Sd>, <Sn>, <Sm>, <Sa>",
            "FNMADD  <Dd>, <Dn>, <Dm>, <Da>"
          ]
        }
      },
      "FNMSUB_float": {
        "authored": "Floating-point Negated fused Multiply-Subtract (scalar). This instruction\nmultiplies the values of the first two SIMD&FP source registers, subtracts the\nvalue of the third SIMD&FP source register, and writes the result to the\ndestination SIMD&FP register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FNMSUB",
        "templates": {
          "FLOAT": [
            "FNMSUB  <Hd>, <Hn>, <Hm>, <Ha>",
            "FNMSUB  <Sd>, <Sn>, <Sm>, <Sa>",
            "FNMSUB  <Dd>, <Dn>, <Dm>, <Da>"
          ]
        }
      },
      "FNMUL_float": {
        "authored": "Floating-point Multiply-Negate (scalar). This instruction multiplies the\nfloating-point values of the two source SIMD&FP registers, and writes the\nnegation of the result to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FNMUL (scalar)",
        "templates": {
          "FLOAT": [
            "FNMUL  <Hd>, <Hn>, <Hm>",
            "FNMUL  <Sd>, <Sn>, <Sm>",
            "FNMUL  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "FRECPE_advsimd": {
        "authored": "Floating-point Reciprocal Estimate. This instruction finds an approximate\nreciprocal estimate for each vector element in the source SIMD&FP register,\nplaces the result in a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRECPE",
        "templates": {
          "FRECPE_ASIMDMISCFP16_R": [
            "FRECPE  <Vd>.<T>, <Vn>.<T>"
          ],
          "FRECPE_ASIMDMISC_R": [
            "FRECPE  <Vd>.<T>, <Vn>.<T>"
          ],
          "FRECPE_ASISDMISCFP16_R": [
            "FRECPE  <Hd>, <Hn>"
          ],
          "FRECPE_ASISDMISC_R": [
            "FRECPE  <V><d>, <V><n>"
          ]
        }
      },
      "FRECPS_advsimd": {
        "authored": "Floating-point Reciprocal Step. This instruction multiplies the corresponding\nfloating-point values in the vectors of the two source SIMD&FP registers,\nsubtracts each of the products from 2.0, places the resulting floating-point\nvalues in a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRECPS",
        "templates": {
          "FRECPS_ASIMDSAMEFP16_ONLY": [
            "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FRECPS_ASIMDSAME_ONLY": [
            "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FRECPS_ASISDSAMEFP16_ONLY": [
            "FRECPS  <Hd>, <Hn>, <Hm>"
          ],
          "FRECPS_ASISDSAME_ONLY": [
            "FRECPS  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FRECPX_advsimd": {
        "authored": "Floating-point Reciprocal exponent (scalar). This instruction finds an\napproximate reciprocal exponent for each vector element in the source SIMD&FP\nregister, places the result in a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRECPX",
        "templates": {
          "FRECPX_ASISDMISCFP16_R": [
            "FRECPX  <Hd>, <Hn>"
          ],
          "FRECPX_ASISDMISC_R": [
            "FRECPX  <V><d>, <V><n>"
          ]
        }
      },
      "FRINT32X_advsimd": {
        "authored": "Floating-point Round to 32-bit Integer, using current rounding mode (vector).\nThis instruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values that fit into a 32-bit integer size\nusing the rounding mode that is determined by the FPCR, and writes the result to\nthe SIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When one of the result\nvalues is not numerically equal to the corresponding input value, an Inexact\nexception is raised. When an input is infinite, NaN or out-of-range, the\ninstruction returns for the corresponding result value the most negative integer\nrepresentable in the destination size, and an Invalid Operation floating-point\nexception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT32X (vector)",
        "templates": {
          "FRINT32X_ASIMDMISC_R": [
            "FRINT32X  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINT32X_float": {
        "authored": "Floating-point Round to 32-bit Integer, using current rounding mode (scalar).\nThis instruction rounds a floating-point value in the SIMD&FP source register to\nan integral floating-point value that fits into a 32-bit integer size using the\nrounding mode that is determined by the FPCR, and writes the result to the\nSIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When the result value is\nnot numerically equal to the input value, an Inexact exception is raised. When\nthe input is infinite, NaN or out-of-range, the instruction returns {for the\ncorresponding result value} the most negative integer representable in the\ndestination size, and an Invalid Operation floating-point exception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT32X (scalar)",
        "templates": {
          "FLOAT": [
            "FRINT32X  <Sd>, <Sn>",
            "FRINT32X  <Dd>, <Dn>"
          ]
        }
      },
      "FRINT32Z_advsimd": {
        "authored": "Floating-point Round to 32-bit Integer toward Zero (vector). This instruction\nrounds a vector of floating-point values in the SIMD&FP source register to\nintegral floating-point values that fit into a 32-bit integer size using the\nRound towards Zero rounding mode, and writes the result to the SIMD&FP\ndestination register.\n\nA zero input returns a zero result with the same sign. When one of the result\nvalues is not numerically equal to the corresponding input value, an Inexact\nexception is raised. When an input is infinite, NaN or out-of-range, the\ninstruction returns for the corresponding result value the most negative integer\nrepresentable in the destination size, and an Invalid Operation floating-point\nexception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT32Z (vector)",
        "templates": {
          "FRINT32Z_ASIMDMISC_R": [
            "FRINT32Z  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINT32Z_float": {
        "authored": "Floating-point Round to 32-bit Integer toward Zero (scalar). This instruction\nrounds a floating-point value in the SIMD&FP source register to an integral\nfloating-point value that fits into a 32-bit integer size using the Round\ntowards Zero rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input returns a zero result with the same sign. When the result value is\nnot numerically equal to the {corresponding} input value, an Inexact exception\nis raised. When the input is infinite, NaN or out-of-range, the instruction\nreturns {for the corresponding result value} the most negative integer\nrepresentable in the destination size, and an Invalid Operation floating-point\nexception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT32Z (scalar)",
        "templates": {
          "FLOAT": [
            "FRINT32Z  <Sd>, <Sn>",
            "FRINT32Z  <Dd>, <Dn>"
          ]
        }
      },
      "FRINT64X_advsimd": {
        "authored": "Floating-point Round to 64-bit Integer, using current rounding mode (vector).\nThis instruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values that fit into a 64-bit integer size\nusing the rounding mode that is determined by the FPCR, and writes the result to\nthe SIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When one of the result\nvalues is not numerically equal to the corresponding input value, an Inexact\nexception is raised. When an input is infinite, NaN or out-of-range, the\ninstruction returns for the corresponding result value the most negative integer\nrepresentable in the destination size, and an Invalid Operation floating-point\nexception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT64X (vector)",
        "templates": {
          "FRINT64X_ASIMDMISC_R": [
            "FRINT64X  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINT64X_float": {
        "authored": "Floating-point Round to 64-bit Integer, using current rounding mode (scalar).\nThis instruction rounds a floating-point value in the SIMD&FP source register to\nan integral floating-point value that fits into a 64-bit integer size using the\nrounding mode that is determined by the FPCR, and writes the result to the\nSIMD&FP destination register.\n\nA zero input returns a zero result with the same sign. When the result value is\nnot numerically equal to the input value, an Inexact exception is raised. When\nthe input is infinite, NaN or out-of-range, the instruction returns {for the\ncorresponding result value} the most negative integer representable in the\ndestination size, and an Invalid Operation floating-point exception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT64X (scalar)",
        "templates": {
          "FLOAT": [
            "FRINT64X  <Sd>, <Sn>",
            "FRINT64X  <Dd>, <Dn>"
          ]
        }
      },
      "FRINT64Z_advsimd": {
        "authored": "Floating-point Round to 64-bit Integer toward Zero (vector). This instruction\nrounds a vector of floating-point values in the SIMD&FP source register to\nintegral floating-point values that fit into a 64-bit integer size using the\nRound towards Zero rounding mode, and writes the result to the SIMD&FP\ndestination register.\n\nA zero input returns a zero result with the same sign. When one of the result\nvalues is not numerically equal to the corresponding input value, an Inexact\nexception is raised. When an input is infinite, NaN or out-of-range, the\ninstruction returns for the corresponding result value the most negative integer\nrepresentable in the destination size, and an Invalid Operation floating-point\nexception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT64Z (vector)",
        "templates": {
          "FRINT64Z_ASIMDMISC_R": [
            "FRINT64Z  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINT64Z_float": {
        "authored": "Floating-point Round to 64-bit Integer toward Zero (scalar). This instruction\nrounds a floating-point value in the SIMD&FP source register to an integral\nfloating-point value that fits into a 64-bit integer size using the Round\ntowards Zero rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input returns a zero result with the same sign. When the result value is\nnot numerically equal to the {corresponding} input value, an Inexact exception\nis raised. When the input is infinite, NaN or out-of-range, the instruction\nreturns {for the corresponding result value} the most negative integer\nrepresentable in the destination size, and an Invalid Operation floating-point\nexception is raised.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINT64Z (scalar)",
        "templates": {
          "FLOAT": [
            "FRINT64Z  <Sd>, <Sn>",
            "FRINT64Z  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTA_advsimd": {
        "authored": "Floating-point Round to Integral, to nearest with ties to Away (vector). This\ninstruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values of the same size using the Round to\nNearest with Ties to Away rounding mode, and writes the result to the SIMD&FP\ndestination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTA (vector)",
        "templates": {
          "FRINTA_ASIMDMISCFP16_R": [
            "FRINTA  <Vd>.<T>, <Vn>.<T>"
          ],
          "FRINTA_ASIMDMISC_R": [
            "FRINTA  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTA_float": {
        "authored": "Floating-point Round to Integral, to nearest with ties to Away (scalar). This\ninstruction rounds a floating-point value in the SIMD&FP source register to an\nintegral floating-point value of the same size using the Round to Nearest with\nTies to Away rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTA (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTA  <Hd>, <Hn>",
            "FRINTA  <Sd>, <Sn>",
            "FRINTA  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTI_advsimd": {
        "authored": "Floating-point Round to Integral, using current rounding mode (vector). This\ninstruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values of the same size using the rounding\nmode that is determined by the FPCR, and writes the result to the SIMD&FP\ndestination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTI (vector)",
        "templates": {
          "FRINTI_ASIMDMISCFP16_R": [
            "FRINTI  <Vd>.<T>, <Vn>.<T>"
          ],
          "FRINTI_ASIMDMISC_R": [
            "FRINTI  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTI_float": {
        "authored": "Floating-point Round to Integral, using current rounding mode (scalar). This\ninstruction rounds a floating-point value in the SIMD&FP source register to an\nintegral floating-point value of the same size using the rounding mode that is\ndetermined by the FPCR, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTI (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTI  <Hd>, <Hn>",
            "FRINTI  <Sd>, <Sn>",
            "FRINTI  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTM_advsimd": {
        "authored": "Floating-point Round to Integral, toward Minus infinity (vector). This\ninstruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values of the same size using the Round\ntowards Minus Infinity rounding mode, and writes the result to the SIMD&FP\ndestination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTM (vector)",
        "templates": {
          "FRINTM_ASIMDMISCFP16_R": [
            "FRINTM  <Vd>.<T>, <Vn>.<T>"
          ],
          "FRINTM_ASIMDMISC_R": [
            "FRINTM  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTM_float": {
        "authored": "Floating-point Round to Integral, toward Minus infinity (scalar). This\ninstruction rounds a floating-point value in the SIMD&FP source register to an\nintegral floating-point value of the same size using the Round towards Minus\nInfinity rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTM (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTM  <Hd>, <Hn>",
            "FRINTM  <Sd>, <Sn>",
            "FRINTM  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTN_advsimd": {
        "authored": "Floating-point Round to Integral, to nearest with ties to even (vector). This\ninstruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values of the same size using the Round to\nNearest rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTN (vector)",
        "templates": {
          "FRINTN_ASIMDMISCFP16_R": [
            "FRINTN  <Vd>.<T>, <Vn>.<T>"
          ],
          "FRINTN_ASIMDMISC_R": [
            "FRINTN  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTN_float": {
        "authored": "Floating-point Round to Integral, to nearest with ties to even (scalar). This\ninstruction rounds a floating-point value in the SIMD&FP source register to an\nintegral floating-point value of the same size using the Round to Nearest\nrounding mode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTN (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTN  <Hd>, <Hn>",
            "FRINTN  <Sd>, <Sn>",
            "FRINTN  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTP_advsimd": {
        "authored": "Floating-point Round to Integral, toward Plus infinity (vector). This\ninstruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values of the same size using the Round\ntowards Plus Infinity rounding mode, and writes the result to the SIMD&FP\ndestination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTP (vector)",
        "templates": {
          "FRINTP_ASIMDMISCFP16_R": [
            "FRINTP  <Vd>.<T>, <Vn>.<T>"
          ],
          "FRINTP_ASIMDMISC_R": [
            "FRINTP  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTP_float": {
        "authored": "Floating-point Round to Integral, toward Plus infinity (scalar). This\ninstruction rounds a floating-point value in the SIMD&FP source register to an\nintegral floating-point value of the same size using the Round towards Plus\nInfinity rounding mode, and writes the result to the SIMD&FP destination\nregister.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTP (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTP  <Hd>, <Hn>",
            "FRINTP  <Sd>, <Sn>",
            "FRINTP  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTX_advsimd": {
        "authored": "Floating-point Round to Integral exact, using current rounding mode (vector).\nThis instruction rounds a vector of floating-point values in the SIMD&FP source\nregister to integral floating-point values of the same size using the rounding\nmode that is determined by the FPCR, and writes the result to the SIMD&FP\ndestination register.\n\nWhen a result value is not numerically equal to the corresponding input value,\nan Inexact exception is raised. A zero input gives a zero result with the same\nsign, an infinite input gives an infinite result with the same sign, and a NaN\nis propagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTX (vector)",
        "templates": {
          "FRINTX_ASIMDMISCFP16_R": [
            "FRINTX  <Vd>.<T>, <Vn>.<T>"
          ],
          "FRINTX_ASIMDMISC_R": [
            "FRINTX  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTX_float": {
        "authored": "Floating-point Round to Integral exact, using current rounding mode (scalar).\nThis instruction rounds a floating-point value in the SIMD&FP source register to\nan integral floating-point value of the same size using the rounding mode that\nis determined by the FPCR, and writes the result to the SIMD&FP destination\nregister.\n\nWhen the result value is not numerically equal to the input value, an Inexact\nexception is raised. A zero input gives a zero result with the same sign, an\ninfinite input gives an infinite result with the same sign, and a NaN is\npropagated as for normal arithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTX (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTX  <Hd>, <Hn>",
            "FRINTX  <Sd>, <Sn>",
            "FRINTX  <Dd>, <Dn>"
          ]
        }
      },
      "FRINTZ_advsimd": {
        "authored": "Floating-point Round to Integral, toward Zero (vector). This instruction rounds\na vector of floating-point values in the SIMD&FP source register to integral\nfloating-point values of the same size using the Round towards Zero rounding\nmode, and writes the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTZ (vector)",
        "templates": {
          "FRINTZ_ASIMDMISCFP16_R": [
            "FRINTZ  <Vd>.<T>, <Vn>.<T>"
          ],
          "FRINTZ_ASIMDMISC_R": [
            "FRINTZ  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FRINTZ_float": {
        "authored": "Floating-point Round to Integral, toward Zero (scalar). This instruction rounds\na floating-point value in the SIMD&FP source register to an integral floating-\npoint value of the same size using the Round towards Zero rounding mode, and\nwrites the result to the SIMD&FP destination register.\n\nA zero input gives a zero result with the same sign, an infinite input gives an\ninfinite result with the same sign, and a NaN is propagated as for normal\narithmetic.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRINTZ (scalar)",
        "templates": {
          "FLOAT": [
            "FRINTZ  <Hd>, <Hn>",
            "FRINTZ  <Sd>, <Sn>",
            "FRINTZ  <Dd>, <Dn>"
          ]
        }
      },
      "FRSQRTE_advsimd": {
        "authored": "Floating-point Reciprocal Square Root Estimate. This instruction calculates an\napproximate square root for each vector element in the source SIMD&FP register,\nplaces the result in a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRSQRTE",
        "templates": {
          "FRSQRTE_ASIMDMISCFP16_R": [
            "FRSQRTE  <Vd>.<T>, <Vn>.<T>"
          ],
          "FRSQRTE_ASIMDMISC_R": [
            "FRSQRTE  <Vd>.<T>, <Vn>.<T>"
          ],
          "FRSQRTE_ASISDMISCFP16_R": [
            "FRSQRTE  <Hd>, <Hn>"
          ],
          "FRSQRTE_ASISDMISC_R": [
            "FRSQRTE  <V><d>, <V><n>"
          ]
        }
      },
      "FRSQRTS_advsimd": {
        "authored": "Floating-point Reciprocal Square Root Step. This instruction multiplies\ncorresponding floating-point values in the vectors of the two source SIMD&FP\nregisters, subtracts each of the products from 3.0, divides these results by\n2.0, places the results into a vector, and writes the vector to the destination\nSIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FRSQRTS",
        "templates": {
          "FRSQRTS_ASIMDSAMEFP16_ONLY": [
            "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FRSQRTS_ASIMDSAME_ONLY": [
            "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FRSQRTS_ASISDSAMEFP16_ONLY": [
            "FRSQRTS  <Hd>, <Hn>, <Hm>"
          ],
          "FRSQRTS_ASISDSAME_ONLY": [
            "FRSQRTS  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "FSQRT_advsimd": {
        "authored": "Floating-point Square Root (vector). This instruction calculates the square root\nfor each vector element in the source SIMD&FP register, places the result in a\nvector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FSQRT (vector)",
        "templates": {
          "FSQRT_ASIMDMISCFP16_R": [
            "FSQRT  <Vd>.<T>, <Vn>.<T>"
          ],
          "FSQRT_ASIMDMISC_R": [
            "FSQRT  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "FSQRT_float": {
        "authored": "Floating-point Square Root (scalar). This instruction calculates the square root\nof the value in the SIMD&FP source register and writes the result to the SIMD&FP\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FSQRT (scalar)",
        "templates": {
          "FLOAT": [
            "FSQRT  <Hd>, <Hn>",
            "FSQRT  <Sd>, <Sn>",
            "FSQRT  <Dd>, <Dn>"
          ]
        }
      },
      "FSUB_advsimd": {
        "authored": "Floating-point Subtract (vector). This instruction subtracts the elements in the\nvector in the second source SIMD&FP register, from the corresponding elements in\nthe vector in the first source SIMD&FP register, places each result into\nelements of a vector, and writes the vector to the destination SIMD&FP register.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FSUB (vector)",
        "templates": {
          "FSUB_ASIMDSAMEFP16_ONLY": [
            "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "FSUB_ASIMDSAME_ONLY": [
            "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "FSUB_float": {
        "authored": "Floating-point Subtract (scalar). This instruction subtracts the floating-point\nvalue of the second source SIMD&FP register from the floating-point value of the\nfirst source SIMD&FP register, and writes the result to the destination SIMD&FP\nregister.\n\nThis instruction can generate a floating-point exception. Depending on the\nsettings in FPCR, the exception results in either a flag being set in FPSR, or a\nsynchronous exception being generated. For more information, see Floating-point\nexception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "FSUB (scalar)",
        "templates": {
          "FLOAT": [
            "FSUB  <Hd>, <Hn>, <Hm>",
            "FSUB  <Sd>, <Sn>, <Sm>",
            "FSUB  <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "INS_advsimd_elt": {
        "authored": "Insert vector element from another vector element. This instruction copies the\nvector element of the source SIMD&FP register to the specified vector element of\nthe destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP\nregister without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "INS (element)",
        "templates": {
          "INS_ASIMDINS_IV_V": [
            "INS  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]"
          ]
        }
      },
      "INS_advsimd_gen": {
        "authored": "Insert vector element from general-purpose register. This instruction copies the\ncontents of the source general-purpose register to the specified vector element\nin the destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP\nregister without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "INS (general)",
        "templates": {
          "INS_ASIMDINS_IR_R": [
            "INS  <Vd>.<Ts>[<index>], <R><n>"
          ]
        }
      },
      "LD1R_advsimd": {
        "authored": "Load one single-element structure and Replicate to all lanes (of one register).\nThis instruction loads a single-element structure from memory and replicates the\nstructure to all the lanes of the SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD1R",
        "templates": {
          "AS_POST_INDEX": [
            "LD1R  { <Vt>.<T> }, [<Xn|SP>], <imm>",
            "LD1R  { <Vt>.<T> }, [<Xn|SP>], <Xm>"
          ],
          "LD1R_ASISDLSO_R1": [
            "LD1R  { <Vt>.<T> }, [<Xn|SP>]"
          ]
        }
      },
      "LD1_advsimd_mult": {
        "authored": "Load multiple single-element structures to one, two, three, or four registers.\nThis instruction loads multiple single-element structures from memory and writes\nthe result to one, two, three, or four SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD1 (multiple structures)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD1  { <Vt>.<T> }, [<Xn|SP>]",
            "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]",
            "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]",
            "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD1  { <Vt>.<T> }, [<Xn|SP>], <imm>",
            "LD1  { <Vt>.<T> }, [<Xn|SP>], <Xm>",
            "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>",
            "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>",
            "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>",
            "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>",
            "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>",
            "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD1_advsimd_sngl": {
        "authored": "Load one single-element structure to one lane of one register. This instruction\nloads a single-element structure from memory and writes the result to the\nspecified lane of the SIMD&FP register without affecting the other bits of the\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD1 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD1  { <Vt>.B }[<index>], [<Xn|SP>]",
            "LD1  { <Vt>.H }[<index>], [<Xn|SP>]",
            "LD1  { <Vt>.S }[<index>], [<Xn|SP>]",
            "LD1  { <Vt>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD1  { <Vt>.B }[<index>], [<Xn|SP>], #1",
            "LD1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>",
            "LD1  { <Vt>.H }[<index>], [<Xn|SP>], #2",
            "LD1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>",
            "LD1  { <Vt>.S }[<index>], [<Xn|SP>], #4",
            "LD1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>",
            "LD1  { <Vt>.D }[<index>], [<Xn|SP>], #8",
            "LD1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD2R_advsimd": {
        "authored": "Load single 2-element structure and Replicate to all lanes of two registers.\nThis instruction loads a 2-element structure from memory and replicates the\nstructure to all the lanes of the two SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD2R",
        "templates": {
          "AS_POST_INDEX": [
            "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>",
            "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
          ],
          "LD2R_ASISDLSO_R2": [
            "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
          ]
        }
      },
      "LD2_advsimd_mult": {
        "authored": "Load multiple 2-element structures to two registers. This instruction loads\nmultiple 2-element structures from memory and writes the result to the two\nSIMD&FP registers, with de-interleaving.\n\nFor an example of de-interleaving, see LD3 (multiple structures).\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD2 (multiple structures)",
        "templates": {
          "AS_POST_INDEX": [
            "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>",
            "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
          ],
          "LD2_ASISDLSE_R2": [
            "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
          ]
        }
      },
      "LD2_advsimd_sngl": {
        "authored": "Load single 2-element structure to one lane of two registers. This instruction\nloads a 2-element structure from memory and writes the result to the\ncorresponding elements of the two SIMD&FP registers without affecting the other\nbits of the registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD2 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]",
            "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]",
            "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]",
            "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2",
            "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>",
            "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4",
            "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>",
            "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8",
            "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>",
            "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16",
            "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD3R_advsimd": {
        "authored": "Load single 3-element structure and Replicate to all lanes of three registers.\nThis instruction loads a 3-element structure from memory and replicates the\nstructure to all the lanes of the three SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD3R",
        "templates": {
          "AS_POST_INDEX": [
            "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>",
            "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
          ],
          "LD3R_ASISDLSO_R3": [
            "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
          ]
        }
      },
      "LD3_advsimd_mult": {
        "authored": "Load multiple 3-element structures to three registers. This instruction loads\nmultiple 3-element structures from memory and writes the result to the three\nSIMD&FP registers, with de-interleaving.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD3 (multiple structures)",
        "templates": {
          "AS_POST_INDEX": [
            "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>",
            "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
          ],
          "LD3_ASISDLSE_R3": [
            "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
          ]
        }
      },
      "LD3_advsimd_sngl": {
        "authored": "Load single 3-element structure to one lane of three registers). This\ninstruction loads a 3-element structure from memory and writes the result to the\ncorresponding elements of the three SIMD&FP registers without affecting the\nother bits of the registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD3 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]",
            "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]",
            "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]",
            "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3",
            "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>",
            "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6",
            "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>",
            "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12",
            "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>",
            "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24",
            "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LD4R_advsimd": {
        "authored": "Load single 4-element structure and Replicate to all lanes of four registers.\nThis instruction loads a 4-element structure from memory and replicates the\nstructure to all the lanes of the four SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD4R",
        "templates": {
          "AS_POST_INDEX": [
            "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>",
            "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          ],
          "LD4R_ASISDLSO_R4": [
            "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          ]
        }
      },
      "LD4_advsimd_mult": {
        "authored": "Load multiple 4-element structures to four registers. This instruction loads\nmultiple 4-element structures from memory and writes the result to the four\nSIMD&FP registers, with de-interleaving.\n\nFor an example of de-interleaving, see LD3 (multiple structures).\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD4 (multiple structures)",
        "templates": {
          "AS_POST_INDEX": [
            "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>",
            "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          ],
          "LD4_ASISDLSE_R4": [
            "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          ]
        }
      },
      "LD4_advsimd_sngl": {
        "authored": "Load single 4-element structure to one lane of four registers. This instruction\nloads a 4-element structure from memory and writes the result to the\ncorresponding elements of the four SIMD&FP registers without affecting the other\nbits of the registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LD4 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]",
            "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]",
            "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]",
            "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4",
            "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>",
            "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8",
            "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>",
            "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16",
            "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>",
            "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32",
            "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "LDNP_fpsimd": {
        "authored": "Load Pair of SIMD&FP registers, with Non-temporal hint. This instruction loads a\npair of SIMD&FP registers from memory, issuing a hint to the memory system that\nthe access is non-temporal. The address that is used for the load is calculated\nfrom a base register value and an optional immediate offset.\n\nFor information about non-temporal pair instructions, see Load/Store SIMD and\nFloating-point Non-temporal pair.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LDNP (SIMD&FP)",
        "templates": {
          "SIGNED_SCALED_OFFSET": [
            "LDNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]",
            "LDNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]",
            "LDNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "LDP_fpsimd": {
        "authored": "Load Pair of SIMD&FP registers. This instruction loads a pair of SIMD&FP\nregisters from memory. The address that is used for the load is calculated from\na base register value and an optional immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LDP (SIMD&FP)",
        "templates": {
          "POST_INDEXED": [
            "LDP  <St1>, <St2>, [<Xn|SP>], #<imm>",
            "LDP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>",
            "LDP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>"
          ],
          "PRE_INDEXED": [
            "LDP  <St1>, <St2>, [<Xn|SP>, #<imm>]!",
            "LDP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!",
            "LDP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "LDP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]",
            "LDP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]",
            "LDP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "LDR_imm_fpsimd": {
        "authored": "Load SIMD&FP Register (immediate offset). This instruction loads an element from\nmemory, and writes the result as a scalar to the SIMD&FP register. The address\nthat is used for the load is calculated from a base register value, a signed\nimmediate offset, and an optional offset that is a multiple of the element size.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LDR (immediate, SIMD&FP)",
        "templates": {
          "POST_INDEXED": [
            "LDR  <Bt>, [<Xn|SP>], #<simm>",
            "LDR  <Ht>, [<Xn|SP>], #<simm>",
            "LDR  <St>, [<Xn|SP>], #<simm>",
            "LDR  <Dt>, [<Xn|SP>], #<simm>",
            "LDR  <Qt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "LDR  <Bt>, [<Xn|SP>, #<simm>]!",
            "LDR  <Ht>, [<Xn|SP>, #<simm>]!",
            "LDR  <St>, [<Xn|SP>, #<simm>]!",
            "LDR  <Dt>, [<Xn|SP>, #<simm>]!",
            "LDR  <Qt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "LDR  <Bt>, [<Xn|SP>{, #<pimm>}]",
            "LDR  <Ht>, [<Xn|SP>{, #<pimm>}]",
            "LDR  <St>, [<Xn|SP>{, #<pimm>}]",
            "LDR  <Dt>, [<Xn|SP>{, #<pimm>}]",
            "LDR  <Qt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "LDR_lit_fpsimd": {
        "authored": "Load SIMD&FP Register (PC-relative literal). This instruction loads a SIMD&FP\nregister from memory. The address that is used for the load is calculated from\nthe PC value and an immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LDR (literal, SIMD&FP)",
        "templates": {
          "LITERAL": [
            "LDR  <St>, <label>",
            "LDR  <Dt>, <label>",
            "LDR  <Qt>, <label>"
          ]
        }
      },
      "LDR_reg_fpsimd": {
        "authored": "Load SIMD&FP Register (register offset). This instruction loads a SIMD&FP\nregister from memory. The address that is used for the load is calculated from a\nbase register value and an offset register value. The offset can be optionally\nshifted and extended.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LDR (register, SIMD&FP)",
        "templates": {
          "FPSIMD": [
            "LDR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]",
            "LDR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]",
            "LDR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "LDR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "LDR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "LDR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "LDUR_fpsimd": {
        "authored": "Load SIMD&FP Register (unscaled offset). This instruction loads a SIMD&FP\nregister from memory. The address that is used for the load is calculated from a\nbase register value and an optional immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "LDUR (SIMD&FP)",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "LDUR  <Bt>, [<Xn|SP>{, #<simm>}]",
            "LDUR  <Ht>, [<Xn|SP>{, #<simm>}]",
            "LDUR  <St>, [<Xn|SP>{, #<simm>}]",
            "LDUR  <Dt>, [<Xn|SP>{, #<simm>}]",
            "LDUR  <Qt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "MLA_advsimd_elt": {
        "authored": "Multiply-Add to accumulator (vector, by element). This instruction multiplies\nthe vector elements in the first source SIMD&FP register by the specified value\nin the second source SIMD&FP register, and accumulates the results with the\nvector elements of the destination SIMD&FP register. All the values in this\ninstruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MLA (by element)",
        "templates": {
          "MLA_ASIMDELEM_R": [
            "MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "MLA_advsimd_vec": {
        "authored": "Multiply-Add to accumulator (vector). This instruction multiplies corresponding\nelements in the vectors of the two source SIMD&FP registers, and accumulates the\nresults with the vector elements of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MLA (vector)",
        "templates": {
          "MLA_ASIMDSAME_ONLY": [
            "MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "MLS_advsimd_elt": {
        "authored": "Multiply-Subtract from accumulator (vector, by element). This instruction\nmultiplies the vector elements in the first source SIMD&FP register by the\nspecified value in the second source SIMD&FP register, and subtracts the results\nfrom the vector elements of the destination SIMD&FP register. All the values in\nthis instruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MLS (by element)",
        "templates": {
          "MLS_ASIMDELEM_R": [
            "MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "MLS_advsimd_vec": {
        "authored": "Multiply-Subtract from accumulator (vector). This instruction multiplies\ncorresponding elements in the vectors of the two source SIMD&FP registers, and\nsubtracts the results from the vector elements of the destination SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MLS (vector)",
        "templates": {
          "MLS_ASIMDSAME_ONLY": [
            "MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "MOVI_advsimd": {
        "authored": "Move Immediate (vector). This instruction places an immediate constant into\nevery vector element of the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MOVI",
        "templates": {
          "ADVSIMD": [
            "MOVI  <Vd>.<T>, #<imm8>{, LSL #0}",
            "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}",
            "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}",
            "MOVI  <Vd>.<T>, #<imm8>, MSL #<amount>",
            "MOVI  <Dd>, #<imm>",
            "MOVI  <Vd>.2D, #<imm>"
          ]
        }
      },
      "MOV_DUP_advsimd_elt": {
        "authored": "Move vector element to scalar. This instruction duplicates the specified vector\nelement in the SIMD&FP source register into a scalar, and writes the result to\nthe SIMD&FP destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MOV (scalar)",
        "templates": {
          "DUP_ASISDONE_ONLY": [
            "MOV  <V><d>, <Vn>.<T>[<index>]"
          ]
        }
      },
      "MOV_INS_advsimd_elt": {
        "authored": "Move vector element to another vector element. This instruction copies the\nvector element of the source SIMD&FP register to the specified vector element of\nthe destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP\nregister without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MOV (element)",
        "templates": {
          "INS_ASIMDINS_IV_V": [
            "MOV  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]"
          ]
        }
      },
      "MOV_INS_advsimd_gen": {
        "authored": "Move general-purpose register to a vector element. This instruction copies the\ncontents of the source general-purpose register to the specified vector element\nin the destination SIMD&FP register.\n\nThis instruction can insert data into individual elements within a SIMD&FP\nregister without clearing the remaining bits to zero.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MOV (from general)",
        "templates": {
          "INS_ASIMDINS_IR_R": [
            "MOV  <Vd>.<Ts>[<index>], <R><n>"
          ]
        }
      },
      "MOV_ORR_advsimd_reg": {
        "authored": "Move vector. This instruction copies the vector in the source SIMD&FP register\ninto the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MOV (vector)",
        "templates": {
          "ORR_ASIMDSAME_ONLY": [
            "MOV  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "MOV_UMOV_advsimd": {
        "authored": "Move vector element to general-purpose register. This instruction reads the\nunsigned integer from the source SIMD&FP register, zero-extends it to form a\n32-bit or 64-bit value, and writes the result to the destination general-purpose\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MOV (to general)",
        "templates": {
          "ADVSIMD": [
            "MOV  <Wd>, <Vn>.S[<index>]",
            "MOV  <Xd>, <Vn>.D[<index>]"
          ]
        }
      },
      "MUL_advsimd_elt": {
        "authored": "Multiply (vector, by element). This instruction multiplies the vector elements\nin the first source SIMD&FP register by the specified value in the second source\nSIMD&FP register, places the results in a vector, and writes the vector to the\ndestination SIMD&FP register. All the values in this instruction are unsigned\ninteger values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MUL (by element)",
        "templates": {
          "MUL_ASIMDELEM_R": [
            "MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "MUL_advsimd_vec": {
        "authored": "Multiply (vector). This instruction multiplies corresponding elements in the\nvectors of the two source SIMD&FP registers, places the results in a vector, and\nwrites the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MUL (vector)",
        "templates": {
          "MUL_ASIMDSAME_ONLY": [
            "MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "MVNI_advsimd": {
        "authored": "Move inverted Immediate (vector). This instruction places the inverse of an\nimmediate constant into every vector element of the destination SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MVNI",
        "templates": {
          "ADVSIMD": [
            "MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}",
            "MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}",
            "MVNI  <Vd>.<T>, #<imm8>, MSL #<amount>"
          ]
        }
      },
      "MVN_NOT_advsimd": {
        "authored": "Bitwise NOT (vector). This instruction reads each vector element from the source\nSIMD&FP register, places the inverse of each value into a vector, and writes the\nvector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "MVN",
        "templates": {
          "NOT_ASIMDMISC_R": [
            "MVN  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "NEG_advsimd": {
        "authored": "Negate (vector). This instruction reads each vector element from the source\nSIMD&FP register, negates each value, puts the result into a vector, and writes\nthe vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "NEG (vector)",
        "templates": {
          "NEG_ASIMDMISC_R": [
            "NEG  <Vd>.<T>, <Vn>.<T>"
          ],
          "NEG_ASISDMISC_R": [
            "NEG  <V><d>, <V><n>"
          ]
        }
      },
      "NOT_advsimd": {
        "authored": "Bitwise NOT (vector). This instruction reads each vector element from the source\nSIMD&FP register, places the inverse of each value into a vector, and writes the\nvector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "NOT",
        "templates": {
          "NOT_ASIMDMISC_R": [
            "NOT  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "ORN_advsimd": {
        "authored": "Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT\nbetween the two source SIMD&FP registers, and writes the result to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ORN (vector)",
        "templates": {
          "ORN_ASIMDSAME_ONLY": [
            "ORN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "ORR_advsimd_imm": {
        "authored": "Bitwise inclusive OR (vector, immediate). This instruction reads each vector\nelement from the destination SIMD&FP register, performs a bitwise OR between\neach result and an immediate constant, places the result into a vector, and\nwrites the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ORR (vector, immediate)",
        "templates": {
          "SHIFTED_IMMEDIATE": [
            "ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}",
            "ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}"
          ]
        }
      },
      "ORR_advsimd_reg": {
        "authored": "Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR\nbetween the two source SIMD&FP registers, and writes the result to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ORR (vector, register)",
        "templates": {
          "ORR_ASIMDSAME_ONLY": [
            "ORR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "PMULL_advsimd": {
        "authored": "Polynomial Multiply Long. This instruction multiplies corresponding elements in\nthe lower or upper half of the vectors of the two source SIMD&FP registers,\nplaces the results in a vector, and writes the vector to the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied.\n\nFor information about multiplying polynomials see Polynomial arithmetic over {0,\n1}.\n\nThe PMULL instruction extracts each source vector from the lower half of each\nsource register, while the PMULL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "PMULL, PMULL2",
        "templates": {
          "PMULL_ASIMDDIFF_L": [
            "PMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "PMUL_advsimd": {
        "authored": "Polynomial Multiply. This instruction multiplies corresponding elements in the\nvectors of the two source SIMD&FP registers, places the results in a vector, and\nwrites the vector to the destination SIMD&FP register.\n\nFor information about multiplying polynomials see Polynomial arithmetic over {0,\n1}.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "PMUL",
        "templates": {
          "PMUL_ASIMDSAME_ONLY": [
            "PMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "RADDHN_advsimd": {
        "authored": "Rounding Add returning High Narrow. This instruction adds each vector element in\nthe first source SIMD&FP register to the corresponding vector element in the\nsecond source SIMD&FP register, places the most significant half of the result\ninto a vector, and writes the vector to the lower or upper half of the\ndestination SIMD&FP register.\n\nThe results are rounded. For truncated results, see ADDHN.\n\nThe RADDHN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the RADDHN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "RADDHN, RADDHN2",
        "templates": {
          "RADDHN_ASIMDDIFF_N": [
            "RADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
          ]
        }
      },
      "RAX1_advsimd": {
        "authored": "Rotate and Exclusive OR rotates each 64-bit element of the 128-bit vector in a\nsource SIMD&FP register left by 1, performs a bitwise exclusive OR of the\nresulting 128-bit vector and the vector in another source SIMD&FP register, and\nwrites the result to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.",
        "heading": "RAX1",
        "templates": {
          "RAX1_VVV2_CRYPTOSHA512_3": [
            "RAX1  <Vd>.2D, <Vn>.2D, <Vm>.2D"
          ]
        }
      },
      "RBIT_advsimd": {
        "authored": "Reverse Bit order (vector). This instruction reads each vector element from the\nsource SIMD&FP register, reverses the bits of the element, places the results\ninto a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "RBIT (vector)",
        "templates": {
          "RBIT_ASIMDMISC_R": [
            "RBIT  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "REV16_advsimd": {
        "authored": "Reverse elements in 16-bit halfwords (vector). This instruction reverses the\norder of 8-bit elements in each halfword of the vector in the source SIMD&FP\nregister, places the results into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "REV16 (vector)",
        "templates": {
          "REV16_ASIMDMISC_R": [
            "REV16  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "REV32_advsimd": {
        "authored": "Reverse elements in 32-bit words (vector). This instruction reverses the order\nof 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP\nregister, places the results into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "REV32 (vector)",
        "templates": {
          "REV32_ASIMDMISC_R": [
            "REV32  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "REV64_advsimd": {
        "authored": "Reverse elements in 64-bit doublewords (vector). This instruction reverses the\norder of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in\nthe source SIMD&FP register, places the results into a vector, and writes the\nvector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "REV64",
        "templates": {
          "REV64_ASIMDMISC_R": [
            "REV64  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "RSHRN_advsimd": {
        "authored": "Rounding Shift Right Narrow (immediate). This instruction reads each unsigned\ninteger value from the vector in the source SIMD&FP register, right shifts each\nresult by an immediate value, writes the final result to a vector, and writes\nthe vector to the lower or upper half of the destination SIMD&FP register. The\ndestination vector elements are half as long as the source vector elements. The\nresults are rounded. For truncated results, see SHRN.\n\nThe RSHRN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the RSHRN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "RSHRN, RSHRN2",
        "templates": {
          "RSHRN_ASIMDSHF_N": [
            "RSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ]
        }
      },
      "RSUBHN_advsimd": {
        "authored": "Rounding Subtract returning High Narrow. This instruction subtracts each vector\nelement of the second source SIMD&FP register from the corresponding vector\nelement of the first source SIMD&FP register, places the most significant half\nof the result into a vector, and writes the vector to the lower or upper half of\nthe destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see SUBHN.\n\nThe RSUBHN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the RSUBHN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "RSUBHN, RSUBHN2",
        "templates": {
          "RSUBHN_ASIMDDIFF_N": [
            "RSUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
          ]
        }
      },
      "SABAL_advsimd": {
        "authored": "Signed Absolute difference and Accumulate Long. This instruction subtracts the\nvector elements in the lower or upper half of the second source SIMD&FP register\nfrom the corresponding vector elements of the first source SIMD&FP register, and\naccumulates the absolute values of the results into the vector elements of the\ndestination SIMD&FP register. The destination vector elements are twice as long\nas the source vector elements.\n\nThe SABAL instruction extracts each source vector from the lower half of each\nsource register, while the SABAL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SABAL, SABAL2",
        "templates": {
          "SABAL_ASIMDDIFF_L": [
            "SABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SABA_advsimd": {
        "authored": "Signed Absolute difference and Accumulate. This instruction subtracts the\nelements of the vector of the second source SIMD&FP register from the\ncorresponding elements of the first source SIMD&FP register, and accumulates the\nabsolute values of the results into the elements of the vector of the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SABA",
        "templates": {
          "SABA_ASIMDSAME_ONLY": [
            "SABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SABDL_advsimd": {
        "authored": "Signed Absolute Difference Long. This instruction subtracts the vector elements\nof the second source SIMD&FP register from the corresponding vector elements of\nthe first source SIMD&FP register, places the absolute value of the results into\na vector, and writes the vector to the lower or upper half of the destination\nSIMD&FP register. The destination vector elements are twice as long as the\nsource vector elements.\n\nThe SABDL instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SABDL2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SABDL, SABDL2",
        "templates": {
          "SABDL_ASIMDDIFF_L": [
            "SABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SABD_advsimd": {
        "authored": "Signed Absolute Difference. This instruction subtracts the elements of the\nvector of the second source SIMD&FP register from the corresponding elements of\nthe first source SIMD&FP register, places the the absolute values of the results\ninto a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SABD",
        "templates": {
          "SABD_ASIMDSAME_ONLY": [
            "SABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SADALP_advsimd": {
        "authored": "Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent\nsigned integer values from the vector in the source SIMD&FP register and\naccumulates the results into the vector elements of the destination SIMD&FP\nregister. The destination vector elements are twice as long as the source vector\nelements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SADALP",
        "templates": {
          "SADALP_ASIMDMISC_P": [
            "SADALP  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "SADDLP_advsimd": {
        "authored": "Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer\nvalues from the vector in the source SIMD&FP register, places the result into a\nvector, and writes the vector to the destination SIMD&FP register. The\ndestination vector elements are twice as long as the source vector elements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SADDLP",
        "templates": {
          "SADDLP_ASIMDMISC_P": [
            "SADDLP  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "SADDLV_advsimd": {
        "authored": "Signed Add Long across Vector. This instruction adds every vector element in the\nsource SIMD&FP register together, and writes the scalar result to the\ndestination SIMD&FP register. The destination scalar is twice as long as the\nsource vector elements. All the values in this instruction are signed integer\nvalues.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SADDLV",
        "templates": {
          "SADDLV_ASIMDALL_ONLY": [
            "SADDLV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "SADDL_advsimd": {
        "authored": "Signed Add Long (vector). This instruction adds each vector element in the lower\nor upper half of the first source SIMD&FP register to the corresponding vector\nelement of the second source SIMD&FP register, places the results into a vector,\nand writes the vector to the destination SIMD&FP register.  The destination\nvector elements are twice as long as the source vector elements. All the values\nin this instruction are signed integer values.\n\nThe SADDL instruction extracts each source vector from the lower half of each\nsource register, while the SADDL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SADDL, SADDL2",
        "templates": {
          "SADDL_ASIMDDIFF_L": [
            "SADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SADDW_advsimd": {
        "authored": "Signed Add Wide. This instruction adds vector elements of the first source\nSIMD&FP register to the corresponding vector elements in the lower or upper half\nof the second source SIMD&FP register, places the results in a vector, and\nwrites the vector to the SIMD&FP destination register.\n\nThe SADDW instruction extracts the second source vector from the lower half of\nthe second source register, while the SADDW2 instruction extracts the second\nsource vector from the upper half of the second source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SADDW, SADDW2",
        "templates": {
          "SADDW_ASIMDDIFF_W": [
            "SADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
          ]
        }
      },
      "SCVTF_advsimd_fix": {
        "authored": "Signed fixed-point Convert to Floating-point (vector). This instruction converts\neach element in a vector from fixed-point to floating-point using the rounding\nmode that is specified by the FPCR, and writes the result to the SIMD&FP\ndestination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "SCVTF (vector, fixed-point)",
        "templates": {
          "SCVTF_ASIMDSHF_C": [
            "SCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>"
          ],
          "SCVTF_ASISDSHF_C": [
            "SCVTF  <V><d>, <V><n>, #<fbits>"
          ]
        }
      },
      "SCVTF_advsimd_int": {
        "authored": "Signed integer Convert to Floating-point (vector). This instruction converts\neach element in a vector from signed integer to floating-point using the\nrounding mode that is specified by the FPCR, and writes the result to the\nSIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "SCVTF (vector, integer)",
        "templates": {
          "SCVTF_ASIMDMISCFP16_R": [
            "SCVTF  <Vd>.<T>, <Vn>.<T>"
          ],
          "SCVTF_ASIMDMISC_R": [
            "SCVTF  <Vd>.<T>, <Vn>.<T>"
          ],
          "SCVTF_ASISDMISCFP16_R": [
            "SCVTF  <Hd>, <Hn>"
          ],
          "SCVTF_ASISDMISC_R": [
            "SCVTF  <V><d>, <V><n>"
          ]
        }
      },
      "SCVTF_float_fix": {
        "authored": "Signed fixed-point Convert to Floating-point (scalar). This instruction converts\nthe signed value in the 32-bit or 64-bit general-purpose source register to a\nfloating-point value using the rounding mode that is specified by the FPCR, and\nwrites the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "SCVTF (scalar, fixed-point)",
        "templates": {
          "FLOAT": [
            "SCVTF  <Hd>, <Wn>, #<fbits>",
            "SCVTF  <Sd>, <Wn>, #<fbits>",
            "SCVTF  <Dd>, <Wn>, #<fbits>",
            "SCVTF  <Hd>, <Xn>, #<fbits>",
            "SCVTF  <Sd>, <Xn>, #<fbits>",
            "SCVTF  <Dd>, <Xn>, #<fbits>"
          ]
        }
      },
      "SCVTF_float_int": {
        "authored": "Signed integer Convert to Floating-point (scalar). This instruction converts the\nsigned integer value in the general-purpose source register to a floating-point\nvalue using the rounding mode that is specified by the FPCR, and writes the\nresult to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SCVTF (scalar, integer)",
        "templates": {
          "FLOAT": [
            "SCVTF  <Hd>, <Wn>",
            "SCVTF  <Sd>, <Wn>",
            "SCVTF  <Dd>, <Wn>",
            "SCVTF  <Hd>, <Xn>",
            "SCVTF  <Sd>, <Xn>",
            "SCVTF  <Dd>, <Xn>"
          ]
        }
      },
      "SDOT_advsimd_elt": {
        "authored": "Dot Product signed arithmetic (vector, by element). This instruction performs\nthe dot product of the four 8-bit elements in each 32-bit element of the first\nsource register with the four 8-bit elements of an indexed 32-bit element in the\nsecond source register, accumulating the result into the corresponding 32-bit\nelement of the destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.",
        "heading": "SDOT (by element)",
        "templates": {
          "SDOT_ASIMDELEM_D": [
            "SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
          ]
        }
      },
      "SDOT_advsimd_vec": {
        "authored": "Dot Product signed arithmetic (vector). This instruction performs the dot\nproduct of the four signed 8-bit elements in each 32-bit element of the first\nsource register with the four signed 8-bit elements of the corresponding 32-bit\nelement in the second source register, accumulating the result into the\ncorresponding 32-bit element of the destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.",
        "heading": "SDOT (vector)",
        "templates": {
          "SDOT_ASIMDSAME2_D": [
            "SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SHA1C_advsimd": {
        "authored": "SHA1 hash update (choose).",
        "heading": "SHA1C",
        "templates": {
          "SHA1C_QSV_CRYPTOSHA3": [
            "SHA1C  <Qd>, <Sn>, <Vm>.4S"
          ]
        }
      },
      "SHA1H_advsimd": {
        "authored": "SHA1 fixed rotate.",
        "heading": "SHA1H",
        "templates": {
          "SHA1H_SS_CRYPTOSHA2": [
            "SHA1H  <Sd>, <Sn>"
          ]
        }
      },
      "SHA1M_advsimd": {
        "authored": "SHA1 hash update (majority).",
        "heading": "SHA1M",
        "templates": {
          "SHA1M_QSV_CRYPTOSHA3": [
            "SHA1M  <Qd>, <Sn>, <Vm>.4S"
          ]
        }
      },
      "SHA1P_advsimd": {
        "authored": "SHA1 hash update (parity).",
        "heading": "SHA1P",
        "templates": {
          "SHA1P_QSV_CRYPTOSHA3": [
            "SHA1P  <Qd>, <Sn>, <Vm>.4S"
          ]
        }
      },
      "SHA1SU0_advsimd": {
        "authored": "SHA1 schedule update 0.",
        "heading": "SHA1SU0",
        "templates": {
          "SHA1SU0_VVV_CRYPTOSHA3": [
            "SHA1SU0  <Vd>.4S, <Vn>.4S, <Vm>.4S"
          ]
        }
      },
      "SHA1SU1_advsimd": {
        "authored": "SHA1 schedule update 1.",
        "heading": "SHA1SU1",
        "templates": {
          "SHA1SU1_VV_CRYPTOSHA2": [
            "SHA1SU1  <Vd>.4S, <Vn>.4S"
          ]
        }
      },
      "SHA256H2_advsimd": {
        "authored": "SHA256 hash update (part 2).",
        "heading": "SHA256H2",
        "templates": {
          "SHA256H2_QQV_CRYPTOSHA3": [
            "SHA256H2  <Qd>, <Qn>, <Vm>.4S"
          ]
        }
      },
      "SHA256H_advsimd": {
        "authored": "SHA256 hash update (part 1).",
        "heading": "SHA256H",
        "templates": {
          "SHA256H_QQV_CRYPTOSHA3": [
            "SHA256H  <Qd>, <Qn>, <Vm>.4S"
          ]
        }
      },
      "SHA256SU0_advsimd": {
        "authored": "SHA256 schedule update 0.",
        "heading": "SHA256SU0",
        "templates": {
          "SHA256SU0_VV_CRYPTOSHA2": [
            "SHA256SU0  <Vd>.4S, <Vn>.4S"
          ]
        }
      },
      "SHA256SU1_advsimd": {
        "authored": "SHA256 schedule update 1.",
        "heading": "SHA256SU1",
        "templates": {
          "SHA256SU1_VVV_CRYPTOSHA3": [
            "SHA256SU1  <Vd>.4S, <Vn>.4S, <Vm>.4S"
          ]
        }
      },
      "SHA512H2_advsimd": {
        "authored": "SHA512 Hash update part 2 takes the values from the three 128-bit source SIMD&FP\nregisters and produces a 128-bit output value that combines the sigma0 and\nmajority functions of two iterations of the SHA512 computation. It returns this\nvalue to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.",
        "heading": "SHA512H2",
        "templates": {
          "SHA512H2_QQV_CRYPTOSHA512_3": [
            "SHA512H2  <Qd>, <Qn>, <Vm>.2D"
          ]
        }
      },
      "SHA512H_advsimd": {
        "authored": "SHA512 Hash update part 1 takes the values from the three 128-bit source SIMD&FP\nregisters and produces a 128-bit output value that combines the sigma1 and chi\nfunctions of two iterations of the SHA512 computation. It returns this value to\nthe destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.",
        "heading": "SHA512H",
        "templates": {
          "SHA512H_QQV_CRYPTOSHA512_3": [
            "SHA512H  <Qd>, <Qn>, <Vm>.2D"
          ]
        }
      },
      "SHA512SU0_advsimd": {
        "authored": "SHA512 Schedule Update 0 takes the values from the two 128-bit source SIMD&FP\nregisters and produces a 128-bit output value that combines the gamma0 functions\nof two iterations of the SHA512 schedule update that are performed after the\nfirst 16 iterations within a block. It returns this value to the destination\nSIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.",
        "heading": "SHA512SU0",
        "templates": {
          "SHA512SU0_VV2_CRYPTOSHA512_2": [
            "SHA512SU0  <Vd>.2D, <Vn>.2D"
          ]
        }
      },
      "SHA512SU1_advsimd": {
        "authored": "SHA512 Schedule Update 1 takes the values from the three source SIMD&FP\nregisters and produces a 128-bit output value that combines the gamma1 functions\nof two iterations of the SHA512 schedule update that are performed after the\nfirst 16 iterations within a block. It returns this value to the destination\nSIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.",
        "heading": "SHA512SU1",
        "templates": {
          "SHA512SU1_VVV2_CRYPTOSHA512_3": [
            "SHA512SU1  <Vd>.2D, <Vn>.2D, <Vm>.2D"
          ]
        }
      },
      "SHADD_advsimd": {
        "authored": "Signed Halving Add. This instruction adds corresponding signed integer values\nfrom the two source SIMD&FP registers, shifts each result right one bit, places\nthe results into a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThe results are truncated. For rounded results, see SRHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SHADD",
        "templates": {
          "SHADD_ASIMDSAME_ONLY": [
            "SHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SHLL_advsimd": {
        "authored": "Shift Left Long (by element size). This instruction reads each vector element in\nthe lower or upper half of the source SIMD&FP register, left shifts each result\nby the element size, writes the final result to a vector, and writes the vector\nto the destination SIMD&FP register. The destination vector elements are twice\nas long as the source vector elements.\n\nThe SHLL instruction extracts vector elements from the lower half of the source\nregister, while the SHLL2 instruction extracts vector elements from the upper\nhalf of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SHLL, SHLL2",
        "templates": {
          "SHLL_ASIMDMISC_S": [
            "SHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"
          ]
        }
      },
      "SHL_advsimd": {
        "authored": "Shift Left (immediate). This instruction reads each value from a vector, left\nshifts each result by an immediate value, writes the final result to a vector,\nand writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SHL",
        "templates": {
          "SHL_ASIMDSHF_R": [
            "SHL  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SHL_ASISDSHF_R": [
            "SHL  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SHRN_advsimd": {
        "authored": "Shift Right Narrow (immediate). This instruction reads each unsigned integer\nvalue from the source SIMD&FP register, right shifts each result by an immediate\nvalue, puts the final result into a vector, and writes the vector to the lower\nor upper half of the destination SIMD&FP register. The destination vector\nelements are half as long as the source vector elements. The results are\ntruncated. For rounded results, see RSHRN.\n\nThe RSHRN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the RSHRN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SHRN, SHRN2",
        "templates": {
          "SHRN_ASIMDSHF_N": [
            "SHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ]
        }
      },
      "SHSUB_advsimd": {
        "authored": "Signed Halving Subtract. This instruction subtracts the elements in the vector\nin the second source SIMD&FP register from the corresponding elements in the\nvector in the first source SIMD&FP register, shifts each result right one bit,\nplaces each result into elements of a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SHSUB",
        "templates": {
          "SHSUB_ASIMDSAME_ONLY": [
            "SHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SLI_advsimd": {
        "authored": "Shift Left and Insert (immediate). This instruction reads each vector element in\nthe source SIMD&FP register, left shifts each vector element by an immediate\nvalue, and inserts the result into the corresponding vector element in the\ndestination SIMD&FP register such that the new zero bits created by the shift\nare not inserted but retain their existing value. Bits shifted out of the left\nof each vector element in the source register are lost.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SLI",
        "templates": {
          "SLI_ASIMDSHF_R": [
            "SLI  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SLI_ASISDSHF_R": [
            "SLI  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SM3PARTW1_advsimd": {
        "authored": "SM3PARTW1 takes three 128-bit vectors from the three source SIMD&FP registers\nand returns a 128-bit result in the destination SIMD&FP register. The result is\nobtained by a three-way exclusive OR of the elements within the input vectors\nwith some fixed rotations, see the Operation pseudocode for more information.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.",
        "heading": "SM3PARTW1",
        "templates": {
          "SM3PARTW1_VVV4_CRYPTOSHA512_3": [
            "SM3PARTW1  <Vd>.4S, <Vn>.4S, <Vm>.4S"
          ]
        }
      },
      "SM3PARTW2_advsimd": {
        "authored": "SM3PARTW2 takes three 128-bit vectors from three source SIMD&FP registers and\nreturns a 128-bit result in the destination SIMD&FP register. The result is\nobtained by a three-way exclusive OR of the elements within the input vectors\nwith some fixed rotations, see the Operation pseudocode for more information.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.",
        "heading": "SM3PARTW2",
        "templates": {
          "SM3PARTW2_VVV4_CRYPTOSHA512_3": [
            "SM3PARTW2  <Vd>.4S, <Vn>.4S, <Vm>.4S"
          ]
        }
      },
      "SM3SS1_advsimd": {
        "authored": "SM3SS1 rotates the top 32 bits of the 128-bit vector in the first source SIMD&FP\nregister by 12, and adds that 32-bit value to the two other 32-bit values held\nin the top 32 bits of each of the 128-bit vectors in the second and third source\nSIMD&FP registers, rotating this result left by 7 and writing the final result\ninto the top 32 bits of the vector in the destination SIMD&FP register, with the\nbottom 96 bits of the vector being written to 0.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.",
        "heading": "SM3SS1",
        "templates": {
          "SM3SS1_VVV4_CRYPTO4": [
            "SM3SS1  <Vd>.4S, <Vn>.4S, <Vm>.4S, <Va>.4S"
          ]
        }
      },
      "SM3TT1A_advsimd": {
        "authored": "SM3TT1A takes three 128-bit vectors from three source SIMD&FP registers and a\n2-bit immediate index value, and returns a 128-bit result in the destination\nSIMD&FP register.  It performs a three-way exclusive OR of the three 32-bit\nfields held in the upper three elements of the first source vector, and adds the\nresulting 32-bit value and the following three other 32-bit values:\n  - The bottom 32-bit element of the first source vector, Vd, that was used for\nthe three-way exclusive OR.\n  - The result of the exclusive OR of the top 32-bit element of the second\nsource vector, Vn, with a rotation left by 12 of the top 32-bit element of the\nfirst source vector.\n  - A 32-bit element indexed out of the third source vector, Vm.\n\nThe result of this addition is returned as the top element of the result. The\nother elements of the result are taken from elements of the first source vector,\nwith the element returned in bits<63:32> being rotated left by 9.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.",
        "heading": "SM3TT1A",
        "templates": {
          "SM3TT1A_VVV4_CRYPTO3_IMM2": [
            "SM3TT1A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
          ]
        }
      },
      "SM3TT1B_advsimd": {
        "authored": "SM3TT1B takes three 128-bit vectors from three source SIMD&FP registers and a\n2-bit immediate index value, and returns a 128-bit result in the destination\nSIMD&FP register. It performs a 32-bit majority function between the three\n32-bit fields held in the upper three elements of the first source vector, and\nadds the resulting 32-bit value and the following three other 32-bit values:\n  - The bottom 32-bit element of the first source vector, Vd, that was used for\nthe 32-bit majority function.\n  - The result of the exclusive OR of the top 32-bit element of the second\nsource vector, Vn, with a rotation left by 12 of the top 32-bit element of the\nfirst source vector.\n  - A 32-bit element indexed out of the third source vector, Vm.\n\nThe result of this addition is returned as the top element of the result. The\nother elements of the result are taken from elements of the first source vector,\nwith the element returned in bits<63:32> being rotated left by 9.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.",
        "heading": "SM3TT1B",
        "templates": {
          "SM3TT1B_VVV4_CRYPTO3_IMM2": [
            "SM3TT1B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
          ]
        }
      },
      "SM3TT2A_advsimd": {
        "authored": "SM3TT2A takes three 128-bit vectors from three source SIMD&FP register and a\n2-bit immediate index value, and returns a 128-bit result in the destination\nSIMD&FP register. It performs a three-way exclusive OR of the three 32-bit\nfields held in the upper three elements of the first source vector, and adds the\nresulting 32-bit value and the following three other 32-bit values:\n  - The bottom 32-bit element of the first source vector, Vd, that was used for\nthe three-way exclusive OR.\n  - The 32-bit element held in the top 32 bits of the second source vector, Vn.\n  - A 32-bit element indexed out of the third source vector, Vm.\n\nA three-way exclusive OR is performed of the result of this addition, the result\nof the addition rotated left by 9, and the result of the addition rotated left\nby 17. The result of this exclusive OR is returned as the top element of the\nreturned result. The other elements of this result are taken from elements of\nthe first source vector, with the element returned in bits<63:32> being rotated\nleft by 19.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.",
        "heading": "SM3TT2A",
        "templates": {
          "SM3TT2A_VVV4_CRYPTO3_IMM2": [
            "SM3TT2A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
          ]
        }
      },
      "SM3TT2B_advsimd": {
        "authored": "SM3TT2B takes three 128-bit vectors from three source SIMD&FP registers, and a\n2-bit immediate index value, and returns a 128-bit result in the destination\nSIMD&FP register. It performs a 32-bit majority function between the three\n32-bit fields held in the upper three elements of the first source vector, and\nadds the resulting 32-bit value and the following three other 32-bit values:\n  - The bottom 32-bit element of the first source vector, Vd, that was used for\nthe 32-bit majority function.\n  - The 32-bit element held in the top 32 bits of the second source vector, Vn.\n  - A 32-bit element indexed out of the third source vector, Vm.\n\nA three-way exclusive OR is performed of the result of this addition, the result\nof the addition rotated left by 9, and the result of the addition rotated left\nby 17. The result of this exclusive OR is returned as the top element of the\nreturned result. The other elements of this result are taken from elements of\nthe first source vector, with the element returned in bits<63:32> being rotated\nleft by 19.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.",
        "heading": "SM3TT2B",
        "templates": {
          "SM3TT2B_VVV_CRYPTO3_IMM2": [
            "SM3TT2B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
          ]
        }
      },
      "SM4EKEY_advsimd": {
        "authored": "SM4 Key takes an input as a 128-bit vector from the first source SIMD&FP\nregister and a 128-bit constant from the second SIMD&FP register. It derives\nfour iterations of the output key, in accordance with the SM4 standard,\nreturning the 128-bit result to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.",
        "heading": "SM4EKEY",
        "templates": {
          "SM4EKEY_VVV4_CRYPTOSHA512_3": [
            "SM4EKEY  <Vd>.4S, <Vn>.4S, <Vm>.4S"
          ]
        }
      },
      "SM4E_advsimd": {
        "authored": "SM4 Encode takes input data as a 128-bit vector from the first source SIMD&FP\nregister, and four iterations of the round key held as the elements of the\n128-bit vector in the second source SIMD&FP register. It encrypts the data by\nfour rounds, in accordance with the SM4 standard, returning the 128-bit result\nto the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SM is implemented.",
        "heading": "SM4E",
        "templates": {
          "SM4E_VV4_CRYPTOSHA512_2": [
            "SM4E  <Vd>.4S, <Vn>.4S"
          ]
        }
      },
      "SMAXP_advsimd": {
        "authored": "Signed Maximum Pairwise. This instruction creates a vector by concatenating the\nvector elements of the first source SIMD&FP register after the vector elements\nof the second source SIMD&FP register, reads each pair of adjacent vector\nelements in the two source SIMD&FP registers, writes the largest of each pair of\nsigned integer values into a vector, and writes the vector to the destination\nSIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMAXP",
        "templates": {
          "SMAXP_ASIMDSAME_ONLY": [
            "SMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SMAXV_advsimd": {
        "authored": "Signed Maximum across Vector. This instruction compares all the vector elements\nin the source SIMD&FP register, and writes the largest of the values as a scalar\nto the destination SIMD&FP register. All the values in this instruction are\nsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMAXV",
        "templates": {
          "SMAXV_ASIMDALL_ONLY": [
            "SMAXV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "SMAX_advsimd": {
        "authored": "Signed Maximum (vector). This instruction compares corresponding elements in the\nvectors in the two source SIMD&FP registers, places the larger of each pair of\nsigned integer values into a vector, and writes the vector to the destination\nSIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMAX",
        "templates": {
          "SMAX_ASIMDSAME_ONLY": [
            "SMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SMINP_advsimd": {
        "authored": "Signed Minimum Pairwise. This instruction creates a vector by concatenating the\nvector elements of the first source SIMD&FP register after the vector elements\nof the second source SIMD&FP register, reads each pair of adjacent vector\nelements in the two source SIMD&FP registers, writes the smallest of each pair\nof signed integer values into a vector, and writes the vector to the destination\nSIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMINP",
        "templates": {
          "SMINP_ASIMDSAME_ONLY": [
            "SMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SMINV_advsimd": {
        "authored": "Signed Minimum across Vector. This instruction compares all the vector elements\nin the source SIMD&FP register, and writes the smallest of the values as a\nscalar to the destination SIMD&FP register. All the values in this instruction\nare signed integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMINV",
        "templates": {
          "SMINV_ASIMDALL_ONLY": [
            "SMINV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "SMIN_advsimd": {
        "authored": "Signed Minimum (vector). This instruction compares corresponding elements in the\nvectors in the two source SIMD&FP registers, places the smaller of each of the\ntwo signed integer values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMIN",
        "templates": {
          "SMIN_ASIMDSAME_ONLY": [
            "SMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SMLAL_advsimd_elt": {
        "authored": "Signed Multiply-Add Long (vector, by element). This instruction multiplies each\nvector element in the lower or upper half of the first source SIMD&FP register\nby the specified vector element in the second source SIMD&FP register, and\naccumulates the results with the vector elements of the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied. All the values in this instruction are signed integer values.\n\nThe SMLAL instruction extracts vector elements from the lower half of the first\nsource register, while the SMLAL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMLAL, SMLAL2 (by element)",
        "templates": {
          "SMLAL_ASIMDELEM_L": [
            "SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SMLAL_advsimd_vec": {
        "authored": "Signed Multiply-Add Long (vector). This instruction multiplies corresponding\nsigned integer values in the lower or upper half of the vectors of the two\nsource SIMD&FP registers, and accumulates the results with the vector elements\nof the destination SIMD&FP register. The destination vector elements are twice\nas long as the elements that are multiplied.\n\nThe SMLAL instruction extracts each source vector from the lower half of each\nsource register, while the SMLAL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMLAL, SMLAL2 (vector)",
        "templates": {
          "SMLAL_ASIMDDIFF_L": [
            "SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SMLSL_advsimd_elt": {
        "authored": "Signed Multiply-Subtract Long (vector, by element). This instruction multiplies\neach vector element in the lower or upper half of the first source SIMD&FP\nregister by the specified vector element of the second source SIMD&FP register\nand subtracts the results from the vector elements of the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied.\n\nThe SMLSL instruction extracts vector elements from the lower half of the first\nsource register, while the SMLSL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMLSL, SMLSL2 (by element)",
        "templates": {
          "SMLSL_ASIMDELEM_L": [
            "SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SMLSL_advsimd_vec": {
        "authored": "Signed Multiply-Subtract Long (vector). This instruction multiplies\ncorresponding signed integer values in the lower or upper half of the vectors of\nthe two source SIMD&FP registers, and subtracts the results from the vector\nelements of the destination SIMD&FP register. The destination vector elements\nare twice as long as the elements that are multiplied.\n\nThe SMLSL instruction extracts each source vector from the lower half of each\nsource register, while the SMLSL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMLSL, SMLSL2 (vector)",
        "templates": {
          "SMLSL_ASIMDDIFF_L": [
            "SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SMMLA_advsimd_vec": {
        "authored": "Signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the\n2x8 matrix of signed 8-bit integer values in the first source vector by the 8x2\nmatrix of signed 8-bit integer values in the second source vector. The resulting\n2x2 32-bit integer matrix product is destructively added to the 32-bit integer\nmatrix accumulator in the destination vector. This is equivalent to performing\nan 8-way dot product per destination element.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is\nmandatory for implementations that include Advanced SIMD to support it.\nID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.",
        "heading": "SMMLA (vector)",
        "templates": {
          "SMMLA_ASIMDSAME2_G": [
            "SMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B"
          ]
        }
      },
      "SMOV_advsimd": {
        "authored": "Signed Move vector element to general-purpose register. This instruction reads\nthe signed integer from the source SIMD&FP register, sign-extends it to form a\n32-bit or 64-bit value, and writes the result to destination general-purpose\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMOV",
        "templates": {
          "ADVSIMD": [
            "SMOV  <Wd>, <Vn>.<Ts>[<index>]",
            "SMOV  <Xd>, <Vn>.<Ts>[<index>]"
          ]
        }
      },
      "SMULL_advsimd_elt": {
        "authored": "Signed Multiply Long (vector, by element). This instruction multiplies each\nvector element in the lower or upper half of the first source SIMD&FP register\nby the specified vector element of the second source SIMD&FP register, places\nthe result in a vector, and writes the vector to the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied.\n\nThe SMULL instruction extracts vector elements from the lower half of the first\nsource register, while the SMULL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMULL, SMULL2 (by element)",
        "templates": {
          "SMULL_ASIMDELEM_L": [
            "SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SMULL_advsimd_vec": {
        "authored": "Signed Multiply Long (vector). This instruction multiplies corresponding signed\ninteger values in the lower or upper half of the vectors of the two source\nSIMD&FP registers, places the results in a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThe destination vector elements are twice as long as the elements that are\nmultiplied.\n\nThe SMULL instruction extracts each source vector from the lower half of each\nsource register, while the SMULL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SMULL, SMULL2 (vector)",
        "templates": {
          "SMULL_ASIMDDIFF_L": [
            "SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SQABS_advsimd": {
        "authored": "Signed saturating Absolute value. This instruction reads each vector element\nfrom the source SIMD&FP register, puts the absolute value of the result into a\nvector, and writes the vector to the destination SIMD&FP register. All the\nvalues in this instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQABS",
        "templates": {
          "SQABS_ASIMDMISC_R": [
            "SQABS  <Vd>.<T>, <Vn>.<T>"
          ],
          "SQABS_ASISDMISC_R": [
            "SQABS  <V><d>, <V><n>"
          ]
        }
      },
      "SQADD_advsimd": {
        "authored": "Signed saturating Add. This instruction adds the values of corresponding\nelements of the two source SIMD&FP registers, places the results into a vector,\nand writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQADD",
        "templates": {
          "SQADD_ASIMDSAME_ONLY": [
            "SQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SQADD_ASISDSAME_ONLY": [
            "SQADD  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQDMLAL_advsimd_elt": {
        "authored": "Signed saturating Doubling Multiply-Add Long (by element). This instruction\nmultiplies each vector element in the lower or upper half of the first source\nSIMD&FP register by the specified vector element of the second source SIMD&FP\nregister, doubles the results, and accumulates the final results with the vector\nelements of the destination SIMD&FP register. The destination vector elements\nare twice as long as the elements that are multiplied.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLAL instruction extracts vector elements from the lower half of the\nfirst source register, while the SQDMLAL2 instruction extracts vector elements\nfrom the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMLAL, SQDMLAL2 (by element)",
        "templates": {
          "SQDMLAL_ASIMDELEM_L": [
            "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ],
          "SQDMLAL_ASISDELEM_L": [
            "SQDMLAL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQDMLAL_advsimd_vec": {
        "authored": "Signed saturating Doubling Multiply-Add Long. This instruction multiplies\ncorresponding signed integer values in the lower or upper half of the vectors of\nthe two source SIMD&FP registers, doubles the results, and accumulates the final\nresults with the vector elements of the destination SIMD&FP register. The\ndestination vector elements are twice as long as the elements that are\nmultiplied.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLAL instruction extracts each source vector from the lower half of each\nsource register, while the SQDMLAL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMLAL, SQDMLAL2 (vector)",
        "templates": {
          "SQDMLAL_ASIMDDIFF_L": [
            "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ],
          "SQDMLAL_ASISDDIFF_ONLY": [
            "SQDMLAL  <Va><d>, <Vb><n>, <Vb><m>"
          ]
        }
      },
      "SQDMLSL_advsimd_elt": {
        "authored": "Signed saturating Doubling Multiply-Subtract Long (by element). This instruction\nmultiplies each vector element in the lower or upper half of the first source\nSIMD&FP register by the specified vector element of the second source SIMD&FP\nregister, doubles the results, and subtracts the final results from the vector\nelements of the destination SIMD&FP register. The destination vector elements\nare twice as long as the elements that are multiplied. All the values in this\ninstruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLSL instruction extracts vector elements from the lower half of the\nfirst source register, while the SQDMLSL2 instruction extracts vector elements\nfrom the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMLSL, SQDMLSL2 (by element)",
        "templates": {
          "SQDMLSL_ASIMDELEM_L": [
            "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ],
          "SQDMLSL_ASISDELEM_L": [
            "SQDMLSL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQDMLSL_advsimd_vec": {
        "authored": "Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies\ncorresponding signed integer values in the lower or upper half of the vectors of\nthe two source SIMD&FP registers, doubles the results, and subtracts the final\nresults from the vector elements of the destination SIMD&FP register. The\ndestination vector elements are twice as long as the elements that are\nmultiplied.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMLSL instruction extracts each source vector from the lower half of each\nsource register, while the SQDMLSL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMLSL, SQDMLSL2 (vector)",
        "templates": {
          "SQDMLSL_ASIMDDIFF_L": [
            "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ],
          "SQDMLSL_ASISDDIFF_ONLY": [
            "SQDMLSL  <Va><d>, <Vb><n>, <Vb><m>"
          ]
        }
      },
      "SQDMULH_advsimd_elt": {
        "authored": "Signed saturating Doubling Multiply returning High half (by element). This\ninstruction multiplies each vector element in the first source SIMD&FP register\nby the specified vector element of the second source SIMD&FP register, doubles\nthe results, places the most significant half of the final results into a\nvector, and writes the vector to the destination SIMD&FP register.\n\nThe results are truncated. For rounded results, see SQRDMULH.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMULH (by element)",
        "templates": {
          "SQDMULH_ASIMDELEM_R": [
            "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "SQDMULH_ASISDELEM_R": [
            "SQDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQDMULH_advsimd_vec": {
        "authored": "Signed saturating Doubling Multiply returning High half. This instruction\nmultiplies the values of corresponding elements of the two source SIMD&FP\nregisters, doubles the results, places the most significant half of the final\nresults into a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThe results are truncated. For rounded results, see SQRDMULH.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMULH (vector)",
        "templates": {
          "SQDMULH_ASIMDSAME_ONLY": [
            "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SQDMULH_ASISDSAME_ONLY": [
            "SQDMULH  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQDMULL_advsimd_elt": {
        "authored": "Signed saturating Doubling Multiply Long (by element). This instruction\nmultiplies each vector element in the lower or upper half of the first source\nSIMD&FP register by the specified vector element of the second source SIMD&FP\nregister, doubles the results, places the final results in a vector, and writes\nthe vector to the destination SIMD&FP register. All the values in this\ninstruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMULL instruction extracts the first source vector from the lower half of\nthe first source register, while the SQDMULL2 instruction extracts the first\nsource vector from the upper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMULL, SQDMULL2 (by element)",
        "templates": {
          "SQDMULL_ASIMDELEM_L": [
            "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ],
          "SQDMULL_ASISDELEM_L": [
            "SQDMULL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQDMULL_advsimd_vec": {
        "authored": "Signed saturating Doubling Multiply Long. This instruction multiplies\ncorresponding vector elements in the lower or upper half of the two source\nSIMD&FP registers, doubles the results, places the final results in a vector,\nand writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQDMULL instruction extracts each source vector from the lower half of each\nsource register, while the SQDMULL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQDMULL, SQDMULL2 (vector)",
        "templates": {
          "SQDMULL_ASIMDDIFF_L": [
            "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ],
          "SQDMULL_ASISDDIFF_ONLY": [
            "SQDMULL  <Va><d>, <Vb><n>, <Vb><m>"
          ]
        }
      },
      "SQNEG_advsimd": {
        "authored": "Signed saturating Negate. This instruction reads each vector element from the\nsource SIMD&FP register, negates each value, places the result into a vector,\nand writes the vector to the destination SIMD&FP register. All the values in\nthis instruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQNEG",
        "templates": {
          "SQNEG_ASIMDMISC_R": [
            "SQNEG  <Vd>.<T>, <Vn>.<T>"
          ],
          "SQNEG_ASISDMISC_R": [
            "SQNEG  <V><d>, <V><n>"
          ]
        }
      },
      "SQRDMLAH_advsimd_elt": {
        "authored": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by\nelement). This instruction multiplies the vector elements of the first source\nSIMD&FP register with the value of a vector element of the second source SIMD&FP\nregister without saturating the multiply results, doubles the results, and\naccumulates the most significant half of the final results with the vector\nelements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRDMLAH (by element)",
        "templates": {
          "SQRDMLAH_ASIMDELEM_R": [
            "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "SQRDMLAH_ASISDELEM_R": [
            "SQRDMLAH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQRDMLAH_advsimd_vec": {
        "authored": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half\n(vector). This instruction multiplies the vector elements of the first source\nSIMD&FP register with the corresponding vector elements of the second source\nSIMD&FP register without saturating the multiply results, doubles the results,\nand accumulates the most significant half of the final results with the vector\nelements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRDMLAH (vector)",
        "templates": {
          "SQRDMLAH_ASIMDSAME2_ONLY": [
            "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SQRDMLAH_ASISDSAME2_ONLY": [
            "SQRDMLAH  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQRDMLSH_advsimd_elt": {
        "authored": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by\nelement). This instruction multiplies the vector elements of the first source\nSIMD&FP register with the value of a vector element of the second source SIMD&FP\nregister without saturating the multiply results, doubles the results, and\nsubtracts the most significant half of the final results from the vector\nelements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRDMLSH (by element)",
        "templates": {
          "SQRDMLSH_ASIMDELEM_R": [
            "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "SQRDMLSH_ASISDELEM_R": [
            "SQRDMLSH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQRDMLSH_advsimd_vec": {
        "authored": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half\n(vector). This instruction multiplies the vector elements of the first source\nSIMD&FP register with the corresponding vector elements of the second source\nSIMD&FP register without saturating the multiply results, doubles the results,\nand subtracts the most significant half of the final results from the vector\nelements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSR.QC, is set if saturation occurs.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRDMLSH (vector)",
        "templates": {
          "SQRDMLSH_ASIMDSAME2_ONLY": [
            "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SQRDMLSH_ASISDSAME2_ONLY": [
            "SQRDMLSH  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQRDMULH_advsimd_elt": {
        "authored": "Signed saturating Rounding Doubling Multiply returning High half (by element).\nThis instruction multiplies each vector element in the first source SIMD&FP\nregister by the specified vector element of the second source SIMD&FP register,\ndoubles the results, places the most significant half of the final results into\na vector, and writes the vector to the destination SIMD&FP register.\n\nThe results are rounded. For truncated results, see SQDMULH.\n\nIf any of the results overflows, they are saturated. If saturation occurs, the\ncumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRDMULH (by element)",
        "templates": {
          "SQRDMULH_ASIMDELEM_R": [
            "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          ],
          "SQRDMULH_ASISDELEM_R": [
            "SQRDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "SQRDMULH_advsimd_vec": {
        "authored": "Signed saturating Rounding Doubling Multiply returning High half. This\ninstruction multiplies the values of corresponding elements of the two source\nSIMD&FP registers, doubles the results, places the most significant half of the\nfinal results into a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThe results are rounded. For truncated results, see SQDMULH.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRDMULH (vector)",
        "templates": {
          "SQRDMULH_ASIMDSAME_ONLY": [
            "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SQRDMULH_ASISDSAME_ONLY": [
            "SQRDMULH  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQRSHL_advsimd": {
        "authored": "Signed saturating Rounding Shift Left (register). This instruction takes each\nvector element in the first source SIMD&FP register, shifts it by a value from\nthe least significant byte of the corresponding vector element of the second\nsource SIMD&FP register, places the results into a vector, and writes the vector\nto the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is\na right shift. The results are rounded. For truncated results, see SQSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRSHL",
        "templates": {
          "SQRSHL_ASIMDSAME_ONLY": [
            "SQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SQRSHL_ASISDSAME_ONLY": [
            "SQRSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQRSHRN_advsimd": {
        "authored": "Signed saturating Rounded Shift Right Narrow (immediate). This instruction reads\neach vector element in the source SIMD&FP register, right shifts each result by\nan immediate value, saturates each shifted result to a value that is half the\noriginal width, puts the final result into a vector, and writes the vector to\nthe lower or upper half of the destination SIMD&FP register. All the values in\nthis instruction are signed integer values. The destination vector elements are\nhalf as long as the source vector elements. The results are rounded. For\ntruncated results, see SQSHRN.\n\nThe SQRSHRN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SQRSHRN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRSHRN, SQRSHRN2",
        "templates": {
          "SQRSHRN_ASIMDSHF_N": [
            "SQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ],
          "SQRSHRN_ASISDSHF_N": [
            "SQRSHRN  <Vb><d>, <Va><n>, #<shift>"
          ]
        }
      },
      "SQRSHRUN_advsimd": {
        "authored": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This\ninstruction reads each signed integer value in the vector of the source SIMD&FP\nregister, right shifts each value by an immediate value, saturates the result to\nan unsigned integer value that is half the original width, places the final\nresult into a vector, and writes the vector to the destination SIMD&FP register.\nThe results are rounded. For truncated results, see SQSHRUN.\n\nThe SQRSHRUN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SQRSHRUN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQRSHRUN, SQRSHRUN2",
        "templates": {
          "SQRSHRUN_ASIMDSHF_N": [
            "SQRSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ],
          "SQRSHRUN_ASISDSHF_N": [
            "SQRSHRUN  <Vb><d>, <Va><n>, #<shift>"
          ]
        }
      },
      "SQSHLU_advsimd": {
        "authored": "Signed saturating Shift Left Unsigned (immediate). This instruction reads each\nsigned integer value in the vector of the source SIMD&FP register, shifts each\nvalue by an immediate value, saturates the shifted result to an unsigned integer\nvalue, places the result in a vector, and writes the vector to the destination\nSIMD&FP register. The results are truncated. For rounded results, see UQRSHL.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQSHLU",
        "templates": {
          "SQSHLU_ASIMDSHF_R": [
            "SQSHLU  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SQSHLU_ASISDSHF_R": [
            "SQSHLU  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SQSHL_advsimd_imm": {
        "authored": "Signed saturating Shift Left (immediate). This instruction reads each vector\nelement in the source SIMD&FP register, shifts each result by an immediate\nvalue, places the final result in a vector, and writes the vector to the\ndestination SIMD&FP register. The results are truncated. For rounded results,\nsee UQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQSHL (immediate)",
        "templates": {
          "SQSHL_ASIMDSHF_R": [
            "SQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SQSHL_ASISDSHF_R": [
            "SQSHL  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SQSHL_advsimd_reg": {
        "authored": "Signed saturating Shift Left (register). This instruction takes each element in\nthe vector of the first source SIMD&FP register, shifts each element by a value\nfrom the least significant byte of the corresponding element of the second\nsource SIMD&FP register, places the results in a vector, and writes the vector\nto the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is\na right shift. The results are truncated. For rounded results, see SQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQSHL (register)",
        "templates": {
          "SQSHL_ASIMDSAME_ONLY": [
            "SQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SQSHL_ASISDSAME_ONLY": [
            "SQSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQSHRN_advsimd": {
        "authored": "Signed saturating Shift Right Narrow (immediate). This instruction reads each\nvector element in the source SIMD&FP register, right shifts and truncates each\nresult by an immediate value, saturates each shifted result to a value that is\nhalf the original width, puts the final result into a vector, and writes the\nvector to the lower or upper half of the destination SIMD&FP register. All the\nvalues in this instruction are signed integer values. The destination vector\nelements are half as long as the source vector elements. For rounded results,\nsee SQRSHRN.\n\nThe SQSHRN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SQSHRN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQSHRN, SQSHRN2",
        "templates": {
          "SQSHRN_ASIMDSHF_N": [
            "SQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ],
          "SQSHRN_ASISDSHF_N": [
            "SQSHRN  <Vb><d>, <Va><n>, #<shift>"
          ]
        }
      },
      "SQSHRUN_advsimd": {
        "authored": "Signed saturating Shift Right Unsigned Narrow (immediate). This instruction\nreads each signed integer value in the vector of the source SIMD&FP register,\nright shifts each value by an immediate value, saturates the result to an\nunsigned integer value that is half the original width, places the final result\ninto a vector, and writes the vector to the destination SIMD&FP register. The\nresults are truncated. For rounded results, see SQRSHRUN.\n\nThe SQSHRUN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SQSHRUN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQSHRUN, SQSHRUN2",
        "templates": {
          "SQSHRUN_ASIMDSHF_N": [
            "SQSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ],
          "SQSHRUN_ASISDSHF_N": [
            "SQSHRUN  <Vb><d>, <Va><n>, #<shift>"
          ]
        }
      },
      "SQSUB_advsimd": {
        "authored": "Signed saturating Subtract. This instruction subtracts the element values of the\nsecond source SIMD&FP register from the corresponding element values of the\nfirst source SIMD&FP register, places the results into a vector, and writes the\nvector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQSUB",
        "templates": {
          "SQSUB_ASIMDSAME_ONLY": [
            "SQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SQSUB_ASISDSAME_ONLY": [
            "SQSUB  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SQXTN_advsimd": {
        "authored": "Signed saturating extract Narrow. This instruction reads each vector element\nfrom the source SIMD&FP register, saturates the value to half the original\nwidth, places the result into a vector, and writes the vector to the lower or\nupper half of the destination SIMD&FP register. The destination vector elements\nare half as long as the source vector elements. All the values in this\ninstruction are signed integer values.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQXTN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SQXTN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQXTN, SQXTN2",
        "templates": {
          "SQXTN_ASIMDMISC_N": [
            "SQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
          ],
          "SQXTN_ASISDMISC_N": [
            "SQXTN  <Vb><d>, <Va><n>"
          ]
        }
      },
      "SQXTUN_advsimd": {
        "authored": "Signed saturating extract Unsigned Narrow. This instruction reads each signed\ninteger value in the vector of the source SIMD&FP register, saturates the value\nto an unsigned integer value that is half the original width, places the result\ninto a vector, and writes the vector to the lower or upper half of the\ndestination SIMD&FP register. The destination vector elements are half as long\nas the source vector elements.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe SQXTUN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SQXTUN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SQXTUN, SQXTUN2",
        "templates": {
          "SQXTUN_ASIMDMISC_N": [
            "SQXTUN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
          ],
          "SQXTUN_ASISDMISC_N": [
            "SQXTUN  <Vb><d>, <Va><n>"
          ]
        }
      },
      "SRHADD_advsimd": {
        "authored": "Signed Rounding Halving Add. This instruction adds corresponding signed integer\nvalues from the two source SIMD&FP registers, shifts each result right one bit,\nplaces the results into a vector, and writes the vector to the destination\nSIMD&FP register.\n\nThe results are rounded. For truncated results, see SHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SRHADD",
        "templates": {
          "SRHADD_ASIMDSAME_ONLY": [
            "SRHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "SRI_advsimd": {
        "authored": "Shift Right and Insert (immediate). This instruction reads each vector element\nin the source SIMD&FP register, right shifts each vector element by an immediate\nvalue, and inserts the result into the corresponding vector element in the\ndestination SIMD&FP register such that the new zero bits created by the shift\nare not inserted but retain their existing value. Bits shifted out of the right\nof each vector element of the source register are lost.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SRI",
        "templates": {
          "SRI_ASIMDSHF_R": [
            "SRI  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SRI_ASISDSHF_R": [
            "SRI  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SRSHL_advsimd": {
        "authored": "Signed Rounding Shift Left (register). This instruction takes each signed\ninteger value in the vector of the first source SIMD&FP register, shifts it by a\nvalue from the least significant byte of the corresponding element of the second\nsource SIMD&FP register, places the results in a vector, and writes the vector\nto the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift\nvalue is negative, it is a rounding right shift. For a truncating shift, see\nSSHL.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SRSHL",
        "templates": {
          "SRSHL_ASIMDSAME_ONLY": [
            "SRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SRSHL_ASISDSAME_ONLY": [
            "SRSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SRSHR_advsimd": {
        "authored": "Signed Rounding Shift Right (immediate). This instruction reads each vector\nelement in the source SIMD&FP register, right shifts each result by an immediate\nvalue, places the final result into a vector, and writes the vector to the\ndestination SIMD&FP register. All the values in this instruction are signed\ninteger values. The results are rounded. For truncated results, see SSHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SRSHR",
        "templates": {
          "SRSHR_ASIMDSHF_R": [
            "SRSHR  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SRSHR_ASISDSHF_R": [
            "SRSHR  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SRSRA_advsimd": {
        "authored": "Signed Rounding Shift Right and Accumulate (immediate). This instruction reads\neach vector element in the source SIMD&FP register, right shifts each result by\nan immediate value, and accumulates the final results with the vector elements\nof the destination SIMD&FP register. All the values in this instruction are\nsigned integer values. The results are rounded. For truncated results, see SSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SRSRA",
        "templates": {
          "SRSRA_ASIMDSHF_R": [
            "SRSRA  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SRSRA_ASISDSHF_R": [
            "SRSRA  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SSHLL_advsimd": {
        "authored": "Signed Shift Left Long (immediate). This instruction reads each vector element\nfrom the source SIMD&FP register, left shifts each vector element by the\nspecified shift amount, places the result into a vector, and writes the vector\nto the destination SIMD&FP register. The destination vector elements are twice\nas long as the source vector elements. All the values in this instruction are\nsigned integer values.\n\nThe SSHLL instruction extracts vector elements from the lower half of the source\nregister, while the SSHLL2 instruction extracts vector elements from the upper\nhalf of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SSHLL, SSHLL2",
        "templates": {
          "SSHLL_ASIMDSHF_L": [
            "SSHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"
          ]
        }
      },
      "SSHL_advsimd": {
        "authored": "Signed Shift Left (register). This instruction takes each signed integer value\nin the vector of the first source SIMD&FP register, shifts each value by a value\nfrom the least significant byte of the corresponding element of the second\nsource SIMD&FP register, places the results in a vector, and writes the vector\nto the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift\nvalue is negative, it is a truncating right shift. For a rounding shift, see\nSRSHL.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SSHL",
        "templates": {
          "SSHL_ASIMDSAME_ONLY": [
            "SSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SSHL_ASISDSAME_ONLY": [
            "SSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SSHR_advsimd": {
        "authored": "Signed Shift Right (immediate). This instruction reads each vector element in\nthe source SIMD&FP register, right shifts each result by an immediate value,\nplaces the final result into a vector, and writes the vector to the destination\nSIMD&FP register. All the values in this instruction are signed integer values.\nThe results are truncated. For rounded results, see SRSHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SSHR",
        "templates": {
          "SSHR_ASIMDSHF_R": [
            "SSHR  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SSHR_ASISDSHF_R": [
            "SSHR  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SSRA_advsimd": {
        "authored": "Signed Shift Right and Accumulate (immediate). This instruction reads each\nvector element in the source SIMD&FP register, right shifts each result by an\nimmediate value, and accumulates the final results with the vector elements of\nthe destination SIMD&FP register. All the values in this instruction are signed\ninteger values. The results are truncated. For rounded results, see SRSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SSRA",
        "templates": {
          "SSRA_ASIMDSHF_R": [
            "SSRA  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "SSRA_ASISDSHF_R": [
            "SSRA  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "SSUBL_advsimd": {
        "authored": "Signed Subtract Long. This instruction subtracts each vector element in the\nlower or upper half of the second source SIMD&FP register from the corresponding\nvector element of the first source SIMD&FP register, places the results into a\nvector, and writes the vector to the destination SIMD&FP register. All the\nvalues in this instruction are signed integer values. The destination vector\nelements are twice as long as the source vector elements.\n\nThe SSUBL instruction extracts each source vector from the lower half of each\nsource register, while the SSUBL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SSUBL, SSUBL2",
        "templates": {
          "SSUBL_ASIMDDIFF_L": [
            "SSUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "SSUBW_advsimd": {
        "authored": "Signed Subtract Wide. This instruction subtracts each vector element in the\nlower or upper half of the second source SIMD&FP register from the corresponding\nvector element in the first source SIMD&FP register, places the result in a\nvector, and writes the vector to the SIMD&FP destination register. All the\nvalues in this instruction are signed integer values.\n\nThe SSUBW instruction extracts the second source vector from the lower half of\nthe second source register, while the SSUBW2 instruction extracts the second\nsource vector from the upper half of the second source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SSUBW, SSUBW2",
        "templates": {
          "SSUBW_ASIMDDIFF_W": [
            "SSUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
          ]
        }
      },
      "ST1_advsimd_mult": {
        "authored": "Store multiple single-element structures from one, two, three, or four\nregisters. This instruction stores elements to memory from one, two, three, or\nfour SIMD&FP registers, without interleaving. Every element of each register is\nstored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST1 (multiple structures)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST1  { <Vt>.<T> }, [<Xn|SP>]",
            "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]",
            "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]",
            "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST1  { <Vt>.<T> }, [<Xn|SP>], <imm>",
            "ST1  { <Vt>.<T> }, [<Xn|SP>], <Xm>",
            "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>",
            "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>",
            "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>",
            "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>",
            "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>",
            "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          ]
        }
      },
      "ST1_advsimd_sngl": {
        "authored": "Store a single-element structure from one lane of one register. This instruction\nstores the specified element of a SIMD&FP register to memory.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST1 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST1  { <Vt>.B }[<index>], [<Xn|SP>]",
            "ST1  { <Vt>.H }[<index>], [<Xn|SP>]",
            "ST1  { <Vt>.S }[<index>], [<Xn|SP>]",
            "ST1  { <Vt>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST1  { <Vt>.B }[<index>], [<Xn|SP>], #1",
            "ST1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>",
            "ST1  { <Vt>.H }[<index>], [<Xn|SP>], #2",
            "ST1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>",
            "ST1  { <Vt>.S }[<index>], [<Xn|SP>], #4",
            "ST1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>",
            "ST1  { <Vt>.D }[<index>], [<Xn|SP>], #8",
            "ST1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "ST2_advsimd_mult": {
        "authored": "Store multiple 2-element structures from two registers. This instruction stores\nmultiple 2-element structures from two SIMD&FP registers to memory, with\ninterleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST2 (multiple structures)",
        "templates": {
          "AS_POST_INDEX": [
            "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>",
            "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
          ],
          "ST2_ASISDLSE_R2": [
            "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
          ]
        }
      },
      "ST2_advsimd_sngl": {
        "authored": "Store single 2-element structure from one lane of two registers. This\ninstruction stores a 2-element structure to memory from corresponding elements\nof two SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST2 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]",
            "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]",
            "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]",
            "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2",
            "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>",
            "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4",
            "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>",
            "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8",
            "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>",
            "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16",
            "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "ST3_advsimd_mult": {
        "authored": "Store multiple 3-element structures from three registers. This instruction\nstores multiple 3-element structures to memory from three SIMD&FP registers,\nwith interleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST3 (multiple structures)",
        "templates": {
          "AS_POST_INDEX": [
            "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>",
            "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
          ],
          "ST3_ASISDLSE_R3": [
            "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
          ]
        }
      },
      "ST3_advsimd_sngl": {
        "authored": "Store single 3-element structure from one lane of three registers. This\ninstruction stores a 3-element structure to memory from corresponding elements\nof three SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST3 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]",
            "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]",
            "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]",
            "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3",
            "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>",
            "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6",
            "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>",
            "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12",
            "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>",
            "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24",
            "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "ST4_advsimd_mult": {
        "authored": "Store multiple 4-element structures from four registers. This instruction stores\nmultiple 4-element structures to memory from four SIMD&FP registers, with\ninterleaving. Every element of each register is stored.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST4 (multiple structures)",
        "templates": {
          "AS_POST_INDEX": [
            "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>",
            "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          ],
          "ST4_ASISDLSE_R4": [
            "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          ]
        }
      },
      "ST4_advsimd_sngl": {
        "authored": "Store single 4-element structure from one lane of four registers. This\ninstruction stores a 4-element structure to memory from corresponding elements\nof four SIMD&FP registers.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ST4 (single structure)",
        "templates": {
          "AS_NO_POST_INDEX": [
            "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]",
            "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]",
            "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]",
            "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]"
          ],
          "AS_POST_INDEX": [
            "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4",
            "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>",
            "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8",
            "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>",
            "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16",
            "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>",
            "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32",
            "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>"
          ]
        }
      },
      "STNP_fpsimd": {
        "authored": "Store Pair of SIMD&FP registers, with Non-temporal hint. This instruction stores\na pair of SIMD&FP registers to memory, issuing a hint to the memory system that\nthe access is non-temporal. The address used for the store is calculated from an\naddress from a base register value and an immediate offset. For information\nabout non-temporal pair instructions, see Load/Store SIMD and Floating-point\nNon-temporal pair.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "STNP (SIMD&FP)",
        "templates": {
          "SIGNED_SCALED_OFFSET": [
            "STNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]",
            "STNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]",
            "STNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "STP_fpsimd": {
        "authored": "Store Pair of SIMD&FP registers. This instruction stores a pair of SIMD&FP\nregisters to memory. The address used for the store is calculated from a base\nregister value and an immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "STP (SIMD&FP)",
        "templates": {
          "POST_INDEXED": [
            "STP  <St1>, <St2>, [<Xn|SP>], #<imm>",
            "STP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>",
            "STP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>"
          ],
          "PRE_INDEXED": [
            "STP  <St1>, <St2>, [<Xn|SP>, #<imm>]!",
            "STP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!",
            "STP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!"
          ],
          "SIGNED_SCALED_OFFSET": [
            "STP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]",
            "STP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]",
            "STP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
          ]
        }
      },
      "STR_imm_fpsimd": {
        "authored": "Store SIMD&FP register (immediate offset). This instruction stores a single\nSIMD&FP register to memory. The address that is used for the store is calculated\nfrom a base register value and an immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "STR (immediate, SIMD&FP)",
        "templates": {
          "POST_INDEXED": [
            "STR  <Bt>, [<Xn|SP>], #<simm>",
            "STR  <Ht>, [<Xn|SP>], #<simm>",
            "STR  <St>, [<Xn|SP>], #<simm>",
            "STR  <Dt>, [<Xn|SP>], #<simm>",
            "STR  <Qt>, [<Xn|SP>], #<simm>"
          ],
          "PRE_INDEXED": [
            "STR  <Bt>, [<Xn|SP>, #<simm>]!",
            "STR  <Ht>, [<Xn|SP>, #<simm>]!",
            "STR  <St>, [<Xn|SP>, #<simm>]!",
            "STR  <Dt>, [<Xn|SP>, #<simm>]!",
            "STR  <Qt>, [<Xn|SP>, #<simm>]!"
          ],
          "UNSIGNED_SCALED_OFFSET": [
            "STR  <Bt>, [<Xn|SP>{, #<pimm>}]",
            "STR  <Ht>, [<Xn|SP>{, #<pimm>}]",
            "STR  <St>, [<Xn|SP>{, #<pimm>}]",
            "STR  <Dt>, [<Xn|SP>{, #<pimm>}]",
            "STR  <Qt>, [<Xn|SP>{, #<pimm>}]"
          ]
        }
      },
      "STR_reg_fpsimd": {
        "authored": "Store SIMD&FP register (register offset). This instruction stores a single\nSIMD&FP register to memory. The address that is used for the store is calculated\nfrom a base register value and an offset register value. The offset can be\noptionally shifted and extended.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "STR (register, SIMD&FP)",
        "templates": {
          "FPSIMD": [
            "STR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]",
            "STR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]",
            "STR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "STR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "STR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]",
            "STR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          ]
        }
      },
      "STUR_fpsimd": {
        "authored": "Store SIMD&FP register (unscaled offset). This instruction stores a single\nSIMD&FP register to memory. The address that is used for the store is calculated\nfrom a base register value and an optional immediate offset.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "STUR (SIMD&FP)",
        "templates": {
          "BASE_PLUS_OFFSET": [
            "STUR  <Bt>, [<Xn|SP>{, #<simm>}]",
            "STUR  <Ht>, [<Xn|SP>{, #<simm>}]",
            "STUR  <St>, [<Xn|SP>{, #<simm>}]",
            "STUR  <Dt>, [<Xn|SP>{, #<simm>}]",
            "STUR  <Qt>, [<Xn|SP>{, #<simm>}]"
          ]
        }
      },
      "SUBHN_advsimd": {
        "authored": "Subtract returning High Narrow. This instruction subtracts each vector element\nin the second source SIMD&FP register from the corresponding vector element in\nthe first source SIMD&FP register, places the most significant half of the\nresult into a vector, and writes the vector to the lower or upper half of the\ndestination SIMD&FP register. All the values in this instruction are signed\ninteger values.\n\nThe results are truncated. For rounded results, see RSUBHN.\n\nThe SUBHN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the SUBHN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SUBHN, SUBHN2",
        "templates": {
          "SUBHN_ASIMDDIFF_N": [
            "SUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
          ]
        }
      },
      "SUB_advsimd": {
        "authored": "Subtract (vector). This instruction subtracts each vector element in the second\nsource SIMD&FP register from the corresponding vector element in the first\nsource SIMD&FP register, places the result into a vector, and writes the vector\nto the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SUB (vector)",
        "templates": {
          "SUB_ASIMDSAME_ONLY": [
            "SUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "SUB_ASISDSAME_ONLY": [
            "SUB  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "SUDOT_advsimd_elt": {
        "authored": "Dot product index form with signed and unsigned integers. This instruction\nperforms the dot product of the four signed 8-bit integer values in each 32-bit\nelement of the first source register with the four unsigned 8-bit integer values\nin an indexed 32-bit element of the second source register, accumulating the\nresult into the corresponding 32-bit element of the destination vector.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is\nmandatory for implementations that include Advanced SIMD to support it.\nID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.",
        "heading": "SUDOT (by element)",
        "templates": {
          "SUDOT_ASIMDELEM_D": [
            "SUDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
          ]
        }
      },
      "SUQADD_advsimd": {
        "authored": "Signed saturating Accumulate of Unsigned value. This instruction adds the\nunsigned integer values of the vector elements in the source SIMD&FP register to\ncorresponding signed integer values of the vector elements in the destination\nSIMD&FP register, and writes the resulting signed integer values to the\ndestination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SUQADD",
        "templates": {
          "SUQADD_ASIMDMISC_R": [
            "SUQADD  <Vd>.<T>, <Vn>.<T>"
          ],
          "SUQADD_ASISDMISC_R": [
            "SUQADD  <V><d>, <V><n>"
          ]
        }
      },
      "SXTL_SSHLL_advsimd": {
        "authored": "Signed extend Long. This instruction duplicates each vector element in the lower\nor upper half of the source SIMD&FP register into a vector, and writes the\nvector to the destination SIMD&FP register. The destination vector elements are\ntwice as long as the source vector elements. All the values in this instruction\nare signed integer values.\n\nThe SXTL instruction extracts the source vector from the lower half of the\nsource register, while the SXTL2 instruction extracts the source vector from the\nupper half of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "SXTL, SXTL2",
        "templates": {
          "SSHLL_ASIMDSHF_L": [
            "SXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "TBL_advsimd": {
        "authored": "Table vector Lookup. This instruction reads each value from the vector elements\nin the index source SIMD&FP register, uses each result as an index to perform a\nlookup in a table of bytes that is described by one to four source table SIMD&FP\nregisters, places the lookup result in a vector, and writes the vector to the\ndestination SIMD&FP register. If an index is out of range for the table, the\nresult for that lookup is 0. If more than one source register is used to\ndescribe the table, the first source register describes the lowest bytes of the\ntable.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "TBL",
        "templates": {
          "ADVSIMD": [
            "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>",
            "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>",
            "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>",
            "TBL  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>"
          ]
        }
      },
      "TBX_advsimd": {
        "authored": "Table vector lookup extension. This instruction reads each value from the vector\nelements in the index source SIMD&FP register, uses each result as an index to\nperform a lookup in a table of bytes that is described by one to four source\ntable SIMD&FP registers, places the lookup result in a vector, and writes the\nvector to the destination SIMD&FP register. If an index is out of range for the\ntable, the existing value in the vector element of the destination register is\nleft unchanged. If more than one source register is used to describe the table,\nthe first source register describes the lowest bytes of the table.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "TBX",
        "templates": {
          "ADVSIMD": [
            "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>",
            "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>",
            "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>",
            "TBX  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>"
          ]
        }
      },
      "TRN1_advsimd": {
        "authored": "Transpose vectors (primary). This instruction reads corresponding even-numbered\nvector elements from the two source SIMD&FP registers, starting at zero, places\neach result into consecutive elements of a vector, and writes the vector to the\ndestination SIMD&FP register. Vector elements from the first source register are\nplaced into even-numbered elements of the destination vector, starting at zero,\nwhile vector elements from the second source register are placed into odd-\nnumbered elements of the destination vector.\n\nBy using this instruction with TRN2, a 2 x 2 matrix can be transposed.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "TRN1",
        "templates": {
          "TRN1_ASIMDPERM_ONLY": [
            "TRN1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "TRN2_advsimd": {
        "authored": "Transpose vectors (secondary). This instruction reads corresponding odd-numbered\nvector elements from the two source SIMD&FP registers, places each result into\nconsecutive elements of a vector, and writes the vector to the destination\nSIMD&FP register. Vector elements from the first source register are placed into\neven-numbered elements of the destination vector, starting at zero, while vector\nelements from the second source register are placed into odd-numbered elements\nof the destination vector.\n\nBy using this instruction with TRN1, a 2 x 2 matrix can be transposed.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "TRN2",
        "templates": {
          "TRN2_ASIMDPERM_ONLY": [
            "TRN2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UABAL_advsimd": {
        "authored": "Unsigned Absolute difference and Accumulate Long. This instruction subtracts the\nvector elements in the lower or upper half of the second source SIMD&FP register\nfrom the corresponding vector elements of the first source SIMD&FP register, and\naccumulates the absolute values of the results into the vector elements of the\ndestination SIMD&FP register. The destination vector elements are twice as long\nas the source vector elements. All the values in this instruction are unsigned\ninteger values.\n\nThe UABAL instruction extracts each source vector from the lower half of each\nsource register, while the UABAL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UABAL, UABAL2",
        "templates": {
          "UABAL_ASIMDDIFF_L": [
            "UABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UABA_advsimd": {
        "authored": "Unsigned Absolute difference and Accumulate. This instruction subtracts the\nelements of the vector of the second source SIMD&FP register from the\ncorresponding elements of the first source SIMD&FP register, and accumulates the\nabsolute values of the results into the elements of the vector of the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UABA",
        "templates": {
          "UABA_ASIMDSAME_ONLY": [
            "UABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UABDL_advsimd": {
        "authored": "Unsigned Absolute Difference Long. This instruction subtracts the vector\nelements in the lower or upper half of the second source SIMD&FP register from\nthe corresponding vector elements of the first source SIMD&FP register, places\nthe absolute value of the result into a vector, and writes the vector to the\ndestination SIMD&FP register. The destination vector elements are twice as long\nas the source vector elements. All the values in this instruction are unsigned\ninteger values.\n\nThe UABDL instruction extracts each source vector from the lower half of each\nsource register, while the UABDL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UABDL, UABDL2",
        "templates": {
          "UABDL_ASIMDDIFF_L": [
            "UABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UABD_advsimd": {
        "authored": "Unsigned Absolute Difference (vector). This instruction subtracts the elements\nof the vector of the second source SIMD&FP register from the corresponding\nelements of the first source SIMD&FP register, places the the absolute values of\nthe results into a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UABD",
        "templates": {
          "UABD_ASIMDSAME_ONLY": [
            "UABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UADALP_advsimd": {
        "authored": "Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of\nadjacent unsigned integer values from the vector in the source SIMD&FP register\nand accumulates the results with the vector elements of the destination SIMD&FP\nregister. The destination vector elements are twice as long as the source vector\nelements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UADALP",
        "templates": {
          "UADALP_ASIMDMISC_P": [
            "UADALP  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "UADDLP_advsimd": {
        "authored": "Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned\ninteger values from the vector in the source SIMD&FP register, places the result\ninto a vector, and writes the vector to the destination SIMD&FP register. The\ndestination vector elements are twice as long as the source vector elements.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UADDLP",
        "templates": {
          "UADDLP_ASIMDMISC_P": [
            "UADDLP  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "UADDLV_advsimd": {
        "authored": "Unsigned sum Long across Vector. This instruction adds every vector element in\nthe source SIMD&FP register together, and writes the scalar result to the\ndestination SIMD&FP register. The destination scalar is twice as long as the\nsource vector elements. All the values in this instruction are unsigned integer\nvalues.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UADDLV",
        "templates": {
          "UADDLV_ASIMDALL_ONLY": [
            "UADDLV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "UADDL_advsimd": {
        "authored": "Unsigned Add Long (vector). This instruction adds each vector element in the\nlower or upper half of the first source SIMD&FP register to the corresponding\nvector element of the second source SIMD&FP register, places the result into a\nvector, and writes the vector to the destination SIMD&FP register. The\ndestination vector elements are twice as long as the source vector elements. All\nthe values in this instruction are unsigned integer values.\n\nThe UADDL instruction extracts each source vector from the lower half of each\nsource register, while the UADDL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UADDL, UADDL2",
        "templates": {
          "UADDL_ASIMDDIFF_L": [
            "UADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UADDW_advsimd": {
        "authored": "Unsigned Add Wide. This instruction adds the vector elements of the first source\nSIMD&FP register to the corresponding vector elements in the lower or upper half\nof the second source SIMD&FP register, places the result in a vector, and writes\nthe vector to the SIMD&FP destination register. The vector elements of the\ndestination register and the first source register are twice as long as the\nvector elements of the second source register. All the values in this\ninstruction are unsigned integer values.\n\nThe UADDW instruction extracts vector elements from the lower half of the second\nsource register, while the UADDW2 instruction extracts vector elements from the\nupper half of the second source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UADDW, UADDW2",
        "templates": {
          "UADDW_ASIMDDIFF_W": [
            "UADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
          ]
        }
      },
      "UCVTF_advsimd_fix": {
        "authored": "Unsigned fixed-point Convert to Floating-point (vector). This instruction\nconverts each element in a vector from fixed-point to floating-point using the\nrounding mode that is specified by the FPCR, and writes the result to the\nSIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "UCVTF (vector, fixed-point)",
        "templates": {
          "UCVTF_ASIMDSHF_C": [
            "UCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>"
          ],
          "UCVTF_ASISDSHF_C": [
            "UCVTF  <V><d>, <V><n>, #<fbits>"
          ]
        }
      },
      "UCVTF_advsimd_int": {
        "authored": "Unsigned integer Convert to Floating-point (vector). This instruction converts\neach element in a vector from an unsigned integer value to a floating-point\nvalue using the rounding mode that is specified by the FPCR, and writes the\nresult to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "UCVTF (vector, integer)",
        "templates": {
          "UCVTF_ASIMDMISCFP16_R": [
            "UCVTF  <Vd>.<T>, <Vn>.<T>"
          ],
          "UCVTF_ASIMDMISC_R": [
            "UCVTF  <Vd>.<T>, <Vn>.<T>"
          ],
          "UCVTF_ASISDMISCFP16_R": [
            "UCVTF  <Hd>, <Hn>"
          ],
          "UCVTF_ASISDMISC_R": [
            "UCVTF  <V><d>, <V><n>"
          ]
        }
      },
      "UCVTF_float_fix": {
        "authored": "Unsigned fixed-point Convert to Floating-point (scalar). This instruction\nconverts the unsigned value in the 32-bit or 64-bit general-purpose source\nregister to a floating-point value using the rounding mode that is specified by\nthe FPCR, and writes the result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the Security state and Exception level in which the instruction is executed,\nan attempt to execute the instruction might be trapped.",
        "heading": "UCVTF (scalar, fixed-point)",
        "templates": {
          "FLOAT": [
            "UCVTF  <Hd>, <Wn>, #<fbits>",
            "UCVTF  <Sd>, <Wn>, #<fbits>",
            "UCVTF  <Dd>, <Wn>, #<fbits>",
            "UCVTF  <Hd>, <Xn>, #<fbits>",
            "UCVTF  <Sd>, <Xn>, #<fbits>",
            "UCVTF  <Dd>, <Xn>, #<fbits>"
          ]
        }
      },
      "UCVTF_float_int": {
        "authored": "Unsigned integer Convert to Floating-point (scalar). This instruction converts\nthe unsigned integer value in the general-purpose source register to a floating-\npoint value using the rounding mode that is specified by the FPCR, and writes\nthe result to the SIMD&FP destination register.\n\nA floating-point exception can be generated by this instruction. Depending on\nthe settings in FPCR, the exception results in either a flag being set in FPSR,\nor a synchronous exception being generated. For more information, see Floating-\npoint exception traps.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UCVTF (scalar, integer)",
        "templates": {
          "FLOAT": [
            "UCVTF  <Hd>, <Wn>",
            "UCVTF  <Sd>, <Wn>",
            "UCVTF  <Dd>, <Wn>",
            "UCVTF  <Hd>, <Xn>",
            "UCVTF  <Sd>, <Xn>",
            "UCVTF  <Dd>, <Xn>"
          ]
        }
      },
      "UDOT_advsimd_elt": {
        "authored": "Dot Product unsigned arithmetic (vector, by element). This instruction performs\nthe dot product of the four 8-bit elements in each 32-bit element of the first\nsource register with the four 8-bit elements of an indexed 32-bit element in the\nsecond source register, accumulating the result into the corresponding 32-bit\nelement of the destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.",
        "heading": "UDOT (by element)",
        "templates": {
          "UDOT_ASIMDELEM_D": [
            "UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
          ]
        }
      },
      "UDOT_advsimd_vec": {
        "authored": "Dot Product unsigned arithmetic (vector). This instruction performs the dot\nproduct of the four unsigned 8-bit elements in each 32-bit element of the first\nsource register with the four unsigned 8-bit elements of the corresponding\n32-bit element in the second source register, accumulating the result into the\ncorresponding 32-bit element of the destination register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.\n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is\nmandatory for all implementations to support it.\n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.",
        "heading": "UDOT (vector)",
        "templates": {
          "UDOT_ASIMDSAME2_D": [
            "UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UHADD_advsimd": {
        "authored": "Unsigned Halving Add. This instruction adds corresponding unsigned integer\nvalues from the two source SIMD&FP registers, shifts each result right one bit,\nplaces the results into a vector, and writes the vector to the destination\nSIMD&FP register.\n\nThe results are truncated. For rounded results, see URHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UHADD",
        "templates": {
          "UHADD_ASIMDSAME_ONLY": [
            "UHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UHSUB_advsimd": {
        "authored": "Unsigned Halving Subtract. This instruction subtracts the vector elements in the\nsecond source SIMD&FP register from the corresponding vector elements in the\nfirst source SIMD&FP register, shifts each result right one bit, places each\nresult into a vector, and writes the vector to the destination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UHSUB",
        "templates": {
          "UHSUB_ASIMDSAME_ONLY": [
            "UHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UMAXP_advsimd": {
        "authored": "Unsigned Maximum Pairwise. This instruction creates a vector by concatenating\nthe vector elements of the first source SIMD&FP register after the vector\nelements of the second source SIMD&FP register, reads each pair of adjacent\nvector elements in the two source SIMD&FP registers, writes the largest of each\npair of unsigned integer values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMAXP",
        "templates": {
          "UMAXP_ASIMDSAME_ONLY": [
            "UMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UMAXV_advsimd": {
        "authored": "Unsigned Maximum across Vector. This instruction compares all the vector\nelements in the source SIMD&FP register, and writes the largest of the values as\na scalar to the destination SIMD&FP register. All the values in this instruction\nare unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMAXV",
        "templates": {
          "UMAXV_ASIMDALL_ONLY": [
            "UMAXV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "UMAX_advsimd": {
        "authored": "Unsigned Maximum (vector). This instruction compares corresponding elements in\nthe vectors in the two source SIMD&FP registers, places the larger of each pair\nof unsigned integer values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMAX",
        "templates": {
          "UMAX_ASIMDSAME_ONLY": [
            "UMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UMINP_advsimd": {
        "authored": "Unsigned Minimum Pairwise. This instruction creates a vector by concatenating\nthe vector elements of the first source SIMD&FP register after the vector\nelements of the second source SIMD&FP register, reads each pair of adjacent\nvector elements in the two source SIMD&FP registers, writes the smallest of each\npair of unsigned integer values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMINP",
        "templates": {
          "UMINP_ASIMDSAME_ONLY": [
            "UMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UMINV_advsimd": {
        "authored": "Unsigned Minimum across Vector. This instruction compares all the vector\nelements in the source SIMD&FP register, and writes the smallest of the values\nas a scalar to the destination SIMD&FP register. All the values in this\ninstruction are unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMINV",
        "templates": {
          "UMINV_ASIMDALL_ONLY": [
            "UMINV  <V><d>, <Vn>.<T>"
          ]
        }
      },
      "UMIN_advsimd": {
        "authored": "Unsigned Minimum (vector). This instruction compares corresponding vector\nelements in the two source SIMD&FP registers, places the smaller of each of the\ntwo unsigned integer values into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMIN",
        "templates": {
          "UMIN_ASIMDSAME_ONLY": [
            "UMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UMLAL_advsimd_elt": {
        "authored": "Unsigned Multiply-Add Long (vector, by element). This instruction multiplies\neach vector element in the lower or upper half of the first source SIMD&FP\nregister by the specified vector element of the second source SIMD&FP register\nand accumulates the results with the vector elements of the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied.\n\nThe UMLAL instruction extracts vector elements from the lower half of the first\nsource register, while the UMLAL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMLAL, UMLAL2 (by element)",
        "templates": {
          "UMLAL_ASIMDELEM_L": [
            "UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "UMLAL_advsimd_vec": {
        "authored": "Unsigned Multiply-Add Long (vector). This instruction multiplies the vector\nelements in the lower or upper half of the first source SIMD&FP register by the\ncorresponding vector elements of the second source SIMD&FP register, and\naccumulates the results with the vector elements of the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied.\n\nThe UMLAL instruction extracts vector elements from the lower half of the first\nsource register, while the UMLAL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMLAL, UMLAL2 (vector)",
        "templates": {
          "UMLAL_ASIMDDIFF_L": [
            "UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UMLSL_advsimd_elt": {
        "authored": "Unsigned Multiply-Subtract Long (vector, by element). This instruction\nmultiplies each vector element in the lower or upper half of the first source\nSIMD&FP register by the specified vector element of the second source SIMD&FP\nregister and subtracts the results from the vector elements of the destination\nSIMD&FP register. The destination vector elements are twice as long as the\nelements that are multiplied.\n\nThe UMLSL instruction extracts vector elements from the lower half of the first\nsource register, while the UMLSL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMLSL, UMLSL2 (by element)",
        "templates": {
          "UMLSL_ASIMDELEM_L": [
            "UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "UMLSL_advsimd_vec": {
        "authored": "Unsigned Multiply-Subtract Long (vector). This instruction multiplies\ncorresponding vector elements in the lower or upper half of the two source\nSIMD&FP registers, and subtracts the results from the vector elements of the\ndestination SIMD&FP register. The destination vector elements are twice as long\nas the elements that are multiplied. All the values in this instruction are\nunsigned integer values.\n\nThe UMLSL instruction extracts each source vector from the lower half of each\nsource register, while the UMLSL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMLSL, UMLSL2 (vector)",
        "templates": {
          "UMLSL_ASIMDDIFF_L": [
            "UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UMMLA_advsimd_vec": {
        "authored": "Unsigned 8-bit integer matrix multiply-accumulate. This instruction multiplies\nthe 2x8 matrix of unsigned 8-bit integer values in the first source vector by\nthe 8x2 matrix of unsigned 8-bit integer values in the second source vector. The\nresulting 2x2 32-bit integer matrix product is destructively added to the 32-bit\ninteger matrix accumulator in the destination vector. This is equivalent to\nperforming an 8-way dot product per destination element.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is\nmandatory for implementations that include Advanced SIMD to support it.\nID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.",
        "heading": "UMMLA (vector)",
        "templates": {
          "UMMLA_ASIMDSAME2_G": [
            "UMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B"
          ]
        }
      },
      "UMOV_advsimd": {
        "authored": "Unsigned Move vector element to general-purpose register. This instruction reads\nthe unsigned integer from the source SIMD&FP register, zero-extends it to form a\n32-bit or 64-bit value, and writes the result to the destination general-purpose\nregister.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMOV",
        "templates": {
          "ADVSIMD": [
            "UMOV  <Wd>, <Vn>.<Ts>[<index>]",
            "UMOV  <Xd>, <Vn>.<Ts>[<index>]"
          ]
        }
      },
      "UMULL_advsimd_elt": {
        "authored": "Unsigned Multiply Long (vector, by element). This instruction multiplies each\nvector element in the lower or upper half of the first source SIMD&FP register\nby the specified vector element of the second source SIMD&FP register, places\nthe results in a vector, and writes the vector to the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied.\n\nThe UMULL instruction extracts vector elements from the lower half of the first\nsource register, while the UMULL2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMULL, UMULL2 (by element)",
        "templates": {
          "UMULL_ASIMDELEM_L": [
            "UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          ]
        }
      },
      "UMULL_advsimd_vec": {
        "authored": "Unsigned Multiply long (vector). This instruction multiplies corresponding\nvector elements in the lower or upper half of the two source SIMD&FP registers,\nplaces the result in a vector, and writes the vector to the destination SIMD&FP\nregister. The destination vector elements are twice as long as the elements that\nare multiplied. All the values in this instruction are unsigned integer values.\n\nThe UMULL instruction extracts each source vector from the lower half of each\nsource register, while the UMULL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UMULL, UMULL2 (vector)",
        "templates": {
          "UMULL_ASIMDDIFF_L": [
            "UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "UQADD_advsimd": {
        "authored": "Unsigned saturating Add. This instruction adds the values of corresponding\nelements of the two source SIMD&FP registers, places the results into a vector,\nand writes the vector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQADD",
        "templates": {
          "UQADD_ASIMDSAME_ONLY": [
            "UQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "UQADD_ASISDSAME_ONLY": [
            "UQADD  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "UQRSHL_advsimd": {
        "authored": "Unsigned saturating Rounding Shift Left (register). This instruction takes each\nvector element of the first source SIMD&FP register, shifts the vector element\nby a value from the least significant byte of the corresponding vector element\nof the second source SIMD&FP register, places the results into a vector, and\nwrites the vector to the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is\na right shift. The results are rounded. For truncated results, see UQSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQRSHL",
        "templates": {
          "UQRSHL_ASIMDSAME_ONLY": [
            "UQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "UQRSHL_ASISDSAME_ONLY": [
            "UQRSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "UQRSHRN_advsimd": {
        "authored": "Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction\nreads each vector element in the source SIMD&FP register, right shifts each\nresult by an immediate value, puts the final result into a vector, and writes\nthe vector to the lower or upper half of the destination SIMD&FP register. All\nthe values in this instruction are unsigned integer values. The results are\nrounded. For truncated results, see UQSHRN.\n\nThe UQRSHRN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the UQRSHRN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQRSHRN, UQRSHRN2",
        "templates": {
          "UQRSHRN_ASIMDSHF_N": [
            "UQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ],
          "UQRSHRN_ASISDSHF_N": [
            "UQRSHRN  <Vb><d>, <Va><n>, #<shift>"
          ]
        }
      },
      "UQSHL_advsimd_imm": {
        "authored": "Unsigned saturating Shift Left (immediate). This instruction takes each vector\nelement in the source SIMD&FP register, shifts it by an immediate value, places\nthe results in a vector, and writes the vector to the destination SIMD&FP\nregister. The results are truncated. For rounded results, see UQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQSHL (immediate)",
        "templates": {
          "UQSHL_ASIMDSHF_R": [
            "UQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "UQSHL_ASISDSHF_R": [
            "UQSHL  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "UQSHL_advsimd_reg": {
        "authored": "Unsigned saturating Shift Left (register). This instruction takes each element\nin the vector of the first source SIMD&FP register, shifts the element by a\nvalue from the least significant byte of the corresponding element of the second\nsource SIMD&FP register, places the results in a vector, and writes the vector\nto the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. Otherwise, it is\na right shift. The results are truncated. For rounded results, see UQRSHL.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQSHL (register)",
        "templates": {
          "UQSHL_ASIMDSAME_ONLY": [
            "UQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "UQSHL_ASISDSAME_ONLY": [
            "UQSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "UQSHRN_advsimd": {
        "authored": "Unsigned saturating Shift Right Narrow (immediate). This instruction reads each\nvector element in the source SIMD&FP register, right shifts each result by an\nimmediate value, saturates each shifted result to a value that is half the\noriginal width, puts the final result into a vector, and writes the vector to\nthe lower or upper half of the destination SIMD&FP register. All the values in\nthis instruction are unsigned integer values. The results are truncated. For\nrounded results, see UQRSHRN.\n\nThe UQSHRN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the UQSHRN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQSHRN, UQSHRN2",
        "templates": {
          "UQSHRN_ASIMDSHF_N": [
            "UQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          ],
          "UQSHRN_ASISDSHF_N": [
            "UQSHRN  <Vb><d>, <Va><n>, #<shift>"
          ]
        }
      },
      "UQSUB_advsimd": {
        "authored": "Unsigned saturating Subtract. This instruction subtracts the element values of\nthe second source SIMD&FP register from the corresponding element values of the\nfirst source SIMD&FP register, places the results into a vector, and writes the\nvector to the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQSUB",
        "templates": {
          "UQSUB_ASIMDSAME_ONLY": [
            "UQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "UQSUB_ASISDSAME_ONLY": [
            "UQSUB  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "UQXTN_advsimd": {
        "authored": "Unsigned saturating extract Narrow. This instruction reads each vector element\nfrom the source SIMD&FP register, saturates each value to half the original\nwidth, places the result into a vector, and writes the vector to the destination\nSIMD&FP register. All the values in this instruction are unsigned integer\nvalues.\n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nThe UQXTN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the UQXTN2 instruction writes the\nvector to the upper half of the destination register without affecting the other\nbits of the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UQXTN, UQXTN2",
        "templates": {
          "UQXTN_ASIMDMISC_N": [
            "UQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
          ],
          "UQXTN_ASISDMISC_N": [
            "UQXTN  <Vb><d>, <Va><n>"
          ]
        }
      },
      "URECPE_advsimd": {
        "authored": "Unsigned Reciprocal Estimate. This instruction reads each vector element from\nthe source SIMD&FP register, calculates an approximate inverse for the unsigned\ninteger value, places the result into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "URECPE",
        "templates": {
          "URECPE_ASIMDMISC_R": [
            "URECPE  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "URHADD_advsimd": {
        "authored": "Unsigned Rounding Halving Add. This instruction adds corresponding unsigned\ninteger values from the two source SIMD&FP registers, shifts each result right\none bit, places the results into a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThe results are rounded. For truncated results, see UHADD.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "URHADD",
        "templates": {
          "URHADD_ASIMDSAME_ONLY": [
            "URHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "URSHL_advsimd": {
        "authored": "Unsigned Rounding Shift Left (register). This instruction takes each element in\nthe vector of the first source SIMD&FP register, shifts the vector element by a\nvalue from the least significant byte of the corresponding element of the second\nsource SIMD&FP register, places the results in a vector, and writes the vector\nto the destination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift\nvalue is negative, it is a rounding right shift.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "URSHL",
        "templates": {
          "URSHL_ASIMDSAME_ONLY": [
            "URSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "URSHL_ASISDSAME_ONLY": [
            "URSHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "URSHR_advsimd": {
        "authored": "Unsigned Rounding Shift Right (immediate). This instruction reads each vector\nelement in the source SIMD&FP register, right shifts each result by an immediate\nvalue, writes the final result to a vector, and writes the vector to the\ndestination SIMD&FP register. All the values in this instruction are unsigned\ninteger values. The results are rounded. For truncated results, see USHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "URSHR",
        "templates": {
          "URSHR_ASIMDSHF_R": [
            "URSHR  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "URSHR_ASISDSHF_R": [
            "URSHR  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "URSQRTE_advsimd": {
        "authored": "Unsigned Reciprocal Square Root Estimate. This instruction reads each vector\nelement from the source SIMD&FP register, calculates an approximate inverse\nsquare root for each value, places the result into a vector, and writes the\nvector to the destination SIMD&FP register. All the values in this instruction\nare unsigned integer values.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "URSQRTE",
        "templates": {
          "URSQRTE_ASIMDMISC_R": [
            "URSQRTE  <Vd>.<T>, <Vn>.<T>"
          ]
        }
      },
      "URSRA_advsimd": {
        "authored": "Unsigned Rounding Shift Right and Accumulate (immediate). This instruction reads\neach vector element in the source SIMD&FP register, right shifts each result by\nan immediate value, and accumulates the final results with the vector elements\nof the destination SIMD&FP register. All the values in this instruction are\nunsigned integer values. The results are rounded. For truncated results, see\nUSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "URSRA",
        "templates": {
          "URSRA_ASIMDSHF_R": [
            "URSRA  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "URSRA_ASISDSHF_R": [
            "URSRA  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "USDOT_advsimd_elt": {
        "authored": "Dot Product index form with unsigned and signed integers. This instruction\nperforms the dot product of the four unsigned 8-bit integer values in each\n32-bit element of the first source register with the four signed 8-bit integer\nvalues in an indexed 32-bit element of the second source register, accumulating\nthe result into the corresponding 32-bit element of the destination register.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is\nmandatory for implementations that include Advanced SIMD to support it.\nID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.",
        "heading": "USDOT (by element)",
        "templates": {
          "USDOT_ASIMDELEM_D": [
            "USDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
          ]
        }
      },
      "USDOT_advsimd_vec": {
        "authored": "Dot Product vector form with unsigned and signed integers. This instruction\nperforms the dot product of the four unsigned 8-bit integer values in each\n32-bit element of the first source register with the four signed 8-bit integer\nvalues in the corresponding 32-bit element of the second source register,\naccumulating the result into the corresponding 32-bit element of the destination\nregister.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is\nmandatory for implementations that include Advanced SIMD to support it.\nID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.",
        "heading": "USDOT (vector)",
        "templates": {
          "USDOT_ASIMDSAME2_D": [
            "USDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "USHLL_advsimd": {
        "authored": "Unsigned Shift Left Long (immediate). This instruction reads each vector element\nin the lower or upper half of the source SIMD&FP register, shifts the unsigned\ninteger value left by the specified number of bits, places the result into a\nvector, and writes the vector to the destination SIMD&FP register. The\ndestination vector elements are twice as long as the source vector elements.\n\nThe USHLL instruction extracts vector elements from the lower half of the source\nregister, while the USHLL2 instruction extracts vector elements from the upper\nhalf of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USHLL, USHLL2",
        "templates": {
          "USHLL_ASIMDSHF_L": [
            "USHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"
          ]
        }
      },
      "USHL_advsimd": {
        "authored": "Unsigned Shift Left (register). This instruction takes each element in the\nvector of the first source SIMD&FP register, shifts each element by a value from\nthe least significant byte of the corresponding element of the second source\nSIMD&FP register, places the results in a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nIf the shift value is positive, the operation is a left shift. If the shift\nvalue is negative, it is a truncating right shift. For a rounding shift, see\nURSHL.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USHL",
        "templates": {
          "USHL_ASIMDSAME_ONLY": [
            "USHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ],
          "USHL_ASISDSAME_ONLY": [
            "USHL  <V><d>, <V><n>, <V><m>"
          ]
        }
      },
      "USHR_advsimd": {
        "authored": "Unsigned Shift Right (immediate). This instruction reads each vector element in\nthe source SIMD&FP register, right shifts each result by an immediate value,\nwrites the final result to a vector, and writes the vector to the destination\nSIMD&FP register. All the values in this instruction are unsigned integer\nvalues. The results are truncated. For rounded results, see URSHR.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USHR",
        "templates": {
          "USHR_ASIMDSHF_R": [
            "USHR  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "USHR_ASISDSHF_R": [
            "USHR  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "USMMLA_advsimd_vec": {
        "authored": "Unsigned and signed 8-bit integer matrix multiply-accumulate. This instruction\nmultiplies the 2x8 matrix of unsigned 8-bit integer values in the first source\nvector by the 8x2 matrix of signed 8-bit integer values in the second source\nvector. The resulting 2x2 32-bit integer matrix product is destructively added\nto the 32-bit integer matrix accumulator in the destination vector. This is\nequivalent to performing an 8-way dot product per destination element.\n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is\nmandatory for implementations that include Advanced SIMD to support it.\nID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.",
        "heading": "USMMLA (vector)",
        "templates": {
          "USMMLA_ASIMDSAME2_G": [
            "USMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B"
          ]
        }
      },
      "USQADD_advsimd": {
        "authored": "Unsigned saturating Accumulate of Signed value. This instruction adds the signed\ninteger values of the vector elements in the source SIMD&FP register to\ncorresponding unsigned integer values of the vector elements in the destination\nSIMD&FP register, and accumulates the resulting unsigned integer values with the\nvector elements of the destination SIMD&FP register.\n\nIf overflow occurs with any of the results, those results are saturated. If\nsaturation occurs, the cumulative saturation bit FPSR.QC is set.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USQADD",
        "templates": {
          "USQADD_ASIMDMISC_R": [
            "USQADD  <Vd>.<T>, <Vn>.<T>"
          ],
          "USQADD_ASISDMISC_R": [
            "USQADD  <V><d>, <V><n>"
          ]
        }
      },
      "USRA_advsimd": {
        "authored": "Unsigned Shift Right and Accumulate (immediate). This instruction reads each\nvector element in the source SIMD&FP register, right shifts each result by an\nimmediate value, and accumulates the final results with the vector elements of\nthe destination SIMD&FP register. All the values in this instruction are\nunsigned integer values. The results are truncated. For rounded results, see\nURSRA.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USRA",
        "templates": {
          "USRA_ASIMDSHF_R": [
            "USRA  <Vd>.<T>, <Vn>.<T>, #<shift>"
          ],
          "USRA_ASISDSHF_R": [
            "USRA  <V><d>, <V><n>, #<shift>"
          ]
        }
      },
      "USUBL_advsimd": {
        "authored": "Unsigned Subtract Long. This instruction subtracts each vector element in the\nlower or upper half of the second source SIMD&FP register from the corresponding\nvector element of the first source SIMD&FP register, places the result into a\nvector, and writes the vector to the destination SIMD&FP register. All the\nvalues in this instruction are unsigned integer values. The destination vector\nelements are twice as long as the source vector elements.\n\nThe USUBL instruction extracts each source vector from the lower half of each\nsource register, while the USUBL2 instruction extracts each source vector from\nthe upper half of each source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USUBL, USUBL2",
        "templates": {
          "USUBL_ASIMDDIFF_L": [
            "USUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          ]
        }
      },
      "USUBW_advsimd": {
        "authored": "Unsigned Subtract Wide. This instruction subtracts each vector element of the\nsecond source SIMD&FP register from the corresponding vector element in the\nlower or upper half of the first source SIMD&FP register, places the result in a\nvector, and writes the vector to the SIMD&FP destination register. All the\nvalues in this instruction are signed integer values.\n\nThe vector elements of the destination register and the first source register\nare twice as long as the vector elements of the second source register.\n\nThe USUBW instruction extracts vector elements from the lower half of the first\nsource register, while the USUBW2 instruction extracts vector elements from the\nupper half of the first source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "USUBW, USUBW2",
        "templates": {
          "USUBW_ASIMDDIFF_W": [
            "USUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
          ]
        }
      },
      "UXTL_USHLL_advsimd": {
        "authored": "Unsigned extend Long. This instruction copies each vector element from the lower\nor upper half of the source SIMD&FP register into a vector, and writes the\nvector to the destination SIMD&FP register. The destination vector elements are\ntwice as long as the source vector elements.\n\nThe UXTL instruction extracts vector elements from the lower half of the source\nregister, while the UXTL2 instruction extracts vector elements from the upper\nhalf of the source register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UXTL, UXTL2",
        "templates": {
          "USHLL_ASIMDSHF_L": [
            "UXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>"
          ]
        }
      },
      "UZP1_advsimd": {
        "authored": "Unzip vectors (primary). This instruction reads corresponding even-numbered\nvector elements from the two source SIMD&FP registers, starting at zero, places\nthe result from the first source register into consecutive elements in the lower\nhalf of a vector, and the result from the second source register into\nconsecutive elements in the upper half of a vector, and writes the vector to the\ndestination SIMD&FP register.\n\nThis instruction can be used with UZP2 to de-interleave two vectors.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UZP1",
        "templates": {
          "UZP1_ASIMDPERM_ONLY": [
            "UZP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "UZP2_advsimd": {
        "authored": "Unzip vectors (secondary). This instruction reads corresponding odd-numbered\nvector elements from the two source SIMD&FP registers, places the result from\nthe first source register into consecutive elements in the lower half of a\nvector, and the result from the second source register into consecutive elements\nin the upper half of a vector, and writes the vector to the destination SIMD&FP\nregister.\n\nThis instruction can be used with UZP1 to de-interleave two vectors.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "UZP2",
        "templates": {
          "UZP2_ASIMDPERM_ONLY": [
            "UZP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "XAR_advsimd": {
        "authored": "Exclusive OR and Rotate performs a bitwise exclusive OR of the 128-bit vectors\nin the two source SIMD&FP registers, rotates each 64-bit element of the\nresulting 128-bit vector right by the value specified by a 6-bit immediate\nvalue, and writes the result to the destination SIMD&FP register.\n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.",
        "heading": "XAR",
        "templates": {
          "XAR_VVV2_CRYPTO3_IMM6": [
            "XAR  <Vd>.2D, <Vn>.2D, <Vm>.2D, #<imm6>"
          ]
        }
      },
      "XTN_advsimd": {
        "authored": "Extract Narrow. This instruction reads each vector element from the source\nSIMD&FP register, narrows each value to half the original width, places the\nresult into a vector, and writes the vector to the lower or upper half of the\ndestination SIMD&FP register. The destination vector elements are half as long\nas the source vector elements.\n\nThe XTN instruction writes the vector to the lower half of the destination\nregister and clears the upper half, while the XTN2 instruction writes the vector\nto the upper half of the destination register without affecting the other bits\nof the register.\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "XTN, XTN2",
        "templates": {
          "XTN_ASIMDMISC_N": [
            "XTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"
          ]
        }
      },
      "ZIP1_advsimd": {
        "authored": "Zip vectors (primary). This instruction reads adjacent vector elements from the\nupper half of two source SIMD&FP registers as pairs, interleaves the pairs and\nplaces them into a vector, and writes the vector to the destination SIMD&FP\nregister. The first pair from the first source register is placed into the two\nlowest vector elements, with subsequent pairs taken alternately from each source\nregister.\n\nThis instruction can be used with ZIP2 to interleave two vectors.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ZIP1",
        "templates": {
          "ZIP1_ASIMDPERM_ONLY": [
            "ZIP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      },
      "ZIP2_advsimd": {
        "authored": "Zip vectors (secondary). This instruction reads adjacent vector elements from\nthe lower half of two source SIMD&FP registers as pairs, interleaves the pairs\nand places them into a vector, and writes the vector to the destination SIMD&FP\nregister. The first pair from the first source register is placed into the two\nlowest vector elements, with subsequent pairs taken alternately from each source\nregister.\n\nThis instruction can be used with ZIP1 to interleave two vectors.\n\n\n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,\nand the current Security state and Exception level, an attempt to execute the\ninstruction might be trapped.",
        "heading": "ZIP2",
        "templates": {
          "ZIP2_ASIMDPERM_ONLY": [
            "ZIP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          ]
        }
      }
    }
  },
  "keywords": {
    "ISH": "Inner Shareable is the required shareability domain, reads and writes are the\nrequired access types, both before and after the barrier instruction.",
    "ISHLD": "Inner Shareable is the required shareability domain, reads are the required\naccess type before the barrier instruction, and reads and writes are the\nrequired access types after the barrier instruction.",
    "ISHST": "Inner Shareable is the required shareability domain, writes are the required\naccess type, both before and after the barrier instruction.",
    "KEEP": "Retained or temporal prefetch, allocated in the cache normally.",
    "L1": "Level 1 cache.",
    "L2": "Level 2 cache.",
    "L3": "Level 3 cache.",
    "LD": "Full system is the required shareability domain, reads are the required access\ntype before the barrier instruction, and reads and writes are the required\naccess types after the barrier instruction.",
    "NSH": "Non-shareable is the required shareability domain, reads and writes are the\nrequired access, both before and after the barrier instruction.",
    "NSHLD": "Non-shareable is the required shareability domain, reads are the required access\ntype before the barrier instruction, and reads and writes are the required\naccess types after the barrier instruction.",
    "NSHST": "Non-shareable is the required shareability domain, writes are the required\naccess type, both before and after the barrier instruction.",
    "OSH": "Outer Shareable is the required shareability domain, reads and writes are the\nrequired access types, both before and after the barrier instruction.",
    "OSHLD": "Outer Shareable is the required shareability domain, reads are the required\naccess type before the barrier instruction, and reads and writes are the\nrequired access types after the barrier instruction.",
    "OSHST": "Outer Shareable is the required shareability domain, writes are the required\naccess type, both before and after the barrier instruction.",
    "PLD": "Prefetch for load.",
    "PLI": "Preload instructions.",
    "PST": "Prefetch for store.",
    "ST": "Full system is the required shareability domain, writes are the required access\ntype, both before and after the barrier instruction.",
    "STRM": "Streaming or non-temporal prefetch, for data that is used only once..",
    "SY": "Full system barrier operation."
  },
  "registers": {
    "base": {
      "B0": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B0-B7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "B1": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B0-B7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "B10": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B8-B15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in B8-B15 need to be preserved."
      },
      "B11": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B8-B15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in B8-B15 need to be preserved."
      },
      "B12": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B8-B15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in B8-B15 need to be preserved."
      },
      "B13": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B8-B15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in B8-B15 need to be preserved."
      },
      "B14": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B8-B15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in B8-B15 need to be preserved."
      },
      "B15": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B8-B15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in B8-B15 need to be preserved."
      },
      "B16": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B17": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B18": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B19": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B2": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B0-B7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "B20": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B21": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B22": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B23": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B24": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B25": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B26": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B27": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B28": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B29": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B3": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B0-B7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "B30": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B31": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B16-B31 do not need to be preserved (or should be preserved by the caller)."
      },
      "B4": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B0-B7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "B5": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B0-B7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "B6": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B0-B7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "B7": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B0-B7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "B8": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B8-B15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in B8-B15 need to be preserved."
      },
      "B9": {
        "long_name": "8-bit SIMD and FP Register",
        "purpose": "B8-B15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in B8-B15 need to be preserved."
      },
      "D0": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D0-D7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "D1": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D0-D7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "D10": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D8-D15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in D8-D15 need to be preserved."
      },
      "D11": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D8-D15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in D8-D15 need to be preserved."
      },
      "D12": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D8-D15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in D8-D15 need to be preserved."
      },
      "D13": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D8-D15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in D8-D15 need to be preserved."
      },
      "D14": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D8-D15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in D8-D15 need to be preserved."
      },
      "D15": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D8-D15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in D8-D15 need to be preserved."
      },
      "D16": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D17": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D18": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D19": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D2": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D0-D7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "D20": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D21": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D22": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D23": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D24": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D25": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D26": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D27": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D28": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D29": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D3": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D0-D7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "D30": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D31": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D16-D31 do not need to be preserved (or should be preserved by the caller)."
      },
      "D4": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D0-D7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "D5": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D0-D7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "D6": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D0-D7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "D7": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D0-D7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "D8": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D8-D15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in D8-D15 need to be preserved."
      },
      "D9": {
        "long_name": "64-bit SIMD and FP Register",
        "purpose": "D8-D15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in D8-D15 need to be preserved."
      },
      "H0": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H0-H7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "H1": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H0-H7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "H10": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H8-H15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in H8-H15 need to be preserved."
      },
      "H11": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H8-H15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in H8-H15 need to be preserved."
      },
      "H12": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H8-H15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in H8-H15 need to be preserved."
      },
      "H13": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H8-H15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in H8-H15 need to be preserved."
      },
      "H14": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H8-H15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in H8-H15 need to be preserved."
      },
      "H15": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H8-H15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in H8-H15 need to be preserved."
      },
      "H16": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H17": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H18": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H19": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H2": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H0-H7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "H20": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H21": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H22": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H23": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H24": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H25": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H26": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H27": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H28": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H29": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H3": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H0-H7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "H30": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H31": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H16-H31 do not need to be preserved (or should be preserved by the caller)."
      },
      "H4": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H0-H7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "H5": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H0-H7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "H6": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H0-H7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "H7": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H0-H7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "H8": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H8-H15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in H8-H15 need to be preserved."
      },
      "H9": {
        "long_name": "16-bit SIMD and FP Register",
        "purpose": "H8-H15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in H8-H15 need to be preserved."
      },
      "PC": {
        "long_name": "64-bit Program Counter",
        "purpose": "The name PC represents the program counter, a register holding the address of\nthe current instruction."
      },
      "Q0": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q0-Q7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "Q1": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q0-Q7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "Q10": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q8-Q15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in Q8-Q15 need to be preserved."
      },
      "Q11": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q8-Q15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in Q8-Q15 need to be preserved."
      },
      "Q12": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q8-Q15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in Q8-Q15 need to be preserved."
      },
      "Q13": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q8-Q15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in Q8-Q15 need to be preserved."
      },
      "Q14": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q8-Q15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in Q8-Q15 need to be preserved."
      },
      "Q15": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q8-Q15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in Q8-Q15 need to be preserved."
      },
      "Q16": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q17": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q18": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q19": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q2": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q0-Q7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "Q20": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q21": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q22": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q23": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q24": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q25": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q26": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q27": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q28": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q29": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q3": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q0-Q7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "Q30": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q31": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q16-Q31 do not need to be preserved (or should be preserved by the caller)."
      },
      "Q4": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q0-Q7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "Q5": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q0-Q7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "Q6": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q0-Q7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "Q7": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q0-Q7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "Q8": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q8-Q15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in Q8-Q15 need to be preserved."
      },
      "Q9": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "Q8-Q15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in Q8-Q15 need to be preserved."
      },
      "S0": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S0-S7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "S1": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S0-S7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "S10": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S8-S15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in S8-S15 need to be preserved."
      },
      "S11": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S8-S15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in S8-S15 need to be preserved."
      },
      "S12": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S8-S15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in S8-S15 need to be preserved."
      },
      "S13": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S8-S15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in S8-S15 need to be preserved."
      },
      "S14": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S8-S15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in S8-S15 need to be preserved."
      },
      "S15": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S8-S15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in S8-S15 need to be preserved."
      },
      "S16": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S17": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S18": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S19": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S2": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S0-S7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "S20": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S21": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S22": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S23": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S24": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S25": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S26": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S27": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S28": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S29": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S3": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S0-S7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "S30": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S31": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S16-S31 do not need to be preserved (or should be preserved by the caller)."
      },
      "S4": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S0-S7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "S5": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S0-S7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "S6": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S0-S7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "S7": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S0-S7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "S8": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S8-S15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in S8-S15 need to be preserved."
      },
      "S9": {
        "long_name": "32-bit SIMD and FP Register",
        "purpose": "S8-S15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in S8-S15 need to be preserved."
      },
      "SP": {
        "long_name": "64-bit Stack Pointer",
        "purpose": "The name SP represents the stack pointer for 64-bit operands where an encoding\nof the value 31 in the corresponding register field is interpreted as a read or\nwrite of the current stack pointer. When instructions do not interpret this\noperand encoding as the stack pointer, use of the name SP is an error."
      },
      "V0": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V0-V7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "V1": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V0-V7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "V10": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V8-V15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in V8-V15 need to be preserved."
      },
      "V11": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V8-V15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in V8-V15 need to be preserved."
      },
      "V12": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V8-V15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in V8-V15 need to be preserved."
      },
      "V13": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V8-V15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in V8-V15 need to be preserved."
      },
      "V14": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V8-V15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in V8-V15 need to be preserved."
      },
      "V15": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V8-V15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in V8-V15 need to be preserved."
      },
      "V16": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V17": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V18": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V19": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V2": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V0-V7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "V20": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V21": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V22": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V23": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V24": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V25": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V26": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V27": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V28": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V29": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V3": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V0-V7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "V30": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V31": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V16-V31 do not need to be preserved (or should be preserved by the caller)."
      },
      "V4": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V0-V7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "V5": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V0-V7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "V6": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V0-V7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "V7": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V0-V7 are used to pass argument values into a subroutine and to return result\nvalues from a function. They may also be used to hold intermediate values within\na routine (but, in general, only between subroutine calls)."
      },
      "V8": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V8-V15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in V8-V15 need to be preserved."
      },
      "V9": {
        "long_name": "128-bit SIMD and FP Register",
        "purpose": "V8-V15 must be preserved by a callee across subroutine calls. Only the bottom 64\nbits of each value stored in V8-V15 need to be preserved."
      },
      "W0": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument registers (W0-W7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "W1": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument registers (W0-W7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "W10": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (W9-W15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "W11": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (W9-W15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "W12": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (W9-W15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "W13": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (W9-W15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "W14": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (W9-W15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "W15": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (W9-W15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "W16": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "W16 and W17 are IP0 and IP1, intra-procedure-call temporary registers.\nThese can be used by call veneers and similar code, or as temporary\nregisters for intermediate values between subroutine calls. They are\ncorruptible by a function. Veneers are small pieces of code which are\nautomatically inserted by the linker, for example when the branch target is\nout of range of the branch instruction."
      },
      "W17": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "W16 and W17 are IP0 and IP1, intra-procedure-call temporary registers.\nThese can be used by call veneers and similar code, or as temporary\nregisters for intermediate values between subroutine calls. They are\ncorruptible by a function. Veneers are small pieces of code which are\nautomatically inserted by the linker, for example when the branch target is\nout of range of the branch instruction."
      },
      "W18": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "W18 is the platform register and is reserved for the use of platform ABIs.\nThis is an additional temporary register on platforms that don't assign a\nspecial meaning to it."
      },
      "W19": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Callee-saved registers (W19-W29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "W2": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument registers (W0-W7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "W20": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Callee-saved registers (W19-W29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "W21": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Callee-saved registers (W19-W29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "W22": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Callee-saved registers (W19-W29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "W23": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Callee-saved registers (W19-W29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "W24": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Callee-saved registers (W19-W29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "W25": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Callee-saved registers (W19-W29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "W26": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Callee-saved registers (W19-W29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "W27": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Callee-saved registers (W19-W29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "W28": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Callee-saved registers (W19-W29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "W29": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "W29 is the frame pointer register (FP)."
      },
      "W3": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument registers (W0-W7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "W30": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "W30 is the link register (LR)."
      },
      "W4": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument registers (W0-W7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "W5": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument registers (W0-W7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "W6": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument registers (W0-W7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "W7": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument registers (W0-W7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "W8": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "W8 is the indirect result register. This is used to pass the address location of\nan indirect result, for example, where a function returns a large structure."
      },
      "W9": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (W9-W15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "WSP": {
        "long_name": "32-bit Stack Pointer",
        "purpose": "The name WSP represents the current stack pointer in a 32-bit context."
      },
      "WZR": {
        "long_name": "32-bit Zero Register",
        "purpose": "The name WZR represents the zero register in a 32-bit context."
      },
      "X0": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Argument registers (X0-X7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "X1": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Argument registers (X0-X7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "X10": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (X9-X15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "X11": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (X9-X15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "X12": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (X9-X15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "X13": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (X9-X15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "X14": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (X9-X15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "X15": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (X9-X15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "X16": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "X16 and X17 are IP0 and IP1, intra-procedure-call temporary registers.\nThese can be used by call veneers and similar code, or as temporary\nregisters for intermediate values between subroutine calls. They are\ncorruptible by a function. Veneers are small pieces of code which are\nautomatically inserted by the linker, for example when the branch target is\nout of range of the branch instruction."
      },
      "X17": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "X16 and X17 are IP0 and IP1, intra-procedure-call temporary registers.\nThese can be used by call veneers and similar code, or as temporary\nregisters for intermediate values between subroutine calls. They are\ncorruptible by a function. Veneers are small pieces of code which are\nautomatically inserted by the linker, for example when the branch target is\nout of range of the branch instruction."
      },
      "X18": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "X18 is the platform register and is reserved for the use of platform ABIs.\nThis is an additional temporary register on platforms that don't assign a\nspecial meaning to it."
      },
      "X19": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Callee-saved registers (X19-X29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "X2": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Argument registers (X0-X7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "X20": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Callee-saved registers (X19-X29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "X21": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Callee-saved registers (X19-X29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "X22": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Callee-saved registers (X19-X29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "X23": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Callee-saved registers (X19-X29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "X24": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Callee-saved registers (X19-X29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "X25": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Callee-saved registers (X19-X29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "X26": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Callee-saved registers (X19-X29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "X27": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Callee-saved registers (X19-X29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "X28": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Callee-saved registers (X19-X29)\n\nThese registers are saved in the callee frame. They can be modified by the\ncalled subroutine as long as they are saved and restored before returning."
      },
      "X29": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "X29 is the frame pointer register (FP)."
      },
      "X3": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Argument registers (X0-X7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "X30": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "X30 is the link register (LR)."
      },
      "X4": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Argument registers (X0-X7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "X5": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Argument registers (X0-X7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "X6": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Argument registers (X0-X7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "X7": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Argument registers (X0-X7)\n\nThese are used to pass parameters to a function and to return a result. They can\nbe used as scratch registers or as caller-saved register variables that can hold\nintermediate values within a function, between calls to other functions."
      },
      "X8": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "X8 is the indirect result register. This is used to pass the address location of\nan indirect result, for example, where a function returns a large structure."
      },
      "X9": {
        "long_name": "64-bit General Purpose Register",
        "purpose": "Caller-saved temporary registers (X9-X15)\n\nIf the caller requires the values in any of these registers to be preserved across a\ncall to another function, the caller must save the affected registers in its own stack\nframe. They can be modified by the called subroutine without the need to save\nand restore them before returning to the caller."
      },
      "XZR": {
        "long_name": "64-bit Zero Register",
        "purpose": "The name XZR represents the zero register for 64-bit operands where an encoding\nof the value 31 in the corresponding register field is interpreted as returning\nzero when read or discarding the result when written. When instructions do not\ninterpret this operand encoding as the zero register, use of the name XZR is an\nerror."
      }
    },
    "encodings": {
      "MCR|MRC": {
        "VMPIDR_EL2": ["1111", "000", "0000", "0000", "101"],
        "VPIDR_EL2": ["1111", "000", "0000", "0000", "000"]
      },
      "MSR|MRS": {
        "ACTLR_EL1": ["11", "000", "0001", "0000", "001"],
        "ACTLR_EL2": ["11", "100", "0001", "0000", "001"],
        "ACTLR_EL3": ["11", "110", "0001", "0000", "001"],
        "AFSR0_EL1": ["11", "000", "0101", "0001", "000"],
        "AFSR0_EL2": ["11", "100", "0101", "0001", "000"],
        "AFSR0_EL3": ["11", "110", "0101", "0001", "000"],
        "AFSR1_EL1": ["11", "000", "0101", "0001", "001"],
        "AFSR1_EL2": ["11", "100", "0101", "0001", "001"],
        "AFSR1_EL3": ["11", "110", "0101", "0001", "001"],
        "AIDR_EL1": ["11", "001", "0000", "0000", "111"],
        "AMAIR_EL1": ["11", "000", "1010", "0011", "000"],
        "AMAIR_EL2": ["11", "100", "1010", "0011", "000"],
        "AMAIR_EL3": ["11", "110", "1010", "0011", "000"],
        "AMCFGR_EL0": ["11", "011", "1101", "0010", "001"],
        "AMCG1IDR_EL0": ["11", "011", "1101", "0010", "110"],
        "AMCGCR_EL0": ["11", "011", "1101", "0010", "010"],
        "AMCNTENCLR0_EL0": ["11", "011", "1101", "0010", "100"],
        "AMCNTENCLR1_EL0": ["11", "011", "1101", "0011", "000"],
        "AMCNTENSET0_EL0": ["11", "011", "1101", "0010", "101"],
        "AMCNTENSET1_EL0": ["11", "011", "1101", "0011", "001"],
        "AMCR_EL0": ["11", "011", "1101", "0010", "000"],
        "AMEVCNTR0<n>_EL0": ["11", "011", "1101", "010x", "xxx"],
        "AMEVCNTR1<n>_EL0": ["11", "011", "1101", "110x", "xxx"],
        "AMEVCNTVOFF0<n>_EL2": ["11", "100", "1101", "100x", "xxx"],
        "AMEVCNTVOFF1<n>_EL2": ["11", "100", "1101", "101x", "xxx"],
        "AMEVTYPER0<n>_EL0": ["11", "011", "1101", "011x", "xxx"],
        "AMEVTYPER1<n>_EL0": ["11", "011", "1101", "111x", "xxx"],
        "AMUSERENR_EL0": ["11", "011", "1101", "0010", "011"],
        "APDAKeyHi_EL1": ["11", "000", "0010", "0010", "001"],
        "APDAKeyLo_EL1": ["11", "000", "0010", "0010", "000"],
        "APDBKeyHi_EL1": ["11", "000", "0010", "0010", "011"],
        "APDBKeyLo_EL1": ["11", "000", "0010", "0010", "010"],
        "APGAKeyHi_EL1": ["11", "000", "0010", "0011", "001"],
        "APGAKeyLo_EL1": ["11", "000", "0010", "0011", "000"],
        "APIAKeyHi_EL1": ["11", "000", "0010", "0001", "001"],
        "APIAKeyLo_EL1": ["11", "000", "0010", "0001", "000"],
        "APIBKeyHi_EL1": ["11", "000", "0010", "0001", "011"],
        "APIBKeyLo_EL1": ["11", "000", "0010", "0001", "010"],
        "CCSIDR2_EL1": ["11", "001", "0000", "0000", "010"],
        "CCSIDR_EL1": ["11", "001", "0000", "0000", "000"],
        "CLIDR_EL1": ["11", "001", "0000", "0000", "001"],
        "CNTFRQ_EL0": ["11", "011", "1110", "0000", "000"],
        "CNTHCTL_EL2": ["11", "100", "1110", "0001", "000"],
        "CNTHPS_CTL_EL2": ["11", "100", "1110", "0101", "001"],
        "CNTHPS_CVAL_EL2": ["11", "100", "1110", "0101", "010"],
        "CNTHPS_TVAL_EL2": ["11", "100", "1110", "0101", "000"],
        "CNTHP_CTL_EL2": ["11", "100", "1110", "0010", "001"],
        "CNTHP_CVAL_EL2": ["11", "100", "1110", "0010", "010"],
        "CNTHP_TVAL_EL2": ["11", "100", "1110", "0010", "000"],
        "CNTHVS_CTL_EL2": ["11", "100", "1110", "0100", "001"],
        "CNTHVS_CVAL_EL2": ["11", "100", "1110", "0100", "010"],
        "CNTHVS_TVAL_EL2": ["11", "100", "1110", "0100", "000"],
        "CNTHV_CTL_EL2": ["11", "100", "1110", "0011", "001"],
        "CNTHV_CVAL_EL2": ["11", "100", "1110", "0011", "010"],
        "CNTHV_TVAL_EL2": ["11", "100", "1110", "0011", "000"],
        "CNTKCTL_EL1": ["11", "000", "1110", "0001", "000"],
        "CNTPCTSS_EL0": ["11", "011", "1110", "0000", "101"],
        "CNTPCT_EL0": ["11", "011", "1110", "0000", "001"],
        "CNTPOFF_EL2": ["11", "100", "1110", "0000", "110"],
        "CNTPS_CTL_EL1": ["11", "111", "1110", "0010", "001"],
        "CNTPS_CVAL_EL1": ["11", "111", "1110", "0010", "010"],
        "CNTPS_TVAL_EL1": ["11", "111", "1110", "0010", "000"],
        "CNTP_CTL_EL0": ["11", "011", "1110", "0010", "001"],
        "CNTP_CVAL_EL0": ["11", "011", "1110", "0010", "010"],
        "CNTP_TVAL_EL0": ["11", "011", "1110", "0010", "000"],
        "CNTVCTSS_EL0": ["11", "011", "1110", "0000", "110"],
        "CNTVCT_EL0": ["11", "011", "1110", "0000", "010"],
        "CNTVOFF_EL2": ["11", "100", "1110", "0000", "011"],
        "CNTV_CTL_EL0": ["11", "011", "1110", "0011", "001"],
        "CNTV_CVAL_EL0": ["11", "011", "1110", "0011", "010"],
        "CNTV_TVAL_EL0": ["11", "011", "1110", "0011", "000"],
        "CONTEXTIDR_EL1": ["11", "000", "1101", "0000", "001"],
        "CONTEXTIDR_EL2": ["11", "100", "1101", "0000", "001"],
        "CPACR_EL1": ["11", "000", "0001", "0000", "010"],
        "CPTR_EL2": ["11", "100", "0001", "0001", "010"],
        "CPTR_EL3": ["11", "110", "0001", "0001", "010"],
        "CSSELR_EL1": ["11", "010", "0000", "0000", "000"],
        "CTR_EL0": ["11", "011", "0000", "0000", "001"],
        "CurrentEL": ["11", "000", "0100", "0010", "010"],
        "DACR32_EL2": ["11", "100", "0011", "0000", "000"],
        "DAIF": ["11", "011", "0100", "0010", "001"],
        "DBGAUTHSTATUS_EL1": ["10", "000", "0111", "1110", "110"],
        "DBGBCR<n>_EL1": ["10", "000", "0000", "xxxx", "101"],
        "DBGBVR<n>_EL1": ["10", "000", "0000", "xxxx", "100"],
        "DBGCLAIMCLR_EL1": ["10", "000", "0111", "1001", "110"],
        "DBGCLAIMSET_EL1": ["10", "000", "0111", "1000", "110"],
        "DBGDTRRX_EL0": ["10", "011", "0000", "0101", "000"],
        "DBGDTRTX_EL0": ["10", "011", "0000", "0101", "000"],
        "DBGDTR_EL0": ["10", "011", "0000", "0100", "000"],
        "DBGPRCR_EL1": ["10", "000", "0001", "0100", "100"],
        "DBGVCR32_EL2": ["10", "100", "0000", "0111", "000"],
        "DBGWCR<n>_EL1": ["10", "000", "0000", "xxxx", "111"],
        "DBGWVR<n>_EL1": ["10", "000", "0000", "xxxx", "110"],
        "DCZID_EL0": ["11", "011", "0000", "0000", "111"],
        "DISR_EL1": ["11", "000", "1100", "0001", "001"],
        "DIT": ["11", "011", "0100", "0010", "101"],
        "DLR_EL0": ["11", "011", "0100", "0101", "001"],
        "DSPSR_EL0": ["11", "011", "0100", "0101", "000"],
        "ELR_EL1": ["11", "000", "0100", "0000", "001"],
        "ELR_EL2": ["11", "100", "0100", "0000", "001"],
        "ELR_EL3": ["11", "110", "0100", "0000", "001"],
        "ERRIDR_EL1": ["11", "000", "0101", "0011", "000"],
        "ERRSELR_EL1": ["11", "000", "0101", "0011", "001"],
        "ERXADDR_EL1": ["11", "000", "0101", "0100", "011"],
        "ERXCTLR_EL1": ["11", "000", "0101", "0100", "001"],
        "ERXFR_EL1": ["11", "000", "0101", "0100", "000"],
        "ERXMISC0_EL1": ["11", "000", "0101", "0101", "000"],
        "ERXMISC1_EL1": ["11", "000", "0101", "0101", "001"],
        "ERXMISC2_EL1": ["11", "000", "0101", "0101", "010"],
        "ERXMISC3_EL1": ["11", "000", "0101", "0101", "011"],
        "ERXPFGCDN_EL1": ["11", "000", "0101", "0100", "110"],
        "ERXPFGCTL_EL1": ["11", "000", "0101", "0100", "101"],
        "ERXPFGF_EL1": ["11", "000", "0101", "0100", "100"],
        "ERXSTATUS_EL1": ["11", "000", "0101", "0100", "010"],
        "ESR_EL1": ["11", "000", "0101", "0010", "000"],
        "ESR_EL2": ["11", "100", "0101", "0010", "000"],
        "ESR_EL3": ["11", "110", "0101", "0010", "000"],
        "FAR_EL1": ["11", "000", "0110", "0000", "000"],
        "FAR_EL2": ["11", "100", "0110", "0000", "000"],
        "FAR_EL3": ["11", "110", "0110", "0000", "000"],
        "FPCR": ["11", "011", "0100", "0100", "000"],
        "FPEXC32_EL2": ["11", "100", "0101", "0011", "000"],
        "FPSR": ["11", "011", "0100", "0100", "001"],
        "GCR_EL1": ["11", "000", "0001", "0000", "110"],
        "GMID_EL1": ["11", "001", "0000", "0000", "100"],
        "HACR_EL2": ["11", "100", "0001", "0001", "111"],
        "HAFGRTR_EL2": ["11", "100", "0011", "0001", "110"],
        "HCR_EL2": ["11", "100", "0001", "0001", "000"],
        "HDFGRTR_EL2": ["11", "100", "0011", "0001", "100"],
        "HDFGWTR_EL2": ["11", "100", "0011", "0001", "101"],
        "HFGITR_EL2": ["11", "100", "0001", "0001", "110"],
        "HFGRTR_EL2": ["11", "100", "0001", "0001", "100"],
        "HFGWTR_EL2": ["11", "100", "0001", "0001", "101"],
        "HPFAR_EL2": ["11", "100", "0110", "0000", "100"],
        "HSTR_EL2": ["11", "100", "0001", "0001", "011"],
        "ICC_AP0R<n>_EL1": ["11", "000", "1100", "1000", "1xx"],
        "ICC_AP1R<n>_EL1": ["11", "000", "1100", "1001", "0xx"],
        "ICC_ASGI1R_EL1": ["11", "000", "1100", "1011", "110"],
        "ICC_BPR0_EL1": ["11", "000", "1100", "1000", "011"],
        "ICC_BPR1_EL1": ["11", "000", "1100", "1100", "011"],
        "ICC_CTLR_EL1": ["11", "000", "1100", "1100", "100"],
        "ICC_CTLR_EL3": ["11", "110", "1100", "1100", "100"],
        "ICC_DIR_EL1": ["11", "000", "1100", "1011", "001"],
        "ICC_EOIR0_EL1": ["11", "000", "1100", "1000", "001"],
        "ICC_EOIR1_EL1": ["11", "000", "1100", "1100", "001"],
        "ICC_HPPIR0_EL1": ["11", "000", "1100", "1000", "010"],
        "ICC_HPPIR1_EL1": ["11", "000", "1100", "1100", "010"],
        "ICC_IAR0_EL1": ["11", "000", "1100", "1000", "000"],
        "ICC_IAR1_EL1": ["11", "000", "1100", "1100", "000"],
        "ICC_IGRPEN0_EL1": ["11", "000", "1100", "1100", "110"],
        "ICC_IGRPEN1_EL1": ["11", "000", "1100", "1100", "111"],
        "ICC_IGRPEN1_EL3": ["11", "110", "1100", "1100", "111"],
        "ICC_PMR_EL1": ["11", "000", "0100", "0110", "000"],
        "ICC_RPR_EL1": ["11", "000", "1100", "1011", "011"],
        "ICC_SGI0R_EL1": ["11", "000", "1100", "1011", "111"],
        "ICC_SGI1R_EL1": ["11", "000", "1100", "1011", "101"],
        "ICC_SRE_EL1": ["11", "000", "1100", "1100", "101"],
        "ICC_SRE_EL2": ["11", "100", "1100", "1001", "101"],
        "ICC_SRE_EL3": ["11", "110", "1100", "1100", "101"],
        "ICH_AP0R<n>_EL2": ["11", "100", "1100", "1000", "0xx"],
        "ICH_AP1R<n>_EL2": ["11", "100", "1100", "1001", "0xx"],
        "ICH_EISR_EL2": ["11", "100", "1100", "1011", "011"],
        "ICH_ELRSR_EL2": ["11", "100", "1100", "1011", "101"],
        "ICH_HCR_EL2": ["11", "100", "1100", "1011", "000"],
        "ICH_LR<n>_EL2": ["11", "100", "1100", "110x", "xxx"],
        "ICH_MISR_EL2": ["11", "100", "1100", "1011", "010"],
        "ICH_VMCR_EL2": ["11", "100", "1100", "1011", "111"],
        "ICH_VTR_EL2": ["11", "100", "1100", "1011", "001"],
        "ICV_AP0R<n>_EL1": ["11", "000", "1100", "1000", "1xx"],
        "ICV_AP1R<n>_EL1": ["11", "000", "1100", "1001", "0xx"],
        "ICV_BPR0_EL1": ["11", "000", "1100", "1000", "011"],
        "ICV_BPR1_EL1": ["11", "000", "1100", "1100", "011"],
        "ICV_CTLR_EL1": ["11", "000", "1100", "1100", "100"],
        "ICV_DIR_EL1": ["11", "000", "1100", "1011", "001"],
        "ICV_EOIR0_EL1": ["11", "000", "1100", "1000", "001"],
        "ICV_EOIR1_EL1": ["11", "000", "1100", "1100", "001"],
        "ICV_HPPIR0_EL1": ["11", "000", "1100", "1000", "010"],
        "ICV_HPPIR1_EL1": ["11", "000", "1100", "1100", "010"],
        "ICV_IAR0_EL1": ["11", "000", "1100", "1000", "000"],
        "ICV_IAR1_EL1": ["11", "000", "1100", "1100", "000"],
        "ICV_IGRPEN0_EL1": ["11", "000", "1100", "1100", "110"],
        "ICV_IGRPEN1_EL1": ["11", "000", "1100", "1100", "111"],
        "ICV_PMR_EL1": ["11", "000", "0100", "0110", "000"],
        "ICV_RPR_EL1": ["11", "000", "1100", "1011", "011"],
        "ID_AA64AFR0_EL1": ["11", "000", "0000", "0101", "100"],
        "ID_AA64AFR1_EL1": ["11", "000", "0000", "0101", "101"],
        "ID_AA64DFR0_EL1": ["11", "000", "0000", "0101", "000"],
        "ID_AA64DFR1_EL1": ["11", "000", "0000", "0101", "001"],
        "ID_AA64ISAR0_EL1": ["11", "000", "0000", "0110", "000"],
        "ID_AA64ISAR1_EL1": ["11", "000", "0000", "0110", "001"],
        "ID_AA64MMFR0_EL1": ["11", "000", "0000", "0111", "000"],
        "ID_AA64MMFR1_EL1": ["11", "000", "0000", "0111", "001"],
        "ID_AA64MMFR2_EL1": ["11", "000", "0000", "0111", "010"],
        "ID_AA64PFR0_EL1": ["11", "000", "0000", "0100", "000"],
        "ID_AA64PFR1_EL1": ["11", "000", "0000", "0100", "001"],
        "ID_AA64ZFR0_EL1": ["11", "000", "0000", "0100", "100"],
        "ID_AFR0_EL1": ["11", "000", "0000", "0001", "011"],
        "ID_DFR0_EL1": ["11", "000", "0000", "0001", "010"],
        "ID_DFR1_EL1": ["11", "000", "0000", "0011", "101"],
        "ID_ISAR0_EL1": ["11", "000", "0000", "0010", "000"],
        "ID_ISAR1_EL1": ["11", "000", "0000", "0010", "001"],
        "ID_ISAR2_EL1": ["11", "000", "0000", "0010", "010"],
        "ID_ISAR3_EL1": ["11", "000", "0000", "0010", "011"],
        "ID_ISAR4_EL1": ["11", "000", "0000", "0010", "100"],
        "ID_ISAR5_EL1": ["11", "000", "0000", "0010", "101"],
        "ID_ISAR6_EL1": ["11", "000", "0000", "0010", "111"],
        "ID_MMFR0_EL1": ["11", "000", "0000", "0001", "100"],
        "ID_MMFR1_EL1": ["11", "000", "0000", "0001", "101"],
        "ID_MMFR2_EL1": ["11", "000", "0000", "0001", "110"],
        "ID_MMFR3_EL1": ["11", "000", "0000", "0001", "111"],
        "ID_MMFR4_EL1": ["11", "000", "0000", "0010", "110"],
        "ID_MMFR5_EL1": ["11", "000", "0000", "0011", "110"],
        "ID_PFR0_EL1": ["11", "000", "0000", "0001", "000"],
        "ID_PFR1_EL1": ["11", "000", "0000", "0001", "001"],
        "ID_PFR2_EL1": ["11", "000", "0000", "0011", "100"],
        "IFSR32_EL2": ["11", "100", "0101", "0000", "001"],
        "ISR_EL1": ["11", "000", "1100", "0001", "000"],
        "LORC_EL1": ["11", "000", "1010", "0100", "011"],
        "LOREA_EL1": ["11", "000", "1010", "0100", "001"],
        "LORID_EL1": ["11", "000", "1010", "0100", "111"],
        "LORN_EL1": ["11", "000", "1010", "0100", "010"],
        "LORSA_EL1": ["11", "000", "1010", "0100", "000"],
        "MAIR_EL1": ["11", "000", "1010", "0010", "000"],
        "MAIR_EL2": ["11", "100", "1010", "0010", "000"],
        "MAIR_EL3": ["11", "110", "1010", "0010", "000"],
        "MDCCINT_EL1": ["10", "000", "0000", "0010", "000"],
        "MDCCSR_EL0": ["10", "011", "0000", "0001", "000"],
        "MDCR_EL2": ["11", "100", "0001", "0001", "001"],
        "MDCR_EL3": ["11", "110", "0001", "0011", "001"],
        "MDRAR_EL1": ["10", "000", "0001", "0000", "000"],
        "MDSCR_EL1": ["10", "000", "0000", "0010", "010"],
        "MIDR_EL1": ["11", "000", "0000", "0000", "000"],
        "MPAM0_EL1": ["11", "000", "1010", "0101", "001"],
        "MPAM1_EL1": ["11", "000", "1010", "0101", "000"],
        "MPAM2_EL2": ["11", "100", "1010", "0101", "000"],
        "MPAM3_EL3": ["11", "110", "1010", "0101", "000"],
        "MPAMHCR_EL2": ["11", "100", "1010", "0100", "000"],
        "MPAMIDR_EL1": ["11", "000", "1010", "0100", "100"],
        "MPAMVPM0_EL2": ["11", "100", "1010", "0110", "000"],
        "MPAMVPM1_EL2": ["11", "100", "1010", "0110", "001"],
        "MPAMVPM2_EL2": ["11", "100", "1010", "0110", "010"],
        "MPAMVPM3_EL2": ["11", "100", "1010", "0110", "011"],
        "MPAMVPM4_EL2": ["11", "100", "1010", "0110", "100"],
        "MPAMVPM5_EL2": ["11", "100", "1010", "0110", "101"],
        "MPAMVPM6_EL2": ["11", "100", "1010", "0110", "110"],
        "MPAMVPM7_EL2": ["11", "100", "1010", "0110", "111"],
        "MPAMVPMV_EL2": ["11", "100", "1010", "0100", "001"],
        "MPIDR_EL1": ["11", "000", "0000", "0000", "101"],
        "MVFR0_EL1": ["11", "000", "0000", "0011", "000"],
        "MVFR1_EL1": ["11", "000", "0000", "0011", "001"],
        "MVFR2_EL1": ["11", "000", "0000", "0011", "010"],
        "NZCV": ["11", "011", "0100", "0010", "000"],
        "OSDLR_EL1": ["10", "000", "0001", "0011", "100"],
        "OSDTRRX_EL1": ["10", "000", "0000", "0000", "010"],
        "OSDTRTX_EL1": ["10", "000", "0000", "0011", "010"],
        "OSECCR_EL1": ["10", "000", "0000", "0110", "010"],
        "OSLAR_EL1": ["10", "000", "0001", "0000", "100"],
        "OSLSR_EL1": ["10", "000", "0001", "0001", "100"],
        "PAN": ["11", "000", "0100", "0010", "011"],
        "PAR_EL1": ["11", "000", "0111", "0100", "000"],
        "PMBIDR_EL1": ["11", "000", "1001", "1010", "111"],
        "PMBLIMITR_EL1": ["11", "000", "1001", "1010", "000"],
        "PMBPTR_EL1": ["11", "000", "1001", "1010", "001"],
        "PMBSR_EL1": ["11", "000", "1001", "1010", "011"],
        "PMCCFILTR_EL0": ["11", "011", "1110", "1111", "111"],
        "PMCCNTR_EL0": ["11", "011", "1001", "1101", "000"],
        "PMCEID0_EL0": ["11", "011", "1001", "1100", "110"],
        "PMCEID1_EL0": ["11", "011", "1001", "1100", "111"],
        "PMCNTENCLR_EL0": ["11", "011", "1001", "1100", "010"],
        "PMCNTENSET_EL0": ["11", "011", "1001", "1100", "001"],
        "PMCR_EL0": ["11", "011", "1001", "1100", "000"],
        "PMEVCNTR<n>_EL0": ["11", "011", "1110", "10xx", "xxx"],
        "PMEVTYPER<n>_EL0": ["11", "011", "1110", "11xx", "xxx"],
        "PMINTENCLR_EL1": ["11", "000", "1001", "1110", "010"],
        "PMINTENSET_EL1": ["11", "000", "1001", "1110", "001"],
        "PMMIR_EL1": ["11", "000", "1001", "1110", "110"],
        "PMOVSCLR_EL0": ["11", "011", "1001", "1100", "011"],
        "PMOVSSET_EL0": ["11", "011", "1001", "1110", "011"],
        "PMSCR_EL1": ["11", "000", "1001", "1001", "000"],
        "PMSCR_EL2": ["11", "100", "1001", "1001", "000"],
        "PMSELR_EL0": ["11", "011", "1001", "1100", "101"],
        "PMSEVFR_EL1": ["11", "000", "1001", "1001", "101"],
        "PMSFCR_EL1": ["11", "000", "1001", "1001", "100"],
        "PMSICR_EL1": ["11", "000", "1001", "1001", "010"],
        "PMSIDR_EL1": ["11", "000", "1001", "1001", "111"],
        "PMSIRR_EL1": ["11", "000", "1001", "1001", "011"],
        "PMSLATFR_EL1": ["11", "000", "1001", "1001", "110"],
        "PMSWINC_EL0": ["11", "011", "1001", "1100", "100"],
        "PMUSERENR_EL0": ["11", "011", "1001", "1110", "000"],
        "PMXEVCNTR_EL0": ["11", "011", "1001", "1101", "010"],
        "PMXEVTYPER_EL0": ["11", "011", "1001", "1101", "001"],
        "REVIDR_EL1": ["11", "000", "0000", "0000", "110"],
        "RGSR_EL1": ["11", "000", "0001", "0000", "101"],
        "RMR_EL1": ["11", "000", "1100", "0000", "010"],
        "RMR_EL2": ["11", "100", "1100", "0000", "010"],
        "RMR_EL3": ["11", "110", "1100", "0000", "010"],
        "RNDR": ["11", "011", "0010", "0100", "000"],
        "RNDRRS": ["11", "011", "0010", "0100", "001"],
        "RVBAR_EL1": ["11", "000", "1100", "0000", "001"],
        "RVBAR_EL2": ["11", "100", "1100", "0000", "001"],
        "RVBAR_EL3": ["11", "110", "1100", "0000", "001"],
        "HID0_EL1": ["11", "0", "1111", "0", "0"],
        "EHID0_EL1": ["11", "0", "1111", "0", "1"],
        "HID1_EL1": ["11", "0", "1111", "1", "0"],
        "EHID1_EL1": ["11", "0", "1111", "1", "1"],
        "HID2_EL1": ["11", "0", "1111", "10", "0"],
        "EHID2_EL1": ["11", "0", "1111", "10", "1"],
        "HID3_EL1": ["11", "0", "1111", "11", "0"],
        "EHID3_EL1": ["11", "0", "1111", "11", "1"],
        "HID4_EL1": ["11", "0", "1111", "100", "0"],
        "EHID4_EL1": ["11", "0", "1111", "100", "1"],
        "HID5_EL1": ["11", "0", "1111", "101", "0"],
        "EHID5_EL1": ["11", "0", "1111", "101", "1"],
        "HID6_EL1": ["11", "0", "1111", "110", "0"],
        "HID7_EL1": ["11", "0", "1111", "111", "0"],
        "EHID7_EL1": ["11", "0", "1111", "111", "1"],
        "HID8_EL1": ["11", "0", "1111", "1000", "0"],
        "HID9_EL1": ["11", "0", "1111", "1001", "0"],
        "EHID9_EL1": ["11", "0", "1111", "1001", "1"],
        "HID10_EL1": ["11", "0", "1111", "1010", "0"],
        "EHID10_EL1": ["11", "0", "1111", "1010", "1"],
        "HID11_EL1": ["11", "0", "1111", "1011", "0"],
        "EHID11_EL1": ["11", "0", "1111", "1011", "1"],
        "HID13_EL1": ["11", "0", "1111", "1110", "0"],
        "HID14_EL1": ["11", "0", "1111", "1111", "0"],
        "HID16_EL1": ["11", "0", "1111", "1111", "10"],
        "HID17_EL1": ["11", "0", "1111", "1111", "101"],
        "HID18_EL1": ["11", "0", "1111", "1011", "10"],
        "EHID20_EL1": ["11", "0", "1111", "1", "10"],
        "HID21_EL1": ["11", "0", "1111", "1", "11"],
        "PMCR0_EL1": ["11", "1", "1111", "0", "0"],
        "PMCR1_EL1": ["11", "1", "1111", "1", "0"],
        "PMCR2_EL1": ["11", "1", "1111", "10", "0"],
        "PMCR3_EL1": ["11", "1", "1111", "11", "0"],
        "PMCR4_EL1": ["11", "1", "1111", "100", "0"],
        "PMESR0_EL1": ["11", "1", "1111", "101", "0"],
        "PMESR1_EL1": ["11", "1", "1111", "110", "0"],
        "PMSR_EL1": ["11", "1", "1111", "1101", "0"],
        "PMC0_EL1": ["11", "10", "1111", "0", "0"],
        "PMC1_EL1": ["11", "10", "1111", "1", "0"],
        "PMC2_EL1": ["11", "10", "1111", "10", "0"],
        "PMC3_EL1": ["11", "10", "1111", "11", "0"],
        "PMC4_EL1": ["11", "10", "1111", "100", "0"],
        "PMC5_EL1": ["11", "10", "1111", "101", "0"],
        "PMC6_EL1": ["11", "10", "1111", "110", "0"],
        "PMC7_EL1": ["11", "10", "1111", "111", "0"],
        "PMC8_EL1": ["11", "10", "1111", "1001", "0"],
        "PMC9_EL1": ["11", "10", "1111", "1010", "0"],
        "LSU_ERR_STS_EL1": ["11", "11", "1111", "0", "0"],
        "E_LSU_ERR_STS_EL1": ["11", "11", "1111", "10", "0"],
        "LSU_ERR_CTL_EL1": ["11", "11", "1111", "1", "0"],
        "L2C_ERR_STS_EL1": ["11", "11", "1111", "1000", "0"],
        "L2C_ERR_ADR_EL1": ["11", "11", "1111", "1001", "0"],
        "L2C_ERR_INF_EL1": ["11", "11", "1111", "1010", "0"],
        "FED_ERR_STS_EL1": ["11", "100", "1111", "0", "0"],
        "E_FED_ERR_STS_EL1": ["11", "100", "1111", "0", "10"],
        "APCTL_EL1": ["11", "100", "1111", "0", "100"],
        "KERNELKEYLO_EL1": ["11", "100", "1111", "1", "0"],
        "KERNELKEYHI_EL1": ["11", "100", "1111", "1", "1"],
        "VMSA_LOCK_EL1": ["11", "100", "1111", "1", "10"],
        "AMX_CTL_EL1": ["11", "100", "1111", "1", "100"],
        "APRR_EL0": ["11", "100", "1111", "10", "0"],
        "APRR_EL1": ["11", "100", "1111", "10", "1"],
        "CTRR_LOCK_EL1": ["11", "100", "1111", "10", "10"],
        "CTRR_A_LWR_EL1": ["11", "100", "1111", "10", "11"],
        "CTRR_A_UPR_EL1": ["11", "100", "1111", "10", "100"],
        "CTRR_CTL_EL1": ["11", "100", "1111", "10", "101"],
        "APRR_JIT_ENABLE_EL2": ["11", "100", "1111", "10", "110"],
        "APRR_JIT_MASK_EL2": ["11", "100", "1111", "10", "111"],
        "AMX_CTL_EL12": ["11", "100", "1111", "100", "110"],
        "AMX_CTL_EL2": ["11", "100", "1111", "100", "111"],
        "SPRR_PERM_EL20_SILLY_THING": ["11", "100", "1111", "101", "1"],
        "SPRR_PERM_EL02": ["11", "100", "1111", "101", "10"],
        "SPRR_KMASK0_EL12": ["11", "100", "1111", "110", "0"],
        "SPRR_UMASK0_EL2": ["11", "100", "1111", "111", "0"],
        "SPRR_UMASK1_EL2": ["11", "100", "1111", "111", "1"],
        "SPRR_UMASK2_EL2": ["11", "100", "1111", "111", "10"],
        "SPRR_UMASK3_EL2": ["11", "100", "1111", "111", "11"],
        "SPRR_UMASK0_EL12": ["11", "100", "1111", "1000", "0"],
        "SPRR_UMASK1_EL12": ["11", "100", "1111", "1000", "1"],
        "SPRR_UMASK2_EL12": ["11", "100", "1111", "1000", "10"],
        "SPRR_UMASK3_EL12": ["11", "100", "1111", "1000", "11"],
        "CNTPCT_ALIAS_EL0": ["11", "100", "1111", "1010", "101"],
        "CNTVCT_ALIAS_EL0": ["11", "100", "1111", "1010", "110"],
        "CTRR_A_LWR_EL2": ["11", "100", "1111", "1011", "0"],
        "CTRR_A_UPR_EL2": ["11", "100", "1111", "1011", "1"],
        "CTRR_CTL_EL2": ["11", "100", "1111", "1011", "100"],
        "CTRR_LOCK_EL2": ["11", "100", "1111", "1011", "101"],
        "IPI_RR_LOCAL_EL1": ["11", "101", "1111", "0", "0"],
        "IPI_RR_GLOBAL_EL1": ["11", "101", "1111", "0", "1"],
        "DPC_ERR_STS_EL1": ["11", "101", "1111", "0", "101"],
        "IPI_SR_EL1": ["11", "101", "1111", "1", "1"],
        "VM_TMR_LR_EL2": ["11", "101", "1111", "1", "10"],
        "VM_TMR_FIQ_ENA_EL2": ["11", "101", "1111", "1", "11"],
        "IPI_CR_EL1": ["11", "101", "1111", "11", "1"],
        "ACC_CFG_EL1": ["11", "101", "1111", "100", "0"],
        "CYC_OVRD_EL1": ["11", "101", "1111", "101", "0"],
        "ACC_OVRD_EL1": ["11", "101", "1111", "110", "0"],
        "ACC_EBLK_OVRD_EL1": ["11", "101", "1111", "110", "1"],
        "MMU_ERR_STS_EL1": ["11", "110", "1111", "0", "0"],
        "AFSR1_GL1": ["11", "110", "1111", "0", "1"],
        "AFSR1_GL2": ["11", "110", "1111", "0", "10"],
        "AFSR1_GL12": ["11", "110", "1111", "0", "11"],
        "SPRR_CONFIG_EL1": ["11", "110", "1111", "1", "0"],
        "GXF_CONFIG_EL1": ["11", "110", "1111", "1", "10"],
        "SPRR_UNK1_EL1": ["11", "110", "1111", "1", "11"],
        "GXF_CONFIG_EL2": ["11", "110", "1111", "1", "100"],
        "SPRR_PERM_EL0": ["11", "110", "1111", "1", "101"],
        "SPRR_PERM_EL1": ["11", "110", "1111", "1", "110"],
        "SPRR_PERM_EL2": ["11", "110", "1111", "1", "111"],
        "E_MMU_ERR_STS_EL1": ["11", "110", "1111", "10", "0"],
        "APGAKeyLo_EL12": ["11", "110", "1111", "10", "1"],
        "APGAKeyHi_EL12": ["11", "110", "1111", "10", "10"],
        "KERNELKEYLO_EL12": ["11", "110", "1111", "10", "11"],
        "KERNELKEYHI_EL12": ["11", "110", "1111", "10", "100"],
        "AFPCR_EL0": ["11", "110", "1111", "10", "101"],
        "AIDR2_EL1": ["11", "110", "1111", "10", "111"],
        "SPRR_UMASK0_EL1": ["11", "110", "1111", "11", "0"],
        "SPRR_KMASK0_EL1": ["11", "110", "1111", "11", "1"],
        "SPRR_KMASK0_EL2": ["11", "110", "1111", "11", "10"],
        "SPRR_UMASK1_EL1": ["11", "110", "1111", "11", "11"],
        "SPRR_UMASK2_EL1": ["11", "110", "1111", "11", "100"],
        "SPRR_UMASK3_EL1": ["11", "110", "1111", "11", "101"],
        "SPRR_KMASK1_EL1": ["11", "110", "1111", "100", "10"],
        "SPRR_KMASK2_EL1": ["11", "110", "1111", "100", "11"],
        "SPRR_KMASK3_EL1": ["11", "110", "1111", "100", "100"],
        "SPRR_KMASK1_EL2": ["11", "110", "1111", "101", "1"],
        "SPRR_KMASK2_EL2": ["11", "110", "1111", "101", "10"],
        "SPRR_KMASK3_EL2": ["11", "110", "1111", "101", "11"],
        "SPRR_KMASK1_EL12": ["11", "110", "1111", "110", "1"],
        "SPRR_KMASK2_EL12": ["11", "110", "1111", "110", "10"],
        "SPRR_KMASK3_EL12": ["11", "110", "1111", "110", "11"],
        "APIAKeyLo_EL12": ["11", "110", "1111", "111", "0"],
        "APIAKeyHi_EL12": ["11", "110", "1111", "111", "1"],
        "APIBKeyLo_EL12": ["11", "110", "1111", "111", "10"],
        "APIBKeyHi_EL12": ["11", "110", "1111", "111", "11"],
        "APDAKeyLo_EL12": ["11", "110", "1111", "111", "100"],
        "APDAKeyHi_EL12": ["11", "110", "1111", "111", "101"],
        "APDBKeyLo_EL12": ["11", "110", "1111", "111", "110"],
        "APDBKeyHi_EL12": ["11", "110", "1111", "111", "111"],
        "GXF_STATUS_EL1": ["11", "110", "1111", "1000", "0"],
        "GXF_ENTER_EL1": ["11", "110", "1111", "1000", "1"],
        "GXF_ABORT_EL1": ["11", "110", "1111", "1000", "10"],
        "VBAR_GL12": ["11", "110", "1111", "1001", "10"],
        "SPSR_GL12": ["11", "110", "1111", "1001", "11"],
        "ASPSR_GL12": ["11", "110", "1111", "1001", "100"],
        "ESR_GL12": ["11", "110", "1111", "1001", "101"],
        "ELR_GL12": ["11", "110", "1111", "1001", "110"],
        "SP_GL12": ["11", "110", "1111", "1010", "0"],
        "TPIDR_GL1": ["11", "110", "1111", "1010", "1"],
        "VBAR_GL1": ["11", "110", "1111", "1010", "10"],
        "SPSR_GL1": ["11", "110", "1111", "1010", "11"],
        "ASPSR_GL1": ["11", "110", "1111", "1010", "100"],
        "ESR_GL1": ["11", "110", "1111", "1010", "101"],
        "ELR_GL1": ["11", "110", "1111", "1010", "110"],
        "FAR_GL1": ["11", "110", "1111", "1010", "111"],
        "TPIDR_GL2": ["11", "110", "1111", "1011", "1"],
        "VBAR_GL2": ["11", "110", "1111", "1011", "10"],
        "SPSR_GL2": ["11", "110", "1111", "1011", "11"],
        "ASPSR_GL2": ["11", "110", "1111", "1011", "100"],
        "ESR_GL2": ["11", "110", "1111", "1011", "101"],
        "ELR_GL2": ["11", "110", "1111", "1011", "110"],
        "FAR_GL2": ["11", "110", "1111", "1011", "111"],
        "GXF_ENTER_EL2": ["11", "110", "1111", "1100", "0"],
        "GXF_ABORT_EL2": ["11", "110", "1111", "1100", "1"],
        "APCTL_EL2": ["11", "110", "1111", "1100", "10"],
        "APSTS_EL2_MAYBE": ["11", "110", "1111", "1100", "11"],
        "APSTS_EL1": ["11", "110", "1111", "1100", "100"],
        "SPRR_CONFIG_EL2": ["11", "110", "1111", "1110", "10"],
        "SPRR_UNK1_EL2": ["11", "110", "1111", "1110", "11"],
        "APVMKEYLO_EL2": ["11", "110", "1111", "1110", "100"],
        "APVMKEYHI_EL2": ["11", "110", "1111", "1110", "101"],
        "ACTLR_EL12": ["11", "110", "1111", "1110", "110"],
        "APSTS_EL12": ["11", "110", "1111", "1110", "111"],
        "APCTL_EL12": ["11", "110", "1111", "1111", "0"],
        "GXF_CONFIG_EL12": ["11", "110", "1111", "1111", "1"],
        "GXF_ENTER_EL12": ["11", "110", "1111", "1111", "10"],
        "GXF_ABORT_EL12": ["11", "110", "1111", "1111", "11"],
        "SPRR_CONFIG_EL12": ["11", "110", "1111", "1111", "100"],
        "SPRR_UNK1_EL12": ["11", "110", "1111", "1111", "101"],
        "SPRR_PERM_EL12": ["11", "110", "1111", "1111", "111"],
        "UPMCR0_EL1": ["11", "111", "1111", "0", "100"],
        "UPMESR0_EL1": ["11", "111", "1111", "1", "100"],
        "UPMECM0_EL1": ["11", "111", "1111", "11", "100"],
        "UPMECM1_EL1": ["11", "111", "1111", "100", "100"],
        "UPMPCM_EL1": ["11", "111", "1111", "101", "100"],
        "UPMSR_EL1": ["11", "111", "1111", "110", "100"],
        "UPMECM2_EL1": ["11", "111", "1111", "1000", "101"],
        "UPMECM3_EL1": ["11", "111", "1111", "1001", "101"],
        "UPMESR1_EL1": ["11", "111", "1111", "1011", "101"],
        "UPMC0_EL1": ["11", "111", "1111", "111", "100"],
        "UPMC1_EL1": ["11", "111", "1111", "1000", "100"],
        "UPMC2_EL1": ["11", "111", "1111", "1001", "100"],
        "UPMC3_EL1": ["11", "111", "1111", "1010", "100"],
        "UPMC4_EL1": ["11", "111", "1111", "1011", "100"],
        "UPMC5_EL1": ["11", "111", "1111", "1100", "100"],
        "UPMC6_EL1": ["11", "111", "1111", "1101", "100"],
        "UPMC7_EL1": ["11", "111", "1111", "1110", "100"],
        "UPMC8_EL1": ["11", "111", "1111", "0", "101"],
        "UPMC9_EL1": ["11", "111", "1111", "1", "101"],
        "UPMC10_EL1": ["11", "111", "1111", "10", "101"],
        "UPMC11_EL1": ["11", "111", "1111", "11", "101"],
        "UPMC12_EL1": ["11", "111", "1111", "100", "101"],
        "UPMC13_EL1": ["11", "111", "1111", "101", "101"],
        "UPMC14_EL1": ["11", "111", "1111", "110", "101"],
        "UPMC15_EL1": ["11", "111", "1111", "111", "101"],
        "S3_<op1>_<Cn>_<Cm>_<op2>": ["11", "xxx", "1x11", "xxxx", "xxx"],
        "SCR_EL3": ["11", "110", "0001", "0001", "000"],
        "SCTLR_EL1": ["11", "000", "0001", "0000", "000"],
        "SCTLR_EL2": ["11", "100", "0001", "0000", "000"],
        "SCTLR_EL3": ["11", "110", "0001", "0000", "000"],
        "SCXTNUM_EL0": ["11", "011", "1101", "0000", "111"],
        "SCXTNUM_EL1": ["11", "000", "1101", "0000", "111"],
        "SCXTNUM_EL2": ["11", "100", "1101", "0000", "111"],
        "SCXTNUM_EL3": ["11", "110", "1101", "0000", "111"],
        "SDER32_EL2": ["11", "100", "0001", "0011", "001"],
        "SDER32_EL3": ["11", "110", "0001", "0001", "001"],
        "SPSR_EL1": ["11", "000", "0100", "0000", "000"],
        "SPSR_EL2": ["11", "100", "0100", "0000", "000"],
        "SPSR_EL3": ["11", "110", "0100", "0000", "000"],
        "SPSR_abt": ["11", "100", "0100", "0011", "001"],
        "SPSR_fiq": ["11", "100", "0100", "0011", "011"],
        "SPSR_irq": ["11", "100", "0100", "0011", "000"],
        "SPSR_und": ["11", "100", "0100", "0011", "010"],
        "SPSel": ["11", "000", "0100", "0010", "000"],
        "SP_EL0": ["11", "000", "0100", "0001", "000"],
        "SP_EL1": ["11", "100", "0100", "0001", "000"],
        "SP_EL2": ["11", "110", "0100", "0001", "000"],
        "SSBS": ["11", "011", "0100", "0010", "110"],
        "TCO": ["11", "011", "0100", "0010", "111"],
        "TCR_EL1": ["11", "000", "0010", "0000", "010"],
        "TCR_EL2": ["11", "100", "0010", "0000", "010"],
        "TCR_EL3": ["11", "110", "0010", "0000", "010"],
        "TFSRE0_EL1": ["11", "000", "0101", "0110", "001"],
        "TFSR_EL1": ["11", "000", "0101", "0110", "000"],
        "TFSR_EL2": ["11", "100", "0101", "0110", "000"],
        "TFSR_EL3": ["11", "110", "0101", "0110", "000"],
        "TPIDRRO_EL0": ["11", "011", "1101", "0000", "011"],
        "TPIDR_EL0": ["11", "011", "1101", "0000", "010"],
        "TPIDR_EL1": ["11", "000", "1101", "0000", "100"],
        "TPIDR_EL2": ["11", "100", "1101", "0000", "010"],
        "TPIDR_EL3": ["11", "110", "1101", "0000", "010"],
        "TRFCR_EL1": ["11", "000", "0001", "0010", "001"],
        "TRFCR_EL2": ["11", "100", "0001", "0010", "001"],
        "TTBR0_EL1": ["11", "000", "0010", "0000", "000"],
        "TTBR0_EL2": ["11", "100", "0010", "0000", "000"],
        "TTBR0_EL3": ["11", "110", "0010", "0000", "000"],
        "TTBR1_EL1": ["11", "000", "0010", "0000", "001"],
        "TTBR1_EL2": ["11", "100", "0010", "0000", "001"],
        "UAO": ["11", "000", "0100", "0010", "100"],
        "VBAR_EL1": ["11", "000", "1100", "0000", "000"],
        "VBAR_EL2": ["11", "100", "1100", "0000", "000"],
        "VBAR_EL3": ["11", "110", "1100", "0000", "000"],
        "VDISR_EL2": ["11", "100", "1100", "0001", "001"],
        "VMPIDR_EL2": ["11", "100", "0000", "0000", "101"],
        "VNCR_EL2": ["11", "100", "0010", "0010", "000"],
        "VPIDR_EL2": ["11", "100", "0000", "0000", "000"],
        "VSESR_EL2": ["11", "100", "0101", "0010", "011"],
        "VSTCR_EL2": ["11", "100", "0010", "0110", "010"],
        "VSTTBR_EL2": ["11", "100", "0010", "0110", "000"],
        "VTCR_EL2": ["11", "100", "0010", "0001", "010"],
        "VTTBR_EL2": ["11", "100", "0010", "0001", "000"],
        "ZCR_EL1": ["11", "000", "0001", "0010", "000"],
        "ZCR_EL2": ["11", "100", "0001", "0010", "000"],
        "ZCR_EL3": ["11", "110", "0001", "0010", "000"]
      },
      "SYS": {
        "AT S12E0R": ["01", "100", "0111", "1000", "110"],
        "AT S12E0W": ["01", "100", "0111", "1000", "111"],
        "AT S12E1R": ["01", "100", "0111", "1000", "100"],
        "AT S12E1W": ["01", "100", "0111", "1000", "101"],
        "AT S1E0R": ["01", "000", "0111", "1000", "010"],
        "AT S1E0W": ["01", "000", "0111", "1000", "011"],
        "AT S1E1R": ["01", "000", "0111", "1000", "000"],
        "AT S1E1RP": ["01", "000", "0111", "1001", "000"],
        "AT S1E1W": ["01", "000", "0111", "1000", "001"],
        "AT S1E1WP": ["01", "000", "0111", "1001", "001"],
        "AT S1E2R": ["01", "100", "0111", "1000", "000"],
        "AT S1E2W": ["01", "100", "0111", "1000", "001"],
        "AT S1E3R": ["01", "110", "0111", "1000", "000"],
        "AT S1E3W": ["01", "110", "0111", "1000", "001"],
        "CFP RCTX": ["01", "011", "0111", "0011", "100"],
        "CPP RCTX": ["01", "011", "0111", "0011", "111"],
        "DC CGDSW": ["01", "000", "0111", "1010", "110"],
        "DC CGDVAC": ["01", "011", "0111", "1010", "101"],
        "DC CGDVADP": ["01", "011", "0111", "1101", "101"],
        "DC CGDVAP": ["01", "011", "0111", "1100", "101"],
        "DC CGSW": ["01", "000", "0111", "1010", "100"],
        "DC CGVAC": ["01", "011", "0111", "1010", "011"],
        "DC CGVADP": ["01", "011", "0111", "1101", "011"],
        "DC CGVAP": ["01", "011", "0111", "1100", "011"],
        "DC CIGDSW": ["01", "000", "0111", "1110", "110"],
        "DC CIGDVAC": ["01", "011", "0111", "1110", "101"],
        "DC CIGSW": ["01", "000", "0111", "1110", "100"],
        "DC CIGVAC": ["01", "011", "0111", "1110", "011"],
        "DC CISW": ["01", "000", "0111", "1110", "010"],
        "DC CIVAC": ["01", "011", "0111", "1110", "001"],
        "DC CSW": ["01", "000", "0111", "1010", "010"],
        "DC CVAC": ["01", "011", "0111", "1010", "001"],
        "DC CVADP": ["01", "011", "0111", "1101", "001"],
        "DC CVAP": ["01", "011", "0111", "1100", "001"],
        "DC CVAU": ["01", "011", "0111", "1011", "001"],
        "DC GVA": ["01", "011", "0111", "0100", "011"],
        "DC GZVA": ["01", "011", "0111", "0100", "100"],
        "DC IGDSW": ["01", "000", "0111", "0110", "110"],
        "DC IGDVAC": ["01", "000", "0111", "0110", "101"],
        "DC IGSW": ["01", "000", "0111", "0110", "100"],
        "DC IGVAC": ["01", "000", "0111", "0110", "011"],
        "DC ISW": ["01", "000", "0111", "0110", "010"],
        "DC IVAC": ["01", "000", "0111", "0110", "001"],
        "DC ZVA": ["01", "011", "0111", "0100", "001"],
        "DVP RCTX": ["01", "011", "0111", "0011", "101"],
        "IC IALLU": ["01", "000", "0111", "0101", "000"],
        "IC IALLUIS": ["01", "000", "0111", "0001", "000"],
        "IC IVAU": ["01", "011", "0111", "0101", "001"],
        "S1_<op1>_<Cn>_<Cm>_<op2>": ["01", "xxx", "1x11", "xxxx", "xxx"],
        "TLBI ALLE1": ["01", "100", "1000", "0111", "100"],
        "TLBI ALLE1IS": ["01", "100", "1000", "0011", "100"],
        "TLBI ALLE1OS": ["01", "100", "1000", "0001", "100"],
        "TLBI ALLE2": ["01", "100", "1000", "0111", "000"],
        "TLBI ALLE2IS": ["01", "100", "1000", "0011", "000"],
        "TLBI ALLE2OS": ["01", "100", "1000", "0001", "000"],
        "TLBI ALLE3": ["01", "110", "1000", "0111", "000"],
        "TLBI ALLE3IS": ["01", "110", "1000", "0011", "000"],
        "TLBI ALLE3OS": ["01", "110", "1000", "0001", "000"],
        "TLBI ASIDE1": ["01", "000", "1000", "0111", "010"],
        "TLBI ASIDE1IS": ["01", "000", "1000", "0011", "010"],
        "TLBI ASIDE1OS": ["01", "000", "1000", "0001", "010"],
        "TLBI IPAS2E1": ["01", "100", "1000", "0100", "001"],
        "TLBI IPAS2E1IS": ["01", "100", "1000", "0000", "001"],
        "TLBI IPAS2E1OS": ["01", "100", "1000", "0100", "000"],
        "TLBI IPAS2LE1": ["01", "100", "1000", "0100", "101"],
        "TLBI IPAS2LE1IS": ["01", "100", "1000", "0000", "101"],
        "TLBI IPAS2LE1OS": ["01", "100", "1000", "0100", "100"],
        "TLBI RIPAS2E1": ["01", "100", "1000", "0100", "010"],
        "TLBI RIPAS2E1IS": ["01", "100", "1000", "0000", "010"],
        "TLBI RIPAS2E1OS": ["01", "100", "1000", "0100", "011"],
        "TLBI RIPAS2LE1": ["01", "100", "1000", "0100", "110"],
        "TLBI RIPAS2LE1IS": ["01", "100", "1000", "0000", "110"],
        "TLBI RIPAS2LE1OS": ["01", "100", "1000", "0100", "111"],
        "TLBI RVAAE1": ["01", "000", "1000", "0110", "011"],
        "TLBI RVAAE1IS": ["01", "000", "1000", "0010", "011"],
        "TLBI RVAAE1OS": ["01", "000", "1000", "0101", "011"],
        "TLBI RVAALE1": ["01", "000", "1000", "0110", "111"],
        "TLBI RVAALE1IS": ["01", "000", "1000", "0010", "111"],
        "TLBI RVAALE1OS": ["01", "000", "1000", "0101", "111"],
        "TLBI RVAE1": ["01", "000", "1000", "0110", "001"],
        "TLBI RVAE1IS": ["01", "000", "1000", "0010", "001"],
        "TLBI RVAE1OS": ["01", "000", "1000", "0101", "001"],
        "TLBI RVAE2": ["01", "100", "1000", "0110", "001"],
        "TLBI RVAE2IS": ["01", "100", "1000", "0010", "001"],
        "TLBI RVAE2OS": ["01", "100", "1000", "0101", "001"],
        "TLBI RVAE3": ["01", "110", "1000", "0110", "001"],
        "TLBI RVAE3IS": ["01", "110", "1000", "0010", "001"],
        "TLBI RVAE3OS": ["01", "110", "1000", "0101", "001"],
        "TLBI RVALE1": ["01", "000", "1000", "0110", "101"],
        "TLBI RVALE1IS": ["01", "000", "1000", "0010", "101"],
        "TLBI RVALE1OS": ["01", "000", "1000", "0101", "101"],
        "TLBI RVALE2": ["01", "100", "1000", "0110", "101"],
        "TLBI RVALE2IS": ["01", "100", "1000", "0010", "101"],
        "TLBI RVALE2OS": ["01", "100", "1000", "0101", "101"],
        "TLBI RVALE3": ["01", "110", "1000", "0110", "101"],
        "TLBI RVALE3IS": ["01", "110", "1000", "0010", "101"],
        "TLBI RVALE3OS": ["01", "110", "1000", "0101", "101"],
        "TLBI VAAE1": ["01", "000", "1000", "0111", "011"],
        "TLBI VAAE1IS": ["01", "000", "1000", "0011", "011"],
        "TLBI VAAE1OS": ["01", "000", "1000", "0001", "011"],
        "TLBI VAALE1": ["01", "000", "1000", "0111", "111"],
        "TLBI VAALE1IS": ["01", "000", "1000", "0011", "111"],
        "TLBI VAALE1OS": ["01", "000", "1000", "0001", "111"],
        "TLBI VAE1": ["01", "000", "1000", "0111", "001"],
        "TLBI VAE1IS": ["01", "000", "1000", "0011", "001"],
        "TLBI VAE1OS": ["01", "000", "1000", "0001", "001"],
        "TLBI VAE2": ["01", "100", "1000", "0111", "001"],
        "TLBI VAE2IS": ["01", "100", "1000", "0011", "001"],
        "TLBI VAE2OS": ["01", "100", "1000", "0001", "001"],
        "TLBI VAE3": ["01", "110", "1000", "0111", "001"],
        "TLBI VAE3IS": ["01", "110", "1000", "0011", "001"],
        "TLBI VAE3OS": ["01", "110", "1000", "0001", "001"],
        "TLBI VALE1": ["01", "000", "1000", "0111", "101"],
        "TLBI VALE1IS": ["01", "000", "1000", "0011", "101"],
        "TLBI VALE1OS": ["01", "000", "1000", "0001", "101"],
        "TLBI VALE2": ["01", "100", "1000", "0111", "101"],
        "TLBI VALE2IS": ["01", "100", "1000", "0011", "101"],
        "TLBI VALE2OS": ["01", "100", "1000", "0001", "101"],
        "TLBI VALE3": ["01", "110", "1000", "0111", "101"],
        "TLBI VALE3IS": ["01", "110", "1000", "0011", "101"],
        "TLBI VALE3OS": ["01", "110", "1000", "0001", "101"],
        "TLBI VMALLE1": ["01", "000", "1000", "0111", "000"],
        "TLBI VMALLE1IS": ["01", "000", "1000", "0011", "000"],
        "TLBI VMALLE1OS": ["01", "000", "1000", "0001", "000"],
        "TLBI VMALLS12E1": ["01", "100", "1000", "0111", "110"],
        "TLBI VMALLS12E1IS": ["01", "100", "1000", "0011", "110"],
        "TLBI VMALLS12E1OS": ["01", "100", "1000", "0001", "110"]
      }
    },
    "instructions": {
      "ALLE1": {
        "long_name": "TLB Invalidate All, EL1",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 or stage 2 translation table entry, from any level of\nthe translation table walk.\n  - If SCR_EL3.NS is 0 and the entry would be required to translate an address\nusing the Secure EL1&0 translation regime.\n  - If SCR_EL3.NS is 1 and the entry would be required to translate an address\nusing the Non-secure EL1&0 translation regime.\n\nThe invalidation applies to entries with any VMID.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nFor the EL1&0 translation regimes, the invalidation applies to both global\nentries, and non-global entries with any ASID."
      },
      "ALLE1IS": {
        "long_name": "TLB Invalidate All, EL1, Inner Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 or stage 2 translation table entry, from any level of\nthe translation table walk.\n  - If SCR_EL3.NS is 0 and the entry would be required to translate an address\nusing the Secure EL1&0 translation regime.\n  - If SCR_EL3.NS is 1 and the entry would be required to translate an address\nusing the Non-secure EL1&0 translation regime.\n\nThe invalidation applies to entries with any VMID.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nFor the EL1&0 translation regimes, the invalidation applies to both global\nentries, and non-global entries with any ASID."
      },
      "ALLE1OS": {
        "long_name": "TLB Invalidate All, EL1, Outer Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 or stage 2 translation table entry, from any level of\nthe translation table walk.\n  - If SCR_EL3.NS is 0 and the entry would be required to translate an address\nusing the Secure EL1&0 translation regime.\n  - If SCR_EL3.NS is 1 and the entry would be required to translate an address\nusing the Non-secure EL1&0 translation regime.\n\nThe invalidation applies to entries with any VMID.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nFor the EL1&0 translation regimes, the invalidation applies to both global\nentries, and non-global entries with any ASID."
      },
      "ALLE2": {
        "long_name": "TLB Invalidate All, EL2",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - If SCR_EL3.NS is 1 and the entry would be required to translate an address\nusing the Non-secure EL2 or Non-secure EL2&0 translation regime.\n  - If SCR_EL3.NS is 0 and the entry would be required to translate an address\nusing the Secure EL2 or Secure EL2&0 translation regime.\n\nThe invalidation only applies to the PE that executes this System instruction."
      },
      "ALLE2IS": {
        "long_name": "TLB Invalidate All, EL2, Inner Shareable",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - If SCR_EL3.NS is 1 and the entry would be required to translate an address\nusing the Non-secure EL2 or Non-secure EL2&0 translation regime.\n  - If SCR_EL3.NS is 0 and the entry would be required to translate an address\nusing the Secure EL2 or Secure EL2&0 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction."
      },
      "ALLE2OS": {
        "long_name": "TLB Invalidate All, EL2, Outer Shareable",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - If SCR_EL3.NS is 1 and the entry would be required to translate an address\nusing the Non-secure EL2 or Non-secure EL2&0 translation regime.\n  - If SCR_EL3.NS is 0 and the entry would be required to translate an address\nusing the Secure EL2 or Secure EL2&0 translation regime.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction."
      },
      "ALLE3": {
        "long_name": "TLB Invalidate All, EL3",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be required to translate an address using the EL3\ntranslation regime.\n\nThe invalidation applies to the PE that executes this System instruction."
      },
      "ALLE3IS": {
        "long_name": "TLB Invalidate All, EL3, Inner Shareable",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be required to translate an address using the EL3\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction."
      },
      "ALLE3OS": {
        "long_name": "TLB Invalidate All, EL3, Outer Shareable",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be required to translate an address using the EL3\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction."
      },
      "ASIDE1": {
        "long_name": "TLB Invalidate by ASID, EL1",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used for the specified ASID, and either:\n    - Is from a level of lookup above the final level.\n    - Is a non-global entry from the final level of lookup.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID, and would be required to translate an address using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nan address using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate an address using the EL1&0 translation\nregime.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nASID, bits [48:63] - ASID value to match. Any appropriate TLB entries that match\n                     the ASID values will be affected by this System\n                     instruction. If the implementation supports 16 bits of\n                     ASID, but only 8 bits are being used in the context being\n                     invalidated, the upper bits are res0."
      },
      "ASIDE1IS": {
        "long_name": "TLB Invalidate by ASID, EL1, Inner Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used for the specified ASID, and either:\n    - Is from a level of lookup above the final level.\n    - Is a non-global entry from the final level of lookup.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID, and would be required to translate an address using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nan address using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate an address using the EL1&0 translation\nregime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nASID, bits [48:63] - ASID value to match. Any appropriate TLB entries that match\n                     the ASID values will be affected by this System\n                     instruction. If the implementation supports 16 bits of\n                     ASID, but only 8 bits are being used in the context being\n                     invalidated, the upper bits are res0."
      },
      "ASIDE1OS": {
        "long_name": "TLB Invalidate by ASID, EL1, Outer Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used for the specified ASID, and either:\n    - Is from a level of lookup above the final level.\n    - Is a non-global entry from the final level of lookup.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID, and would be required to translate an address using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nan address using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate an address using the EL1&0 translation\nregime.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nASID, bits [48:63] - ASID value to match. Any appropriate TLB entries that match\n                     the ASID values will be affected by this System\n                     instruction. If the implementation supports 16 bits of\n                     ASID, but only 8 bits are being used in the context being\n                     invalidated, the upper bits are res0."
      },
      "CGDSW": {
        "long_name": "Data, Allocation Tag or unified Cache line Clean of Data and Allocation Tags by Set/Way",
        "purpose": "Clean data and Allocation Tags in data cache by set/way.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "CGDVAC": {
        "long_name": "Data, Allocation Tag or unified Cache line Clean of Allocation Tags by VA to PoC",
        "purpose": "Clean data and Allocation Tags in data cache by address to Point of Coherency.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "CGDVADP": {
        "long_name": "Data, Allocation Tag or unified Cache line Clean of Allocation Tags by VA to PoDP",
        "purpose": "Clean Allocation Tags in data cache by address to Point of Deep Persistence.\n\nIf the memory system does not identify a Point of Deep Persistence, then this\ninstruction behaves as a DC CGVAP.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "CGDVAP": {
        "long_name": "Data, Allocation Tag or unified Cache line Clean of Data and Allocation Tags by VA to PoP",
        "purpose": "Clean data and Allocation Tags in data cache by address to Point of Persistence.\n\nIf the memory system does not identify a Point of Persistence, then this\ninstruction behaves as a DC CGDVAC.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "CGSW": {
        "long_name": "Data, Allocation Tag or unified Cache line Clean of Allocation Tags by Set/Way",
        "purpose": "Clean Allocation Tags in data cache by set/way.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "CGVAC": {
        "long_name": "Data, Allocation Tag or unified Cache line Clean of Allocation Tags by VA to PoC",
        "purpose": "Clean Allocation Tags in data cache by address to Point of Coherency.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "CGVADP": {
        "long_name": "Data, Allocation Tag or unified Cache line Clean of Data and Allocation Tags by VA to PoDP",
        "purpose": "Clean data and Allocation Tags in data cache by address to Point of Deep\nPersistence.\n\nIf the memory system does not identify a Point of Deep Persistence, then this\ninstruction behaves as a DC CGDVAP.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "CGVAP": {
        "long_name": "Data, Allocation Tag or unified Cache line Clean of Allocation Tags by VA to PoP",
        "purpose": "Clean Allocation Tags in data cache by address to Point of Persistence.\n\nIf the memory system does not identify a Point of Persistence, then this\ninstruction behaves as a DC CGVAC.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "CIGDSW": {
        "long_name": "Data, Allocation Tag or unified Cache line Clean and Invalidate of Data and Allocation Tags by Set/Way",
        "purpose": "Clean and Invalidate data and Allocation Tags in data cache by set/way.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "CIGDVAC": {
        "long_name": "Data, Allocation Tag or unified Cache line Clean and Invalidate of Data and Allocation Tags by VA to PoC",
        "purpose": "Clean and Invalidate data and Allocation Tags in data cache by address to Point\nof Coherency.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "CIGSW": {
        "long_name": "Data, Allocation Tag or unified Cache line Clean and Invalidate of Allocation Tags by Set/Way",
        "purpose": "Clean and Invalidate Allocation Tags in data cache by set/way.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "CIGVAC": {
        "long_name": "Data, Allocation Tag or unified Cache line Clean and Invalidate of Allocation Tags by VA to PoC",
        "purpose": "Clean and Invalidate Allocation Tags in data cache by address to Point of\nCoherency.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "CISW": {
        "long_name": "Data or unified Cache line Clean and Invalidate by Set/Way",
        "purpose": "Clean and Invalidate data cache by set/way.\n\nWhen ARMv8.5-MemTag is implemented, this instruction might clean and invalidate\nAllocation Tags from caches.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "CIVAC": {
        "long_name": "Data or unified Cache line Clean and Invalidate by VA to PoC",
        "purpose": "Clean and Invalidate data cache by address to Point of Coherency.\n\nWhen ARMv8.5-MemTag is implemented, this instruction might clean and invalidate\nAllocation Tags from caches.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "CSW": {
        "long_name": "Data or unified Cache line Clean by Set/Way",
        "purpose": "Clean data cache by set/way.\n\nWhen ARMv8.5-MemTag is implemented, this instruction might clean Allocation Tags\nfrom caches.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "CVAC": {
        "long_name": "Data or unified Cache line Clean by VA to PoC",
        "purpose": "Clean data cache by address to Point of Coherency.\n\nWhen ARMv8.5-MemTag is implemented, this instruction might clean Allocation Tags\nfrom caches.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "CVADP": {
        "long_name": "Data or unified Cache line Clean by VA to PoDP",
        "purpose": "Clean data cache by address to Point of Deep Persistence.\n\nIf the memory system does not identify a Point of Deep Persistence, then this\ninstruction behaves as a DC CVAP.\n\nWhen ARMv8.5-MemTag is implemented, this instruction might clean Allocation Tags\nfrom caches.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "CVAP": {
        "long_name": "Data or unified Cache line Clean by VA to PoP",
        "purpose": "Clean data cache by address to Point of Persistence.\n\nIf the memory system does not identify a Point of Persistence, then this\ninstruction behaves as a DC CVAC.\n\nWhen ARMv8.5-MemTag is implemented, this instruction might clean Allocation Tags\nfrom caches.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "CVAU": {
        "long_name": "Data or unified Cache line Clean by VA to PoU",
        "purpose": "Clean data cache by address to Point of Unification.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "GVA": {
        "long_name": "Data Cache set Allocation Tag by VA",
        "purpose": "Write a value to the Allocation Tags of a naturally aligned block of N bytes,\nwhere the size of N is identified in DCZID_EL0. The Allocation Tag used is\ndetermined by the input address.\n\nbits [0:63] - Virtual address to use. There is no alignment restriction on the\n              address within the block of N bytes that is used."
      },
      "GZVA": {
        "long_name": "Data Cache set Allocation Tags and Zero by VA",
        "purpose": "Zero data and write a value to the Allocation Tags of a naturally aligned block\nof N bytes, where the size of N is identified in DCZID_EL0.  The Allocation Tag\nused is determined by the input address.\n\nbits [0:63] - Virtual address to use. There is no alignment restriction on the\n              address within the block of N bytes that is used."
      },
      "IALLU": {
        "long_name": "Instruction Cache Invalidate All to PoU",
        "purpose": "Invalidate all instruction caches to Point of Unification."
      },
      "IALLUIS": {
        "long_name": "Instruction Cache Invalidate All to PoU, Inner Shareable",
        "purpose": "Invalidate all instruction caches in Inner Shareable domain to Point of\nUnification."
      },
      "IGDSW": {
        "long_name": "Data, Allocation Tag or unified Cache line Invalidate of Data and Allocation Tags by Set/Way",
        "purpose": "Invalidate data and Allocation Tags in data cache by set/way.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "IGDVAC": {
        "long_name": "Data, Allocation Tag or unified Cache line Invalidate of Allocation Tags by VA to PoC",
        "purpose": "Invalidate data and Allocation Tags in data cache by address to Point of\nCoherency.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "IGSW": {
        "long_name": "Data, Allocation Tag or unified Cache line Invalidate of Allocation Tags by Set/Way",
        "purpose": "Invalidate Allocation Tags in data cache by set/way.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "IGVAC": {
        "long_name": "Data, Allocation Tag or unified Cache line Invalidate of Allocation Tags by VA to PoC",
        "purpose": "Invalidate Allocation Tags in data cache by address to Point of Coherency.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "IPAS2E1": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2, EL1",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 2 only translation table entry, from any level of the\ntranslation table walk.\n  - One of the following applies:\n    - SCR_EL3.NS==1 and the entry would be required to translate the specified\nIPA using the Non-secure EL1&0 translation regime.\n    - SCR_EL3.NS==0 and the entry would be required to translate the specified\nIPA using the Secure EL1&0 translation regime.\n  - The entry would be used with the current VMID.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nNS, bit [63]             - Not Secure.\nTTL, bits [44:47]        - Translation Table Level.\nIPA[51:48], bits [36:39] - Extension to IPA[47:12].\nIPA[47:12], bits [0:35]  - Bits[47:12] of the intermediate physical address to\n                           match."
      },
      "IPAS2E1IS": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2, EL1, Inner Shareable",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 2 only translation table entry, from any level of the\ntranslation table walk.\n  - One of the following applies:\n    - SCR_EL3.NS==1 and the entry would be required to translate the specified\nIPA using the Non-secure EL1&0 translation regime.\n    - SCR_EL3.NS==0 and the entry would be required to translate the specified\nIPA using the Secure EL1&0 translation regime.\n  - The entry would be used with the current VMID.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nNS, bit [63]             - Not Secure.\nTTL, bits [44:47]        - Translation Table Level.\nIPA[51:48], bits [36:39] - Extension to IPA[47:12].\nIPA[47:12], bits [0:35]  - Bits[47:12] of the intermediate physical address to\n                           match."
      },
      "IPAS2E1OS": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2, EL1, Outer Shareable",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 2 only translation table entry, from any level of the\ntranslation table walk.\n  - One of the following applies:\n    - SCR_EL3.NS==1 and the entry would be required to translate the specified\nIPA using the Non-secure EL1&0 translation regime.\n    - SCR_EL3.NS==0 and the entry would be required to translate the specified\nIPA using the Secure EL1&0 translation regime.\n  - The entry would be used with the current VMID.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nNS, bit [63]             - Not Secure.\nTTL, bits [44:47]        - Translation Table Level.\nIPA[51:48], bits [36:39] - Extension to IPA[47:12].\nIPA[47:12], bits [0:35]  - Bits[47:12] of the intermediate physical address to\n                           match."
      },
      "IPAS2LE1": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, EL1",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 2 only translation table entry, from the final level of\nthe translation table walk.\n  - One of the following applies:\n    - SCR_EL3.NS==1 and the entry would be required to translate the specified\nIPA using the Non-secure EL1&0 translation regime.\n    - SCR_EL3.NS==0 and the entry would be required to translate the specified\nIPA using the Secure EL1&0 translation regime.\n  - The entry would be used with the current VMID.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nNS, bit [63]             - Not Secure.\nTTL, bits [44:47]        - Translation Table Level.\nIPA[51:48], bits [36:39] - Extension to IPA[47:12].\nIPA[47:12], bits [0:35]  - Bits[47:12] of the intermediate physical address to\n                           match."
      },
      "IPAS2LE1IS": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, EL1, Inner Shareable",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 2 only translation table entry, from the final level of\nthe translation table walk.\n  - One of the following applies:\n    - SCR_EL3.NS==1 and the entry would be required to translate the specified\nIPA using the Non-secure EL1&0 translation regime.\n    - SCR_EL3.NS==0 and the entry would be required to translate the specified\nIPA using the Secure EL1&0 translation regime.\n  - The entry would be used with the current VMID.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nNS, bit [63]             - Not Secure.\nTTL, bits [44:47]        - Translation Table Level.\nIPA[51:48], bits [36:39] - Extension to IPA[47:12].\nIPA[47:12], bits [0:35]  - Bits[47:12] of the intermediate physical address to\n                           match."
      },
      "IPAS2LE1OS": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, EL1, Outer Shareable",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 2 only translation table entry, from the final level of\nthe translation table walk.\n  - One of the following applies:\n    - SCR_EL3.NS==1 and the entry would be required to translate the specified\nIPA using the Non-secure EL1&0 translation regime.\n    - SCR_EL3.NS==0 and the entry would be required to translate the specified\nIPA using the Secure EL1&0 translation regime.\n  - The entry would be used with the current VMID.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nNS, bit [63]             - Not Secure.\nTTL, bits [44:47]        - Translation Table Level.\nIPA[51:48], bits [36:39] - Extension to IPA[47:12].\nIPA[47:12], bits [0:35]  - Bits[47:12] of the intermediate physical address to\n                           match."
      },
      "ISW": {
        "long_name": "Data or unified Cache line Invalidate by Set/Way",
        "purpose": "Invalidate data cache by set/way.\n\nWhen ARMv8.5-MemTag is implemented, this instruction might invalidate Allocation\nTags from caches. When it invalidates Allocation Tags from caches, it also\ncleans them.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "IVAC": {
        "long_name": "Data or unified Cache line Invalidate by VA to PoC",
        "purpose": "Invalidate data cache by address to Point of Coherency.\n\nWhen ARMv8.5-MemTag is implemented, this instruction might invalidate Allocation\nTags from caches. When it invalidates Allocation Tags from caches, it also\ncleans them.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "IVAU": {
        "long_name": "Instruction Cache line Invalidate by VA to PoU",
        "purpose": "Invalidate instruction cache by address to Point of Unification.\n\nbits [0:63] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "RCTX": {
        "long_name": "Data Value Prediction Restriction by Context",
        "purpose": "Data Value Prediction Restriction by Context applies to all Data Value\nPrediction Resources that predict execution based on information gathered within\nthe target execution context or contexts.\n\nWhen this instruction is complete and synchronized, data value prediction does\nnot permit later speculative execution within the target execution context to be\nobservable through side channels.\n\nThis instruction is guaranteed to be complete following a DSB that covers both\nread and write behavior on the same PE as executed the original restriction\ninstruction, and a subsequent context synchronization event is required to\nensure that the effect of the completion of the instructions is synchronized to\nthe current execution.\n\nThis instruction does not require the invalidation of prediction structures so\nlong as the behavior described for completion of this instruction is met by the\nimplementation.On some implementations the instruction is likely to take a\nsignificant number of cycles to execute. This instruction is expected to be used\nvery rarely, such as on the roll-over of an ASID or VMID, but should not be used\non every context switch.\n\nGVMID, bit [48]    - Execution of this instruction applies to all VMIDs or a\n                     specified VMID.\nVMID, bits [32:47] - Only applies when bit[48] is 0 and one of.\nNS, bit [26]       - Security State.\nEL, bits [24:25]   - Exception Level\nGASID, bit [16]    - Execution of this instruction applies to all ASIDs or a\n                     specified ASID.\nASID, bits [0:15]  - Only applies for an EL0 context and when bit[16] is 0."
      },
      "RIPAS2E1": {
        "long_name": "TLB Range Invalidate by Intermediate Physical Address, Stage 2, EL1",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 2 only translation table entry, from any level of the\ntranslation table walk.\n  - One of the following applies:\n    - SCR_EL3.NS==1 and the entry would be required to translate the specified\nIPA using the Non-secure EL1&0 translation regime.\n    - SCR_EL3.NS==0 and the entry would be required to translate the specified\nIPA using the Secure EL1&0 translation regime.\n  - The entry would be used with the current VMID.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nNS, bit [63]          - Not Secure.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RIPAS2E1IS": {
        "long_name": "TLB Range Invalidate by Intermediate Physical Address, Stage 2, EL1, Inner Shareable",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 2 only translation table entry, from any level of the\ntranslation table walk.\n  - One of the following applies:\n    - SCR_EL3.NS==1 and the entry would be required to translate the specified\nIPA using the Non-secure EL1&0 translation regime.\n    - SCR_EL3.NS==0 and the entry would be required to translate the specified\nIPA using the Secure EL1&0 translation regime.\n  - The entry would be used with the current VMID.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nNS, bit [63]          - Not Secure.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RIPAS2E1OS": {
        "long_name": "TLB Range Invalidate by Intermediate Physical Address, Stage 2, EL1, Outer Shareable",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 2 only translation table entry, from any level of the\ntranslation table walk.\n  - One of the following applies:\n    - SCR_EL3.NS==1 and the entry would be required to translate the specified\nIPA using the Non-secure EL1&0 translation regime.\n    - SCR_EL3.NS==0 and the entry would be required to translate the specified\nIPA using the Secure EL1&0 translation regime.\n  - The entry would be used with the current VMID.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nNS, bit [63]          - Not Secure.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RIPAS2LE1": {
        "long_name": "TLB Range Invalidate by Intermediate Physical Address, Stage 2, Last level, EL1",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 2 only translation table entry, from the final level of\nthe translation table walk.\n  - One of the following applies:\n    - SCR_EL3.NS==1 and the entry would be required to translate the specified\nIPA using the Non-secure EL1&0 translation regime.\n    - SCR_EL3.NS==0 and the entry would be required to translate the specified\nIPA using the Secure EL1&0 translation regime.\n  - The entry would be used with the current VMID.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation only applies to the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nNS, bit [63]          - Not Secure.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RIPAS2LE1IS": {
        "long_name": "TLB Range Invalidate by Intermediate Physical Address, Stage 2, Last level, EL1, Inner Shareable",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 2 only translation table entry, from the final level of\nthe translation table walk.\n  - One of the following applies:\n    - SCR_EL3.NS==1 and the entry would be required to translate the specified\nIPA using the Non-secure EL1&0 translation regime.\n    - SCR_EL3.NS==0 and the entry would be required to translate the specified\nIPA using the Secure EL1&0 translation regime.\n  - The entry would be used with the current VMID.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nNS, bit [63]          - Not Secure.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RIPAS2LE1OS": {
        "long_name": "TLB Range Invalidate by Intermediate Physical Address, Stage 2, Last level, EL1, Outer Shareable",
        "purpose": "If EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 2 only translation table entry, from any level of the\ntranslation table walk.\n  - One of the following applies:\n    - SCR_EL3.NS==1 and the entry would be required to translate the specified\nIPA using the Non-secure EL1&0 translation regime.\n    - SCR_EL3.NS==0 and the entry would be required to translate the specified\nIPA using the Secure EL1&0 translation regime.\n  - The entry would be used with the current VMID.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nNS, bit [63]          - Not Secure.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAAE1": {
        "long_name": "TLB Range Invalidate by VA, All ASID, EL1",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to the PE that executes this System instruction.\n\nFor the EL1&0 and EL2&0 translation regimes, the invalidation applies to both:\n  - Global entries.\n  - Non-global entries with any ASID.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAAE1IS": {
        "long_name": "TLB Range Invalidate by VA, All ASID, EL1, Inner Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.For the EL1&0 and EL2&0 translation regimes, the\ninvalidation applies to both:\n  - Global entries.\n  - Non-global entries with any ASID.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAAE1OS": {
        "long_name": "TLB Range Invalidate by VA, All ASID, EL1, Outer Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.For the EL1&0 and EL2&0 translation regimes, the\ninvalidation applies to both:\n  - Global entries.\n  - Non-global entries with any ASID.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAALE1": {
        "long_name": "TLB Range Invalidate by VA, All ASID, Last level, EL1",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to the PE that executes this System instruction.\n\nFor the EL1&0 and EL2&0 translation regimes, the invalidation applies to both:\n  - Global entries.\n  - Non-global entries with any ASID.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAALE1IS": {
        "long_name": "TLB Range Invalidate by VA, All ASID, Last Level, EL1, Inner Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.For the EL1&0 and EL2&0 translation regimes, the\ninvalidation applies to both:\n  - Global entries.\n  - Non-global entries with any ASID.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAALE1OS": {
        "long_name": "TLB Range Invalidate by VA, All ASID, Last Level, EL1, Outer Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.For the EL1&0 and EL2&0 translation regimes, the\ninvalidation applies to both:\n  - Global entries.\n  - Non-global entries with any ASID.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAE1": {
        "long_name": "TLB Range Invalidate by VA, EL1",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nASID, bits [48:63]    - ASID value to match.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAE1IS": {
        "long_name": "TLB Range Invalidate by VA, EL1, Inner Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nASID, bits [48:63]    - ASID value to match.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAE1OS": {
        "long_name": "TLB Range Invalidate by VA, EL1, Outer Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nASID, bits [48:63]    - ASID value to match.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAE2": {
        "long_name": "TLB Range Invalidate by VA, EL2",
        "purpose": "When EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA in the specified range\ndetermined by the formula [BaseADDR <= VA < BaseADDR + ((NUM +1)*2^(5*SCALE +1)\n* Translation_Granule_Size)], using the EL2 or EL2&0 translation regime.\n  - If HCR_EL2.E2H == 0, the entry is from any level of the translation table\nwalk.\n  - If HCR_EL2.E2H == 1, one of the following applies:\n    - The entry is from a level of the translation table walk above the final\nlevel and matches the specified ASID.\n    - The entry is a global entry from the final level of the translation table\nwalk.\n    - The entry is a non-global entry from the final level of the translation\ntable walk and matches the specified ASID.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nASID, bits [48:63]    - ASID value to match.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAE2IS": {
        "long_name": "TLB Range Invalidate by VA, EL2, Inner Shareable",
        "purpose": "When EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA in the specified range\ndetermined by the formula [BaseADDR <= VA < BaseADDR + ((NUM +1)*2^(5*SCALE +1)\n* Translation_Granule_Size)], using the EL2 or EL2&0 translation regime.\n  - If HCR_EL2.E2H == 0, the entry is from any level of the translation table\nwalk.\n  - If HCR_EL2.E2H == 1, one of the following applies:\n    - The entry is from a level of the translation table walk above the final\nlevel and matches the specified ASID.\n    - The entry is a global entry from the final level of the translation table\nwalk.\n    - The entry is a non-global entry from the final level of the translation\ntable walk and matches the specified ASID.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nASID, bits [48:63]    - ASID value to match.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAE2OS": {
        "long_name": "TLB Range Invalidate by VA, EL2, Outer Shareable",
        "purpose": "When EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA in the specified range\ndetermined by the formula [BaseADDR <= VA < BaseADDR + ((NUM +1)*2^(5*SCALE +1)\n* Translation_Granule_Size)], using the EL2 or EL2&0 translation regime.\n  - If HCR_EL2.E2H == 0, the entry is from any level of the translation table\nwalk.\n  - If HCR_EL2.E2H == 1, one of the following applies:\n    - The entry is from a level of the translation table walk above the final\nlevel and matches the specified ASID.\n    - The entry is a global entry from the final level of the translation table\nwalk.\n    - The entry is a non-global entry from the final level of the translation\ntable walk and matches the specified ASID.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nASID, bits [48:63]    - ASID value to match.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAE3": {
        "long_name": "TLB Range Invalidate by VA, EL3",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified VA using the EL3\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAE3IS": {
        "long_name": "TLB Range Invalidate by VA, EL3, Inner Shareable",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified VA using the EL3\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVAE3OS": {
        "long_name": "TLB Range Invalidate by VA, EL3, Outer Shareable",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified VA using the EL3\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVALE1": {
        "long_name": "TLB Range Invalidate by VA, Last level, EL1",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA, and one of the\nfollowing applies:\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nFor more information about the architectural requirements for this System\ninstruction see 'Invalidation of TLB entries from stage 2 translations' in the\nArm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture profile.\n\nASID, bits [48:63]    - ASID value to match.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVALE1IS": {
        "long_name": "TLB Range Invalidate by VA, Last level, EL1, Inner Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA, and one of the\nfollowing applies:\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nASID, bits [48:63]    - ASID value to match.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVALE1OS": {
        "long_name": "TLB Range Invalidate by VA, Last level, EL1, Outer Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA, and one of the\nfollowing applies:\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nASID, bits [48:63]    - ASID value to match.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVALE2": {
        "long_name": "TLB Range Invalidate by VA, Last level, EL2",
        "purpose": "When EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA in the specified range\ndetermined by the formula [BaseADDR <= VA < BaseADDR + ((NUM +1)*2^(5*SCALE +1)\n* Translation_Granule_Size)] using the EL2 or  EL2&0 translation regime.\n  - If HCR_EL2.E2H == 0, the entry is from the final level of the translation\ntable walk.\n  - If HCR_EL2.E2H == 1, one of the following applies:\n    - The entry is a global entry from the final level of translation table\nwalk.\n    - The entry is a non-global entry from the final level of the translation\ntable walk and matches the specified ASID.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nASID, bits [48:63]    - ASID value to match.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVALE2IS": {
        "long_name": "TLB Range Invalidate by VA, Last level, EL2, Inner Shareable",
        "purpose": "When EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA in the specified range\ndetermined by the formula [BaseADDR <= VA < BaseADDR + ((NUM +1)*2^(5*SCALE +1)\n* Translation_Granule_Size)] using the EL2 or  EL2&0 translation regime.\n  - If HCR_EL2.E2H == 0, the entry is from the final level of the translation\ntable walk.\n  - If HCR_EL2.E2H == 1, one of the following applies:\n    - The entry is a global entry from the final level of translation table\nwalk.\n    - The entry is a non-global entry from the final level of the translation\ntable walk and matches the specified ASID.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nASID, bits [48:63]    - ASID value to match.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVALE2OS": {
        "long_name": "TLB Range Invalidate by VA, Last level, EL2, Outer Shareable",
        "purpose": "When EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA in the specified range\ndetermined by the formula [BaseADDR <= VA < BaseADDR + ((NUM +1)*2^(5*SCALE +1)\n* Translation_Granule_Size)] using the EL2 or  EL2&0 translation regime.\n  - If HCR_EL2.E2H == 0, the entry is from the final level of the translation\ntable walk.\n  - If HCR_EL2.E2H == 1, one of the following applies:\n    - The entry is a global entry from the final level of translation table\nwalk.\n    - The entry is a non-global entry from the final level of the translation\ntable walk and matches the specified ASID.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nASID, bits [48:63]    - ASID value to match.\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVALE3": {
        "long_name": "TLB Range Invalidate by VA, Last level, EL3",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified VA using the EL3\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVALE3IS": {
        "long_name": "TLB Range Invalidate by VA, Last level, EL3, Inner Shareable",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified VA using the EL3\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "RVALE3OS": {
        "long_name": "TLB Range Invalidate by VA, Last level, EL3, Outer Shareable",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified VA using the EL3\ntranslation regime.\n  - The entry is within the address range determined by the formula [BaseADDR <=\nVA < BaseADDR + ((NUM +1)*2^(5*SCALE +1) * Translation_Granule_Size)].\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nThe range of addresses invalidated is unpredictable when:\n\n  - For the 4K translation granule:\n    - If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.\n    - If TTL==10 and BaseADDR[20:12] is not equal to 000000000.\n  - For the 16K translation granule:\n    - If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.\n  - For the 64K translation granule:\n    - If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.\n    - If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.\n\nTG, bits [46:47]      - Translation granule size.\nSCALE, bits [44:45]   - The exponent element of the calculation that is used to\n                        produce the upper range.\nNUM, bits [39:43]     - The base element of the calculation that is used to\n                        produce the upper range.\nTTL, bits [37:38]     - TTL Level hint.\nBaseADDR, bits [0:36] - The starting address for the range of the maintenance\n                        instruction."
      },
      "S12E0R": {
        "long_name": "Address Translate Stages 1 and 2 EL0 Read",
        "purpose": "Performs stage 1 and 2 address translations from EL0, with permissions as if\nreading from the given virtual address from EL0, using the following translation\nregime:\n\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the EL1&0 translation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the EL2&0 translation regime.\n  - Otherwise, the EL1&0 translation regime.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S12E0W": {
        "long_name": "Address Translate Stages 1 and 2 EL0 Write",
        "purpose": "Performs stage 1 and 2 address translations from EL0, with permissions as if\nwriting to the given virtual address from EL0, using the following translation\nregime:\n\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the EL1&0 translation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the EL2&0 translation regime.\n  - Otherwise, the EL1&0 translation regime.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S12E1R": {
        "long_name": "Address Translate Stages 1 and 2 EL1 Read",
        "purpose": "Performs stage 1 and 2 address translation, with permissions as if reading from\nthe given virtual address from EL1, or from EL2 if the Effective value of\nHCR_EL2.{E2H, TGE} is {1, 1}, using the following translation regime:\n\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the EL1&0 translation regime,\naccessed from EL1.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the EL2&0 translation regime, accessed\nfrom EL2.\n  - Otherwise, the EL1&0 translation regime, accessed from EL1.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S12E1W": {
        "long_name": "Address Translate Stages 1 and 2 EL1 Write",
        "purpose": "Performs stage 1 and 2 address translation, with permissions as if writing to\nthe given virtual address from EL1, or from EL2 if the Effective value of\nHCR_EL2.{E2H, TGE} is {1, 1}, using the following translation regime:\n\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the EL1&0 translation regime,\naccessed from EL1.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the EL2&0 translation regime, accessed\nfrom EL2.\n  - Otherwise, the EL1&0 translation regime, accessed from EL1.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S1E0R": {
        "long_name": "Address Translate Stage 1 EL0 Read",
        "purpose": "Performs stage 1 address translation from EL0, with permissions as if reading\nfrom the given virtual address from EL0, using the following translation regime:\n\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the EL1&0 translation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the EL2&0 translation regime.\n  - Otherwise, the EL1&0 translation regime.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S1E0W": {
        "long_name": "Address Translate Stage 1 EL0 Write",
        "purpose": "Performs stage 1 address translation from EL0, with permissions as if writing to\nthe given virtual address from EL0, using the following translation regime:\n\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the EL1&0 translation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the EL2&0 translation regime.\n  - Otherwise, the EL1&0 translation regime.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S1E1R": {
        "long_name": "Address Translate Stage 1 EL1 Read",
        "purpose": "Performs stage 1 address translation, with permissions as if reading from the\ngiven virtual address from EL1, or from EL2 if the Effective value of\nHCR_EL2.{E2H, TGE} is {1, 1}, using the following translation regime:\n\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the EL1&0 translation regime,\naccessed from EL1.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the EL2&0 translation regime, accessed\nfrom EL2.\n  - Otherwise, the EL1&0 translation regime, accessed from EL1.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S1E1RP": {
        "long_name": "Address Translate Stage 1 EL1 Read PAN",
        "purpose": "Performs a stage 1 address translation, where the value of PSTATE.PAN determines\nif a read from a location will generate a permission fault for a privileged\naccess, using the following translation regime:\n\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the EL1&0 translation regime,\naccessed from EL1.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the EL2&0 translation regime, accessed\nfrom EL2.\n  - Otherwise, the EL1&0 translation regime, accessed from EL1.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S1E1W": {
        "long_name": "Address Translate Stage 1 EL1 Write",
        "purpose": "Performs stage 1 address translation, with permissions as if writing to the\ngiven virtual address from EL1, or from EL2 if the Effective value of\nHCR_EL2.{E2H, TGE} is {1, 1}, using the following translation regime:\n\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the EL1&0 translation regime,\naccessed from EL1.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the EL2&0 translation regime, accessed\nfrom EL2.\n  - Otherwise, the EL1&0 translation regime, accessed from EL1.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S1E1WP": {
        "long_name": "Address Translate Stage 1 EL1 Write PAN",
        "purpose": "Performs a stage 1 address translation, where the value of PSTATE.PAN determines\nif a write to a location will generate a permission fault for a privileged\naccess, using the following translation regime:\n\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the EL1&0 translation regime,\naccessed from EL1.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the EL2&0 translation regime, accessed\nfrom EL2.\n  - Otherwise, the EL1&0 translation regime, accessed from EL1.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S1E2R": {
        "long_name": "Address Translate Stage 1 EL2 Read",
        "purpose": "Performs stage 1 address translation as defined for EL2, with permissions as if\nreading from the given virtual address.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S1E2W": {
        "long_name": "Address Translate Stage 1 EL2 Write",
        "purpose": "Performs stage 1 address translation as defined for EL2, with permissions as if\nwriting to the given virtual address.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S1E3R": {
        "long_name": "Address Translate Stage 1 EL3 Read",
        "purpose": "Performs stage 1 address translation as defined for EL3, with permissions as if\nreading from the given virtual address.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S1E3W": {
        "long_name": "Address Translate Stage 1 EL3 Write",
        "purpose": "Performs stage 1 address translation as defined for EL3, with permissions as if\nwriting to the given virtual address.\n\nbits [0:63] - Input address for translation. The resulting address can be read\n              from the PAR_EL1. If the address translation instructions are\n              targeting a translation regime that is using AArch32, and so has a\n              VA of only 32 bits, then VA[63:32] is res0."
      },
      "S1_<op1>_<Cn>_<Cm>_<op2>": {
        "long_name": "IMPLEMENTATION DEFINED maintenance instructions",
        "purpose": "This area of the System instruction encoding space is reserved for\nimplementation defined System instructions."
      },
      "VAAE1": {
        "long_name": "TLB Invalidate by VA, All ASID, EL1",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nFor the EL1&0 and EL2&0 translation regimes, the invalidation applies to both\nglobal entries, and non-global entries with any ASID.\n\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAAE1IS": {
        "long_name": "TLB Invalidate by VA, All ASID, EL1, Inner Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nFrom Armv8.4, when a TLB maintenance instruction is generated to the Secure\nEL1&0 translation regime and is defined to pass a VMID argument, or would be\ndefined to pass a VMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.For the EL1&0 and EL2&0 translation regimes, the\ninvalidation applies to both global entries, and non-global entries with any\nASID.\n\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAAE1OS": {
        "long_name": "TLB Invalidate by VA, All ASID, EL1, Outer Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.For the EL1&0 and EL2&0 translation regimes, the\ninvalidation applies to both global entries, and non-global entries with any\nASID.\n\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAALE1": {
        "long_name": "TLB Invalidate by VA, All ASID, Last level, EL1",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nFor the EL1&0 and EL2&0 translation regimes, the invalidation applies to both\nglobal entries, and non-global entries with any ASID.\n\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAALE1IS": {
        "long_name": "TLB Invalidate by VA, All ASID, Last Level, EL1, Inner Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nFrom Armv8.4, when a TLB maintenance instruction is generated to the Secure\nEL1&0 translation regime and is defined to pass a VMID argument, or would be\ndefined to pass a VMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.For the EL1&0 and EL2&0 translation regimes, the\ninvalidation applies to both global entries, and non-global entries with any\nASID.\n\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAALE1OS": {
        "long_name": "TLB Invalidate by VA, All ASID, Last Level, EL1, Outer Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.For the EL1&0 and EL2&0 translation regimes, the\ninvalidation applies to both global entries, and non-global entries with any\nASID.\n\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAE1": {
        "long_name": "TLB Invalidate by VA, EL1",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nASID, bits [48:63]     - ASID value to match.\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAE1IS": {
        "long_name": "TLB Invalidate by VA, EL1, Inner Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nFrom Armv8.4, when a TLB maintenance instruction is generated to the Secure\nEL1&0 translation regime and is defined to pass a VMID argument, or would be\ndefined to pass a VMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.\n\nASID, bits [48:63]     - ASID value to match.\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAE1OS": {
        "long_name": "TLB Invalidate by VA, EL1, Outer Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.\n\nASID, bits [48:63]     - ASID value to match.\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAE2": {
        "long_name": "TLB Invalidate by VA, EL2",
        "purpose": "When EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be required to translate the specified VA using the EL2 or\nthe EL2&0 translation regime.\n  - If HCR_EL2.E2H == 0, the entry is from any level of the translation table\nwalk.\n  - If HCR_EL2.E2H == 1 one of the following applies:\n    - The entry is from a level of the translation table walk above the final\nlevel and matches the specified ASID.\n    - The entry is a global entry from the final level of the translation table\nwalk.\n    - The entry is a non-global entry from the final level of the translation\ntable walk and matches the specified ASID.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nASID, bits [48:63]     - ASID value to match.\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAE2IS": {
        "long_name": "TLB Invalidate by VA, EL2, Inner Shareable",
        "purpose": "When EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be required to translate the specified VA using the EL2 or\nthe EL2&0 translation regime.\n  - If HCR_EL2.E2H == 0, the entry is from any level of the translation table\nwalk.\n  - If HCR_EL2.E2H == 1 one of the following applies:\n    - The entry is from a level of the translation table walk above the final\nlevel and matches the specified ASID.\n    - The entry is a global entry from the final level of the translation table\nwalk.\n    - The entry is a non-global entry from the final level of the translation\ntable walk and matches the specified ASID.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nASID, bits [48:63]     - ASID value to match.\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAE2OS": {
        "long_name": "TLB Invalidate by VA, EL2, Outer Shareable",
        "purpose": "When EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be required to translate the specified VA using the EL2 or\nthe EL2&0 translation regime.\n  - If HCR_EL2.E2H == 0, the entry is from any level of the translation table\nwalk.\n  - If HCR_EL2.E2H == 1 one of the following applies:\n    - The entry is from a level of the translation table walk above the final\nlevel and matches the specified ASID.\n    - The entry is a global entry from the final level of the translation table\nwalk.\n    - The entry is a non-global entry from the final level of the translation\ntable walk and matches the specified ASID.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nASID, bits [48:63]     - ASID value to match.\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAE3": {
        "long_name": "TLB Invalidate by VA, EL3",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified VA using the EL3\ntranslation regime.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAE3IS": {
        "long_name": "TLB Invalidate by VA, EL3, Inner Shareable",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified VA using the EL3\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VAE3OS": {
        "long_name": "TLB Invalidate by VA, EL3, Outer Shareable",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified VA using the EL3\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VALE1": {
        "long_name": "TLB Invalidate by VA, Last level, EL1",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA, and one of the\nfollowing applies:\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nASID, bits [48:63]     - ASID value to match.\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VALE1IS": {
        "long_name": "TLB Invalidate by VA, Last level, EL1, Inner Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA, and one of the\nfollowing applies:\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nFrom Armv8.4, when a TLB maintenance instruction is generated to the Secure\nEL1&0 translation regime and is defined to pass a VMID argument, or would be\ndefined to pass a VMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.\n\nASID, bits [48:63]     - ASID value to match.\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VALE1OS": {
        "long_name": "TLB Invalidate by VA, Last level, EL1, Outer Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA, and one of the\nfollowing applies:\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or disabled in the current Security state, the\nentry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.\n\nASID, bits [48:63]     - ASID value to match.\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VALE2": {
        "long_name": "TLB Invalidate by VA, Last level, EL2",
        "purpose": "When EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA using the EL2 or EL2&0\ntranslation regime.\n  - If HCR_EL2.E2H == 0, the entry is from the final level of the translation\ntable walk.\n  - If HCR_EL2.E2H == 1, one of the following applies:\n    - The entry is a global entry from the final level of the translation table\nwalk.\n    - The entry is a non-global entry from the final level of translation table\nwalk that matches the specified ASID.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nASID, bits [48:63]     - ASID value to match.\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VALE2IS": {
        "long_name": "TLB Invalidate by VA, Last level, EL2, Inner Shareable",
        "purpose": "When EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA using the EL2 or EL2&0\ntranslation regime.\n  - If HCR_EL2.E2H == 0, the entry is from the final level of the translation\ntable walk.\n  - If HCR_EL2.E2H == 1, one of the following applies:\n    - The entry is a global entry from the final level of the translation table\nwalk.\n    - The entry is a non-global entry from the final level of translation table\nwalk that matches the specified ASID.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nASID, bits [48:63]     - ASID value to match.\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VALE2OS": {
        "long_name": "TLB Invalidate by VA, Last level, EL2, Outer Shareable",
        "purpose": "When EL2 is implemented and enabled in the current Security state, invalidates\ncached copies of translation table entries from TLBs that meet all the following\nrequirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified VA using the EL2 or EL2&0\ntranslation regime.\n  - If HCR_EL2.E2H == 0, the entry is from the final level of the translation\ntable walk.\n  - If HCR_EL2.E2H == 1, one of the following applies:\n    - The entry is a global entry from the final level of the translation table\nwalk.\n    - The entry is a non-global entry from the final level of translation table\nwalk that matches the specified ASID.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nASID, bits [48:63]     - ASID value to match.\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VALE3": {
        "long_name": "TLB Invalidate by VA, Last level, EL3",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - The entry would be used to translate the specified VA using the EL3\ntranslation regime.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VALE3IS": {
        "long_name": "TLB Invalidate by VA, Last level, EL3, Inner Shareable",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - The entry would be used to translate the specified VA using the EL3\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VALE3OS": {
        "long_name": "TLB Invalidate by VA, Last level, EL3, Outer Shareable",
        "purpose": "If EL3 is implemented, invalidates cached copies of translation table entries\nfrom TLBs that meet all the following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - The entry would be used to translate the specified VA using the EL3\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nTTL, bits [44:47]      - Translation Table Level.\nVA[55:12], bits [0:43] - Bits[55:12] of the virtual address to match."
      },
      "VMALLE1": {
        "long_name": "TLB Invalidate by VMID, All at stage 1, EL1",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nFor the EL1&0 translation regimes, the invalidation applies to both global\nentries, and non-global entries with any ASID."
      },
      "VMALLE1IS": {
        "long_name": "TLB Invalidate by VMID, All at stage 1, EL1, Inner Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nFrom Armv8.4, when a TLB maintenance instruction is generated to the Secure\nEL1&0 translation regime and is defined to pass a VMID argument, or would be\ndefined to pass a VMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.For the EL1&0 translation regimes, the invalidation\napplies to both global entries, and non-global entries with any ASID."
      },
      "VMALLE1OS": {
        "long_name": "TLB Invalidate by VMID, All at stage 1, EL1, Outer Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - When EL2 is implemented and enabled in the Security state described by the\ncurrent value of SCR_EL3.NS:\n    - If HCR_EL2.{E2H, TGE} is not {1, 1}, the entry would be used with the\ncurrent VMID and would be required to translate the specified VA using the EL1&0\ntranslation regime.\n    - If HCR_EL2.{E2H, TGE} is {1, 1}, the entry would be required to translate\nthe specified VA using the EL2&0 translation regime.\n  - When EL2 is not implemented or is disabled in the current Security state,\nthe entry would be required to translate the specified VA using the EL1&0\ntranslation regime.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.For the EL1&0 translation regimes, the invalidation\napplies to both global entries, and non-global entries with any ASID."
      },
      "VMALLS12E1": {
        "long_name": "TLB Invalidate by VMID, All at Stage 1 and 2, EL1",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 or stage 2 translation table entry, from any level of\nthe translation table walk.\n  - If SCR_EL3.NS is 0, then \n    - The entry would be required to translate an address using the Secure EL1&0\ntranslation regime.\n    - If ARMv8.4-SecEL2 is implemented and enabled, the entry would be used with\nthe current VMID.\n  - If SCR_EL3.NS is 1, then:\n    - The entry would be required to translate an address using the Non-secure\nEL1&0 translation regime.\n    - If Non-secure EL2 is implemented, the entry would be used with the current\nVMID.\n\nThe invalidation applies to the PE that executes this System instruction.\n\nFor the EL1&0 translation regimes, the invalidation applies to both global\nentries, and non-global entries with any ASID."
      },
      "VMALLS12E1IS": {
        "long_name": "TLB Invalidate by VMID, All at Stage 1 and 2, EL1, Inner Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 or stage 2 translation table entry, from any level of\nthe translation table walk.\n  - If SCR_EL3.NS is 0, then \n    - The entry would be required to translate an address using the Secure EL1&0\ntranslation regime.\n    - If ARMv8.4-SecEL2 is implemented and enabled, the entry would be used with\nthe current VMID.\n  - If SCR_EL3.NS is 1, then:\n    - The entry would be required to translate an address using the Non-secure\nEL1&0 translation regime.\n    - If Non-secure EL2 is implemented, the entry would be used with the current\nVMID.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this System instruction.\n\nFrom Armv8.4, when a TLB maintenance instruction is generated to the Secure\nEL1&0 translation regime and is defined to pass a VMID argument, or would be\ndefined to pass a VMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.For the EL1&0 translation regimes, the invalidation\napplies to both global entries, and non-global entries with any ASID."
      },
      "VMALLS12E1OS": {
        "long_name": "TLB Invalidate by VMID, All at Stage 1 and 2, EL1, Outer Shareable",
        "purpose": "Invalidates cached copies of translation table entries from TLBs that meet all\nthe following requirements:\n\n  - The entry is a stage 1 or stage 2 translation table entry, from any level of\nthe translation table walk.\n  - If SCR_EL3.NS is 0, then \n    - The entry would be required to translate an address using the Secure EL1&0\ntranslation regime.\n    - If ARMv8.4-SecEL2 is implemented and enabled, the entry would be used with\nthe current VMID.\n  - If SCR_EL3.NS is 1, then:\n    - The entry would be required to translate an address using the Non-secure\nEL1&0 translation regime.\n    - If Non-secure EL2 is implemented, the entry would be used with the current\nVMID.\n\nThe invalidation applies to all PEs in the same Outer Shareable shareability\ndomain as the PE that executes this System instruction.\n\nWhen a TLB maintenance instruction is generated to the Secure EL1&0 translation\nregime and is defined to pass a VMID argument, or would be defined to pass a\nVMID argument if SCR_EL3.EEL2==1, then:\n  - A PE with SCR_EL3.EEL2==1 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==0.\n  - A PE with SCR_EL3.EEL2==0 is not architecturally required to invalidate any\nentries in the Secure EL1&0 translation of a PE in the same required\nshareability domain with SCR_EL3.EEL2==1.\n  - A PE is architecturally required to invalidate all relevant entries in the\nSecure EL1&0 translation of a System MMU in the same required shareability\ndomain with a VMID of 0.For the EL1&0 translation regimes, the invalidation\napplies to both global entries, and non-global entries with any ASID."
      },
      "ZVA": {
        "long_name": "Data Cache Zero by VA",
        "purpose": "Zero data cache by address. Zeroes a naturally aligned block of N bytes, where\nthe size of N is identified in DCZID_EL0.\n\nbits [0:63] - Virtual address to use. There is no alignment restriction on the\n              address within the block of N bytes that is used."
      }
    },
    "registers": {
      "ACTLR_EL1": {
        "long_name": "Auxiliary Control Register (EL1)",
        "purpose": "Provides implementation defined configuration and control options for execution\nat EL1 and EL0.\n\nArm recommends the contents of this register have no effect on the PE when\nHCR_EL2.{E2H, TGE} is {1, 1}, and instead the configuration and control fields\nare provided by the ACTLR_EL2 register. This avoids the need for software to\nmanage the contents of these register when switching between a Guest OS and a\nHost OS."
      },
      "ACTLR_EL2": {
        "long_name": "Auxiliary Control Register (EL2)",
        "purpose": "Provides implementation defined configuration and control options for EL2.\n\nArm recommends the contents of this register are updated to apply to EL0 when\nHCR_EL2.{E2H, TGE} is {1, 1}, gaining configuration and control fields from the\nACTLR_EL1. This avoids the need for software to manage the contents of these\nregister when switching between a Guest OS and a Host OS."
      },
      "ACTLR_EL3": {
        "long_name": "Auxiliary Control Register (EL3)",
        "purpose": "Provides implementation defined configuration and control options for EL3."
      },
      "AFSR0_EL1": {
        "long_name": "Auxiliary Fault Status Register 0 (EL1)",
        "purpose": "Provides additional implementation defined fault status information for\nexceptions taken to EL1."
      },
      "AFSR0_EL2": {
        "long_name": "Auxiliary Fault Status Register 0 (EL2)",
        "purpose": "Provides additional implementation defined fault status information for\nexceptions taken to EL2."
      },
      "AFSR0_EL3": {
        "long_name": "Auxiliary Fault Status Register 0 (EL3)",
        "purpose": "Provides additional implementation defined fault status information for\nexceptions taken to EL3."
      },
      "AFSR1_EL1": {
        "long_name": "Auxiliary Fault Status Register 1 (EL1)",
        "purpose": "Provides additional implementation defined fault status information for\nexceptions taken to EL1."
      },
      "AFSR1_EL2": {
        "long_name": "Auxiliary Fault Status Register 1 (EL2)",
        "purpose": "Provides additional implementation defined fault status information for\nexceptions taken to EL2."
      },
      "AFSR1_EL3": {
        "long_name": "Auxiliary Fault Status Register 1 (EL3)",
        "purpose": "Provides additional implementation defined fault status information for\nexceptions taken to EL3."
      },
      "AIDR_EL1": {
        "long_name": "Auxiliary ID Register",
        "purpose": "Provides implementation defined identification information.\n\nThe value of this register must be interpreted in conjunction with the value of\nMIDR_EL1."
      },
      "AMAIR_EL1": {
        "long_name": "Auxiliary Memory Attribute Indirection Register (EL1)",
        "purpose": "Provides implementation defined memory attributes for the memory regions\nspecified by MAIR_EL1."
      },
      "AMAIR_EL2": {
        "long_name": "Auxiliary Memory Attribute Indirection Register (EL2)",
        "purpose": "Provides implementation defined memory attributes for the memory regions\nspecified by MAIR_EL2."
      },
      "AMAIR_EL3": {
        "long_name": "Auxiliary Memory Attribute Indirection Register (EL3)",
        "purpose": "Provides implementation defined memory attributes for the memory regions\nspecified by MAIR_EL3."
      },
      "AMCFGR_EL0": {
        "long_name": "Activity Monitors Configuration Register",
        "purpose": "Global configuration register for the activity monitors.\n\nProvides information on supported features, the number of counter groups\nimplemented, the total number of activity monitor event counters implemented,\nand the size of the counters. AMCFGR_EL0 is applicable to both the architected\nand the auxiliary counter groups.\n\nNCG, bits [28:31] - Defines the number of counter groups. The number of\n                    implemented counter groups is defined as [AMCFGR_EL0.NCG +\n                    1]. If the number of implemented auxiliary activity monitor\n                    event counters is zero, this field has a value of 0b0000.\n                    Otherwise, this field has a value of 0b0001.\nHDBG, bit [24]    - Halt-on-debug supported. From Armv8, this feature must be\n                    supported, and so this bit is 0b1.\n                        0b0 AMCR_EL0.HDBG is res0.\n                        0b1 AMCR_EL0.HDBG is read/write.\nSIZE, bits [8:13] - Defines the size of activity monitor event counters. The\n                    size of the activity monitor event counters implemented by\n                    the activity monitors Extension is defined as\n                    [AMCFGR_EL0.SIZE + 1]. From Armv8, the counters are 64-bit,\n                    and so this field is 0b111111. Software also uses this field\n                    to determine the spacing of counters in the memory-map. From\n                    Armv8, the counters are at doubleword-aligned addresses.\nN, bits [0:7]     - Defines the number of activity monitor event counters. The\n                    total number of counters implemented in all groups by the\n                    Activity Monitors Extension is defined as [AMCFGR_EL0.N +\n                    1]."
      },
      "AMCG1IDR_EL0": {
        "long_name": "Activity Monitors Counter Group 1 Identification Register",
        "purpose": "Defines which auxiliary counters are implemented, and which of them have a\ncorresponding virtual offset register, AMEVCNTVOFF1<n>_EL2 implemented.\n\nAMEVCNTOFF1<n>_EL2, bits [16:31] - Indicates which implemented auxiliary\n                                   counters have a corresponding virtual offset\n                                   register, AMEVCNTVOFF1<n>_EL2 implemented.\n                                       0b0 When read, mean that AMEVCNTR1<n>_EL0\n                                   does not have an offset, or is not\n                                   implemented.\n                                       0b1 When read, means the offset\n                                   AMEVCNTVOFF1<n>_EL2 is implemented for\n                                   AMEVCNTR1<n>_EL0.\nAMEVCNTR1<n>_EL0, bits [0:15]    - Indicates which auxiliary counters\n                                   AMEVCNTR1<n>_EL0 are implemented.\n                                       0b0 When read, means that\n                                   AMEVCNTR1<n>_EL0 is not implemented.\n                                       0b1 When read, means that\n                                   AMEVCNTR1<n>_EL0 is implemented."
      },
      "AMCGCR_EL0": {
        "long_name": "Activity Monitors Counter Group Configuration Register",
        "purpose": "Provides information on the number of activity monitor event counters\nimplemented within each counter group.\n\nCG1NC, bits [8:15] - Counter Group 1 Number of Counters. The number of counters\n                     in the auxiliary counter group. In AMUv1, the permitted\n                     range of values is 0x0 to 0x10.\nCG0NC, bits [0:7]  - Counter Group 0 Number of Counters. The number of counters\n                     in the architected counter group. In AMUv1, the value of\n                     this field is 0x4."
      },
      "AMCNTENCLR0_EL0": {
        "long_name": "Activity Monitors Count Enable Clear Register 0",
        "purpose": "Disable control bits for the architected activity monitors event counters,\nAMEVCNTR0<n>_EL0.\n\nP<n>, bits [0:15] - Activity monitor event counter disable bit for\n                    AMEVCNTR0<n>_EL0. Bits [31:16] are res0. Bits [15:N] are\n                    RAZ/WI. N is the value in AMCGCR_EL0.CG0NC. Possible values\n                    of each bit are:\n                        0b0 When read, means that AMEVCNTR0<n>_EL0 is disabled.\n                    When written, has no effect.\n                        0b1 When read, means that AMEVCNTR0<n>_EL0 is enabled.\n                    When written, disables AMEVCNTR0<n>_EL0."
      },
      "AMCNTENCLR1_EL0": {
        "long_name": "Activity Monitors Count Enable Clear Register 1",
        "purpose": "Disable control bits for the auxiliary activity monitors event counters,\nAMEVCNTR1<n>_EL0.\n\nP<n>, bits [0:15] - Activity monitor event counter disable bit for\n                    AMEVCNTR1<n>_EL0. Bits [31:16] are res0. Bits [15:N] are\n                    RAZ/WI. N is the value in AMCGCR_EL0.CG1NC. Possible values\n                    of each bit are:\n                        0b0 When read, means that AMEVCNTR1<n>_EL0 is disabled.\n                    When written, has no effect.\n                        0b1 When read, means that AMEVCNTR1<n>_EL0 is enabled.\n                    When written, disables AMEVCNTR1<n>_EL0."
      },
      "AMCNTENSET0_EL0": {
        "long_name": "Activity Monitors Count Enable Set Register 0",
        "purpose": "Enable control bits for the architected activity monitors event counters,\nAMEVCNTR0<n>_EL0.\n\nP<n>, bits [0:15] - Activity monitor event counter enable bit for\n                    AMEVCNTR0<n>_EL0. Bits [31:16] are res0. Bits [15:N] are\n                    RAZ/WI. N is the value in AMCGCR_EL0.CG0NC. Possible values\n                    of each bit are:\n                        0b0 When read, means that AMEVCNTR0<n>_EL0 is disabled.\n                    When written, has no effect.\n                        0b1 When read, means that AMEVCNTR0<n>_EL0 is enabled.\n                    When written, enables AMEVCNTR0<n>_EL0."
      },
      "AMCNTENSET1_EL0": {
        "long_name": "Activity Monitors Count Enable Set Register 1",
        "purpose": "Enable control bits for the auxiliary activity monitors event counters,\nAMEVCNTR1<n>_EL0.\n\nP<n>, bits [0:15] - Activity monitor event counter enable bit for\n                    AMEVCNTR1<n>_EL0. Bits [31:16] are res0. Bits [15:N] are\n                    RAZ/WI. N is the value in AMCGCR_EL0.CG1NC. Possible values\n                    of each bit are:\n                        0b0 When read, means that AMEVCNTR1<n>_EL0 is disabled.\n                    When written, has no effect.\n                        0b1 When read, means that AMEVCNTR1<n>_EL0 is enabled.\n                    When written, enables AMEVCNTR1<n>_EL0."
      },
      "AMCR_EL0": {
        "long_name": "Activity Monitors Control Register",
        "purpose": "Global control register for the activity monitors implementation. AMCR_EL0 is\napplicable to both the architected and the auxiliary counter groups.\n\nCG1RZ, bit [17] - Counter Group 1 Read Zero.\n                      0b0 System register reads of AMEVCNTR1<n>_EL0 return the\n                  event count at all implemented and enabled Exception levels.\n                      0b1 If the current Exception level is the highest\n                  implemented Exception level, system register reads of\n                  AMEVCNTR1<n>_EL0 return the event count. Otherwise, reads of\n                  AMEVCNTR1<n>_EL0 return a zero value.\n                  Reads from the memory-mapped view are unaffected by this\n                  field.\nHDBG, bit [10]  - This bit controls whether activity monitor counting is halted\n                  when the PE is halted in Debug state.\n                      0b0 Activity monitors do not halt counting when the PE is\n                  halted in Debug state.\n                      0b1 Activity monitors halt counting when the PE is halted\n                  in Debug state."
      },
      "AMEVCNTR0<n>_EL0": {
        "long_name": "Activity Monitors Event Counter Registers 0",
        "purpose": "Provides access to the architected activity monitor event counters.\n\nACNT, bits [0:63] - Architected activity monitor event counter n. Value of\n                    architected activity monitor event counter n, where n is the\n                    number of this register and is a number from 0 to 15. If\n                    ARMv8.6-AMU is implemented, HCR_EL2.AMVOFFEN is 1,\n                    SCR_EL3.AMVOFFEN is 0, HCR_EL2.{E2H, TGE} is not {1,1}, and\n                    EL2 is implemented in the current Security state, access to\n                    these registers at EL0 or EL1 return (PCount<63:0> -\n                    AMEVCNTVOFF0<n>_EL2<63:0>). PCount is the physical count\n                    returned when AMEVCNTR0<n>_EL0 is read from EL2 or EL3.\n                    If the counter is enabled, writes to this register have\n                    unpredictable results."
      },
      "AMEVCNTR1<n>_EL0": {
        "long_name": "Activity Monitors Event Counter Registers 1",
        "purpose": "Provides access to the auxiliary activity monitor event counters.\n\nACNT, bits [0:63] - Auxiliary activity monitor event counter n. Value of\n                    auxiliary activity monitor event counter n, where n is the\n                    number of this register and is a number from 0 to 15. If\n                    ARMv8.6-AMU is implemented, HCR_EL2.AMVOFFEN is 1,\n                    SCR_EL3.AMVOFFEN is 0, HCR_EL2.{E2H, TGE} is not {1,1}, EL2\n                    is implemented in the current Security state, and\n                    AMCR_EL0.CG1RZ is 0, reads to these registers at EL0 or EL1\n                    return (PCount<63:0> - AMEVCNTVOFF1<n>_EL2<63:0>). PCount is\n                    the physical count returned when AMEVCNTR1<n>_EL0 is read\n                    from EL2 or EL3.\n                    If the counter is enabled, writes to this register have\n                    unpredictable results."
      },
      "AMEVCNTVOFF0<n>_EL2": {
        "long_name": "Activity Monitors Event Counter Virtual Offset Registers 0",
        "purpose": "Holds the 64-bit virtual offset for architected activity monitor events.\n\nbits [0:63] - Virtual offset."
      },
      "AMEVCNTVOFF1<n>_EL2": {
        "long_name": "Activity Monitors Event Counter Virtual Offset Registers 1",
        "purpose": "Holds the 64-bit virtual offset for auxiliary activity monitor events.\n\nbits [0:63] - Virtual offset."
      },
      "AMEVTYPER0<n>_EL0": {
        "long_name": "Activity Monitors Event Type Registers 0",
        "purpose": "Provides information on the events that an architected activity monitor event\ncounter AMEVCNTR0<n>_EL0 counts.\n\nevtCount, bits [0:15] - Event to count. The event number of the event that is\n                        counted by the architected activity monitor event\n                        counter AMEVCNTR0<n>_EL0. The value of this field is\n                        architecturally mandated for each architected counter.\n                        The following table shows the mapping between required\n                        event numbers and the corresponding counters:\n                            0x0011 Processor frequency cycles\n                            0x4004 Constant frequency cycles\n                            0x0008 Instructions retired\n                            0x4005 Memory stall cycles"
      },
      "AMEVTYPER1<n>_EL0": {
        "long_name": "Activity Monitors Event Type Registers 1",
        "purpose": "Provides information on the events that an auxiliary activity monitor event\ncounter AMEVCNTR1<n>_EL0 counts.\n\nevtCount, bits [0:15] - Event to count. The event number of the event that is\n                        counted by the auxiliary activity monitor event counter\n                        AMEVCNTR1<n>_EL0. It is implementation defined what\n                        values are supported by each counter. If software writes\n                        a value to this field which is not supported by the\n                        corresponding counter AMEVCNTR1<n>_EL0, then:\n                          - It is unpredictable which event will be counted.\n                          - The value read back is unknown. The event counted by\n                        AMEVCNTR1<n>_EL0 might be fixed at implementation. In\n                        this case, the field is read-only and writes are\n                        undefined. If the corresponding counter AMEVCNTR1<n>_EL0\n                        is enabled, writes to this register have unpredictable\n                        results."
      },
      "AMUSERENR_EL0": {
        "long_name": "Activity Monitors User Enable Register",
        "purpose": "Global user enable register for the activity monitors. Enables or disables EL0\naccess to the activity monitors. AMUSERENR_EL0 is applicable to both the\narchitected and the auxiliary counter groups.\n\nEN, bit [0] - Traps EL0 accesses to the activity monitors registers to EL1, or\n              to EL2 when it is implemented and enabled for the current Security\n              state and HCR_EL2.TGE is 1, as follows:\n                -  In AArch64 state, accesses to the following registers are\n              trapped, reported using EC syndrome value 0x18:\n                  - AMCFGR_EL0, AMCGCR_EL0, AMCNTENCLR0_EL0, AMCNTENCLR1_EL0,\n              AMCNTENSET0_EL0, AMCNTENSET1_EL0, AMCR_EL0, AMEVCNTR0<n>_EL0,\n              AMEVCNTR1<n>_EL0, AMEVTYPER0<n>_EL0, and AMEVTYPER1<n>_EL0.\n                -  In AArch32 state, MRC and MCR accesses to the following\n              registers are trapped and reported using EC syndrome value 0x03,\n              MRRC and MCRR accesses are trapped and reported using EC syndrome\n              value 0x04:\n                  - AMCFGR, AMCGCR, AMCNTENCLR0, AMCNTENCLR1, AMCNTENSET0,\n              AMCNTENSET1, AMCR, AMEVCNTR0<n>, AMEVCNTR1<n>, AMEVTYPER0<n>, and\n              AMEVTYPER1<n>.\n                  0b0 EL0 accesses to the activity monitors registers are\n              trapped.\n                  0b1 This control does not cause any instructions to be\n              trapped. Software can access all activity monitor registers at\n              EL0.\n              \n                - AMUSERENR_EL0 can always be read at EL0 and is not governed by\n              this bit."
      },
      "APDAKeyHi_EL1": {
        "long_name": "Pointer Authentication Key A for Data (bits[127:64]) ",
        "purpose": "Holds bits[127:64] of key A used for authentication of data pointer values.\n\nThe term APDAKey_EL1 is used to describe the concatenation of APDAKeyHi_EL1:\nAPDAKeyLo_EL1.\n\nbits [0:63] - 64 bit value, bits[127:64] of the 128 bit pointer authentication\n              key value."
      },
      "APDAKeyLo_EL1": {
        "long_name": "Pointer Authentication Key A for Data (bits[63:0]) ",
        "purpose": "Holds bits[63:0] of key A used for authentication of data pointer values.\n\nThe term APDAKey_EL1 is used to describe the concatenation of APDAKeyHi_EL1:\nAPDAKeyLo_EL1.\n\nbits [0:63] - 64 bit value, bits[63:0] of the 128 bit pointer authentication key\n              value."
      },
      "APDBKeyHi_EL1": {
        "long_name": "Pointer Authentication Key B for Data (bits[127:64]) ",
        "purpose": "Holds bits[127:64] of key B used for authentication of data pointer values.\n\nThe term APDBKey_EL1 is used to describe the concatenation of APDBKeyHi_EL1:\nAPDBKeyLo_EL1.\n\nbits [0:63] - 64 bit value, bits[127:64] of the 128 bit pointer authentication\n              key value."
      },
      "APDBKeyLo_EL1": {
        "long_name": "Pointer Authentication Key B for Data (bits[63:0]) ",
        "purpose": "Holds bits[63:0] of key B used for authentication of data pointer values.\n\nThe term APDBKey_EL1 is used to describe the concatenation of APDBKeyHi_EL1:\nAPDBKeyLo_EL1.\n\nbits [0:63] - 64 bit value, bits[63:0] of the 128 bit pointer authentication key\n              value."
      },
      "APGAKeyHi_EL1": {
        "long_name": "Pointer Authentication Key A for Code (bits[127:64]) ",
        "purpose": "Holds bits[127:64] of key used for generic pointer authentication code.\n\nThe term APGAKey_EL1 is used to describe the concatenation of APGAKeyHi_EL1:\nAPGAKeyLo_EL1.\n\nbits [0:63] - 64 bit value, bits[127:64] of the 128 bit pointer authentication\n              key value."
      },
      "APGAKeyLo_EL1": {
        "long_name": "Pointer Authentication Key A for Code (bits[63:0]) ",
        "purpose": "Holds bits[63:0] of key used for generic pointer authentication code.\n\nThe term APGAKey_EL1 is used to describe the concatenation of APGAKeyHi_EL1:\nAPGAKeyLo_EL1.\n\nbits [0:63] - 64 bit value, bits[63:0] of the 128 bit pointer authentication key\n              value."
      },
      "APIAKeyHi_EL1": {
        "long_name": "Pointer Authentication Key A for Instruction (bits[127:64]) ",
        "purpose": "Holds bits[127:64] of key A used for authentication of instruction pointer\nvalues.\n\nThe term APIAKey_EL1 is used to describe the concatenation of APIAKeyHi_EL1:\nAPIAKeyLo_EL1.\n\nbits [0:63] - 64 bit value, bits[127:64] of the 128 bit pointer authentication\n              key value."
      },
      "APIAKeyLo_EL1": {
        "long_name": "Pointer Authentication Key A for Instruction (bits[63:0]) ",
        "purpose": "Holds bits[63:0] of key A used for authentication of instruction pointer values.\n\nThe term APIAKey_EL1 is used to describe the concatenation of APIAKeyHi_EL1:\nAPIAKeyLo_EL1.\n\nbits [0:63] - 64 bit value, bits[63:0] of the 128 bit pointer authentication key\n              value."
      },
      "APIBKeyHi_EL1": {
        "long_name": "Pointer Authentication Key B for Instruction (bits[127:64]) ",
        "purpose": "Holds bits[127:64] of key B used for authentication of instruction pointer\nvalues.\n\nThe term APIBKey_EL1 is used to describe the concatenation of APIBKeyHi_EL1:\nAPIBKeyLo_EL1.\n\nbits [0:63] - 64 bit value, bits[127:64] of the 128 bit pointer authentication\n              key value."
      },
      "APIBKeyLo_EL1": {
        "long_name": "Pointer Authentication Key B for Instruction (bits[63:0]) ",
        "purpose": "Holds bits[63:0] of key B used for authentication of instruction pointer values.\n\nThe term APIBKey_EL1 is used to describe the concatenation of APIBKeyHi_EL1:\nAPIBKeyLo_EL1.\n\nbits [0:63] - 64 bit value, bits[63:0] of the 128 bit pointer authentication key\n              value."
      },
      "CCSIDR2_EL1": {
        "long_name": "Current Cache Size ID Register 2",
        "purpose": "When ARMv8.3-CCIDX is implemented, provides the information about the\narchitecture of the currently selected cache from bits[63:32] of CCSIDR_EL1.\n\nWhen ARMv8.3-CCIDX is not implemented, this register is not implemented.\n\nNumSets, bits [0:23] - (Number of sets in cache) - 1, therefore a value of 0\n                       indicates 1 set in the cache. The number of sets does not\n                       have to be a power of 2."
      },
      "CCSIDR_EL1": {
        "long_name": "Current Cache Size ID Register",
        "purpose": "Provides information about the architecture of the currently selected cache.\n\nNumSets, bits [32:55]      - (Number of sets in cache) - 1, therefore a value of\n                             0 indicates 1 set in the cache. The number of sets\n                             does not have to be a power of 2.\nAssociativity, bits [3:23] - (Associativity of cache) - 1, therefore a value of\n                             0 indicates an associativity of 1. The\n                             associativity does not have to be a power of 2.\nLineSize, bits [0:2]       - (Log_2(Number of bytes in cache line)) - 4. For\n                             example:\n                               - For a line length of 16 bytes: Log_2(16) = 4,\n                             LineSize entry = 0. This is the minimum line\n                             length.\n                               - For a line length of 32 bytes: Log_2(32) = 5,\n                             LineSize entry = 1. When ARMv8.5-MemTag is\n                             implemented and enabled, where a cache only holds\n                             Allocation tags, this field is res0."
      },
      "CLIDR_EL1": {
        "long_name": "Cache Level ID Register",
        "purpose": "Identifies the type of cache, or caches, that are implemented at each level and\ncan be managed using the architected cache maintenance instructions that operate\nby set/way, up to a maximum of seven levels. Also identifies the Level of\nCoherence (LoC) and Level of Unification (LoU) for the cache hierarchy.\n\nTtype<n>, bits [33:46] - Tag cache type. Indicate the type of cache that is\n                         implemented and can be managed using the architected\n                         cache maintenance instructions that operate by set/way\n                         at each level, from Level 1 up to a maximum of seven\n                         levels of cache hierarchy.\nICB, bits [30:32]      - Inner cache boundary. This field indicates the boundary\n                         for caching Inner Cacheable memory regions.\nLoUU, bits [27:29]     - Level of Unification Uniprocessor for the cache\n                         hierarchy.\nLoC, bits [24:26]      - Level of Coherence for the cache hierarchy.\nLoUIS, bits [21:23]    - Level of Unification Inner Shareable for the cache\n                         hierarchy.\nCtype<n>, bits [0:20]  - Cache Type fields. Indicate the type of cache that is\n                         implemented and can be managed using the architected\n                         cache maintenance instructions that operate by set/way\n                         at each level, from Level 1 up to a maximum of seven\n                         levels of cache hierarchy."
      },
      "CNTFRQ_EL0": {
        "long_name": "Counter-timer Frequency register",
        "purpose": "This register is provided so that software can discover the frequency of the\nsystem counter. It must be programmed with this value as part of system\ninitialization. The value of the register is not interpreted by hardware.\n\nbits [0:31] - Clock frequency. Indicates the system counter clock frequency, in\n              Hz."
      },
      "CNTHCTL_EL2": {
        "long_name": "Counter-timer Hypervisor Control register",
        "purpose": "Controls the generation of an event stream from the physical counter, and access\nfrom EL1 to the physical counter and the EL1 physical timer.\n\nEVNTIS, bit [17]   - Controls the scale of the generation of the event stream.\nEL1NVVCT, bit [16] - Traps EL1 accesses to the specified EL1 virtual timer\n                     registers using the EL02 descriptors to EL2, when EL2 is\n                     enabled for the current Security state.\nEL1NVPCT, bit [15] - Traps EL1 accesses to the specified EL1 physical timer\n                     registers using the EL02 descriptors to EL2, when EL2 is\n                     enabled for the current Security state.\nEL1TVCT, bit [14]  - Traps EL0 and EL1 accesses to the EL1 virtual counter\n                     registers to EL2, when EL2 is enabled for the current\n                     Security state.\nEL1TVT, bit [13]   - Traps EL0 and EL1 accesses to the EL1 virtual timer\n                     registers to EL2, when EL2 is enabled for the current\n                     Security state.\nECV, bit [12]      - Enables the Enhanced Counter Virtualization functionality\n                     registers.\nEL1PTEN, bit [11]  - When HCR_EL2.TGE is 0, traps EL0 and EL1 accesses to the E1\n                     physical timer registers to EL2 when EL2 is enabled in the\n                     current Security state.\nEL1PCTEN, bit [10] - When HCR_EL2.TGE is 0, traps EL0 and EL1 accesses to the\n                     EL1 physical counter register to EL2 when EL2 is enabled in\n                     the current Security state, as follows.\nEL0PTEN, bit [9]   - When HCR_EL2.TGE is 0, this control does not cause any\n                     instructions to be trapped.\nEL0VTEN, bit [8]   - When HCR_EL2.TGE is 0, this control does not cause any\n                     instructions to be trapped.\nEVNTI, bits [4:7]  - Selects which bit (0 to 15) of the counter register\n                     CNTPCT_EL0 is the trigger for the event stream generated\n                     from that counter, when that stream is enabled.\nEVNTDIR, bit [3]   - Controls which transition of the counter register\n                     CNTPCT_EL0 trigger bit, defined by EVNTI, generates an\n                     event when the event stream is enabled:\nEVNTEN, bit [2]    - Enables the generation of an event stream from the counter\n                     register CNTPCT_EL0:\nEL0VCTEN, bit [1]  - When HCR_EL2.TGE is 0, this control does not cause any\n                     instructions to be trapped.\nEL0PCTEN, bit [0]  - When HCR_EL2.TGE is 0, this control does not cause any\n                     instructions to be trapped."
      },
      "CNTHPS_CTL_EL2": {
        "long_name": "Counter-timer Secure Physical Timer Control register (EL2)",
        "purpose": "Control register for the Secure EL2 physical timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the CNTHPS_CTL_EL2.ENABLE bit is 1, ISTATUS\n                   indicates whether the timer condition is met. ISTATUS takes\n                   no account of the value of the IMASK bit. If the value of\n                   ISTATUS is 1 and the value of IMASK is 0 then the timer\n                   interrupt is asserted. When the value of the\n                   CNTHPS_CTL_EL2.ENABLE bit is 0, the ISTATUS field is unknown.\n                   For more information see 'Operation of the CompareValue views\n                   of the timers' and 'Operation of the TimerValue views of the\n                   timers' in the Arm\u00ae Architecture Reference Manual, Armv8, for\n                   Armv8-A architecture profile, chapter D6. This bit is read-\n                   only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTHPS_TVAL_EL2 continues to\n                   count down. Disabling the output signal might be a power-\n                   saving option."
      },
      "CNTHPS_CVAL_EL2": {
        "long_name": "Counter-timer Secure Physical Timer CompareValue register (EL2)",
        "purpose": "Holds the compare value for the Secure EL2 physical timer.\n\nCompareValue, bits [0:63] - Holds the EL2 physical timer CompareValue. When\n                            CNTHPS_CTL_EL2.ENABLE is 1, the timer condition is\n                            met when (CNTPCT_EL0 - CompareValue) is greater than\n                            or equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTHPS_CTL_EL2.ISTATUS is set to 1.\n                              - If CNTHPS_CTL_EL2.IMASK is 0, an interrupt is\n                            generated. When CNTHPS_CTL_EL2.ENABLE is 0, the\n                            timer condition is not met, but CNTPCT_EL0 continues\n                            to count. If the Generic counter is implemented at a\n                            size less than 64 bits, then this field is permitted\n                            to be implemented at the same width as the counter,\n                            and the upper bits are res0. The value of this field\n                            is treated as zero-extended in all counter\n                            calculations."
      },
      "CNTHPS_TVAL_EL2": {
        "long_name": "Counter-timer Secure Physical Timer TimerValue register (EL2)",
        "purpose": "Holds the timer value for the Secure EL2 physical timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL2 physical timer. On a\n                          read of this register:\n                            - If CNTHPS_CTL_EL2.ENABLE is 0, the value returned\n                          is unknown.\n                            - If CNTHPS_CTL_EL2.ENABLE is 1, the value returned\n                          is (CNTHPS_CVAL_EL2 - CNTPCT_EL0). On a write of this\n                          register, CNTHPS_CVAL_EL2 is set to (CNTPCT_EL0 +\n                          TimerValue), where TimerValue is treated as a signed\n                          32-bit integer. When CNTHPS_CTL_EL2.ENABLE is 1, the\n                          timer condition is met when (CNTPCT_EL0 -\n                          CNTHPS_CVAL_EL2) is greater than or equal to zero.\n                          This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTHPS_CTL_EL2.ISTATUS is set to 1.\n                            - If CNTHPS_CTL_EL2.IMASK is 0, an interrupt is\n                          generated. When CNTHPS_CTL_EL2.ENABLE is 0, the timer\n                          condition is not met, but CNTPCT_EL0 continues to\n                          count, so the TimerValue view appears to continue to\n                          count down."
      },
      "CNTHP_CTL_EL2": {
        "long_name": "Counter-timer Hypervisor Physical Timer Control register",
        "purpose": "Control register for the EL2 physical timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown. For more information see 'Operation of the\n                   CompareValue views of the timers' and 'Operation of the\n                   TimerValue views of the timers' in the Arm\u00ae Architecture\n                   Reference Manual, Armv8, for Armv8-A architecture profile,\n                   chapter D6. This bit is read-only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTHP_TVAL_EL2 continues to\n                   count down. Disabling the output signal might be a power-\n                   saving option."
      },
      "CNTHP_CVAL_EL2": {
        "long_name": "Counter-timer Physical Timer CompareValue register (EL2)",
        "purpose": "Holds the compare value for the EL2 physical timer.\n\nCompareValue, bits [0:63] - Holds the EL2 physical timer CompareValue. When\n                            CNTHP_CTL_EL2.ENABLE is 1, the timer condition is\n                            met when (CNTPCT_EL0 - CompareValue) is greater than\n                            or equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTHP_CTL_EL2.ISTATUS is set to 1.\n                              - If CNTHP_CTL_EL2.IMASK is 0, an interrupt is\n                            generated. When CNTHP_CTL_EL2.ENABLE is 0, the timer\n                            condition is not met, but CNTPCT_EL0 continues to\n                            count. If the Generic counter is implemented at a\n                            size less than 64 bits, then this field is permitted\n                            to be implemented at the same width as the counter,\n                            and the upper bits are res0. The value of this field\n                            is treated as zero-extended in all counter\n                            calculations."
      },
      "CNTHP_TVAL_EL2": {
        "long_name": "Counter-timer Physical Timer TimerValue register (EL2)",
        "purpose": "Holds the timer value for the EL2 physical timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL2 physical timer. On a\n                          read of this register:\n                            - If CNTHP_CTL_EL2.ENABLE is 0, the value returned\n                          is unknown.\n                            - If CNTHP_CTL_EL2.ENABLE is 1, the value returned\n                          is (CNTHP_CVAL_EL2 - CNTPCT_EL0). On a write of this\n                          register, CNTHP_CVAL_EL2 is set to (CNTPCT_EL0 +\n                          TimerValue), where TimerValue is treated as a signed\n                          32-bit integer. When CNTHP_CTL_EL2.ENABLE is 1, the\n                          timer condition is met when (CNTPCT_EL0 -\n                          CNTHP_CVAL_EL2) is greater than or equal to zero. This\n                          means that TimerValue acts like a 32-bit downcounter\n                          timer. When the timer condition is met:\n                            - CNTHP_CTL_EL2.ISTATUS is set to 1.\n                            - If CNTHP_CTL_EL2.IMASK is 0, an interrupt is\n                          generated. When CNTHP_CTL_EL2.ENABLE is 0, the timer\n                          condition is not met, but CNTPCT_EL0 continues to\n                          count, so the TimerValue view appears to continue to\n                          count down."
      },
      "CNTHVS_CTL_EL2": {
        "long_name": "Counter-timer Secure Virtual Timer Control register (EL2)",
        "purpose": "Control register for the Secure EL2 virtual timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the CNTHVS_CTL_EL2.ENABLE bit is 1, ISTATUS\n                   indicates whether the timer condition is met. ISTATUS takes\n                   no account of the value of the IMASK bit. If the value of\n                   ISTATUS is 1 and the value of IMASK is 0 then the timer\n                   interrupt is asserted. When the value of the ENABLE bit is 0,\n                   the ISTATUS field is unknown. For more information see\n                   'Operation of the CompareValue views of the timers' and\n                   'Operation of the TimerValue views of the timers' in the Arm\u00ae\n                   Architecture Reference Manual, Armv8, for Armv8-A\n                   architecture profile, chapter D6. This bit is read-only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the\n                   CNTHVS_CTL_EL2.ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTHVS_TVAL_EL2 continues to\n                   count down. Disabling the output signal might be a power-\n                   saving option."
      },
      "CNTHVS_CVAL_EL2": {
        "long_name": "Counter-timer Secure Virtual Timer CompareValue register (EL2)",
        "purpose": "Holds the compare value for the Secure EL2 virtual timer.\n\nCompareValue, bits [0:63] - Holds the Secure EL2 virtual timer CompareValue.\n                            When CNTHVS_CTL_EL2.ENABLE is 1, the timer condition\n                            is met when (CNTVCT_EL0 - CompareValue) is greater\n                            than or equal to zero. This means that CompareValue\n                            acts like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTHVS_CTL_EL2.ISTATUS is set to 1.\n                              - If CNTHVS_CTL_EL2.IMASK is 0, an interrupt is\n                            generated. When CNTHVS_CTL_EL2.ENABLE is 0, the\n                            timer condition is not met, but CNTVCT_EL0 continues\n                            to count. If the Generic counter is implemented at a\n                            size less than 64 bits, then this field is permitted\n                            to be implemented at the same width as the counter,\n                            and the upper bits are res0. The value of this field\n                            is treated as zero-extended in all counter\n                            calculations."
      },
      "CNTHVS_TVAL_EL2": {
        "long_name": "Counter-timer Secure Virtual Timer TimerValue register (EL2)",
        "purpose": "Holds the timer value for the Secure EL2 virtual timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL2 virtual timer. On a\n                          read of this register:\n                            - If CNTHVS_CTL_EL2.ENABLE is 0, the value returned\n                          is unknown.\n                            - If CNTHVS_CTL_EL2.ENABLE is 1, the value returned\n                          is (CNTHVS_CVAL_EL2 - CNTVCT_EL0). On a write of this\n                          register, CNTHVS_CVAL_EL2 is set to (CNTVCT_EL0 +\n                          TimerValue), where TimerValue is treated as a signed\n                          32-bit integer. When CNTHVS_CTL_EL2.ENABLE is 1, the\n                          timer condition is met when ((CNTVCT_EL0 -\n                          CNTHVS_CVAL_EL2) is greater than or equal to zero.\n                          This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTHVS_CTL_EL2.ISTATUS is set to 1.\n                            - If CNTHVS_CTL_EL2.IMASK is 0, an interrupt is\n                          generated. When CNTHVS_CTL_EL2.ENABLE is 0, the timer\n                          condition is not met, but CNTVCT_EL0 continues to\n                          count, so the TimerValue view appears to continue to\n                          count down."
      },
      "CNTHV_CTL_EL2": {
        "long_name": "Counter-timer Virtual Timer Control register (EL2)",
        "purpose": "Control register for the EL2 virtual timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown. For more information see 'Operation of the\n                   CompareValue views of the timers' and 'Operation of the\n                   TimerValue views of the timers' in the Arm\u00ae Architecture\n                   Reference Manual, Armv8, for Armv8-A architecture profile,\n                   chapter D6. This bit is read-only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTHV_TVAL_EL2 continues to\n                   count down. Disabling the output signal might be a power-\n                   saving option."
      },
      "CNTHV_CVAL_EL2": {
        "long_name": "Counter-timer Virtual Timer CompareValue register (EL2)",
        "purpose": "Holds the compare value for the EL2 virtual timer.\n\nCompareValue, bits [0:63] - Holds the EL2 virtual timer CompareValue. When\n                            CNTHV_CTL_EL2.ENABLE is 1, the timer condition is\n                            met when (CNTVCT_EL0 - CompareValue) is greater than\n                            or equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTHV_CTL_EL2.ISTATUS is set to 1.\n                              - If CNTHV_CTL_EL2.IMASK is 0, an interrupt is\n                            generated. When CNTHV_CTL_EL2.ENABLE is 0, the timer\n                            condition is not met, but CNTVCT_EL0 continues to\n                            count. If the Generic counter is implemented at a\n                            size less than 64 bits, then this field is permitted\n                            to be implemented at the same width as the counter,\n                            and the upper bits are res0. The value of this field\n                            is treated as zero-extended in all counter\n                            calculations."
      },
      "CNTHV_TVAL_EL2": {
        "long_name": "Counter-timer Virtual Timer TimerValue Register (EL2)",
        "purpose": "Holds the timer value for the EL2 virtual timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL2 virtual timer. On a\n                          read of this register:\n                            - If CNTHV_CTL_EL2.ENABLE is 0, the value returned\n                          is unknown.\n                            - If CNTHV_CTL_EL2.ENABLE is 1, the value returned\n                          is (CNTHV_CVAL_EL2 - CNTVCT_EL0). On a write of this\n                          register, CNTHV_CVAL_EL2 is set to (CNTVCT_EL0 +\n                          TimerValue), where TimerValue is treated as a signed\n                          32-bit integer. When CNTHV_CTL_EL2.ENABLE is 1, the\n                          timer condition is met when (CNTVCT_EL0 -\n                          CNTHV_CVAL_EL2) is greater than or equal to zero. This\n                          means that TimerValue acts like a 32-bit downcounter\n                          timer. When the timer condition is met:\n                            - CNTHV_CTL_EL2.ISTATUS is set to 1.\n                            - If CNTHV_CTL_EL2.IMASK is 0, an interrupt is\n                          generated. When CNTHV_CTL_EL2.ENABLE is 0, the timer\n                          condition is not met, but CNTVCT_EL0 continues to\n                          count, so the TimerValue view appears to continue to\n                          count down."
      },
      "CNTKCTL_EL1": {
        "long_name": "Counter-timer Kernel Control register",
        "purpose": "When ARMv8.1-VHE is not implemented, or when HCR_EL2.{E2H, TGE} is not {1, 1},\nthis register controls the generation of an event stream from the virtual\ncounter, and access from EL0 to the physical counter, virtual counter, EL1\nphysical timers, and the virtual timer.\n\nWhen ARMv8.1-VHE is implemented and HCR_EL2.{E2H, TGE} is {1, 1}, this register\ndoes not cause any event stream from the virtual counter to be generated, and\ndoes not control access to the counters and timers. The access to counters and\ntimers at EL0 is controlled by CNTHCTL_EL2.\n\nEVNTIS, bit [17]  - Controls the scale of the generation of the event stream.\nEL0PTEN, bit [9]  - Traps EL0 accesses to the physical timer registers to EL1,\n                    or to EL2 when it is implemented and enabled for the current\n                    Security state and HCR_EL2.TGE is 1, as follows.\nEL0VTEN, bit [8]  - Traps EL0 accesses to the virtual timer registers to EL1, or\n                    to EL2 when it is implemented and enabled for the current\n                    Security state and HCR_EL2.TGE is 1, as follows.\nEVNTI, bits [4:7] - Selects which bit (0 to 15) of the counter register\n                    CNTVCT_EL0 is the trigger for the event stream generated\n                    from that counter, when that stream is enabled.\nEVNTDIR, bit [3]  - Controls which transition of the counter register CNTVCT_EL0\n                    trigger bit, defined by EVNTI, generates an event when the\n                    event stream is enabled:\nEVNTEN, bit [2]   - \nEL0VCTEN, bit [1] - Traps EL0 accesses to the frequency register and virtual\n                    counter register to EL1, or to EL2 when it is implemented\n                    and enabled for the current Security state and HCR_EL2.TGE\n                    is 1, as follows.\nEL0PCTEN, bit [0] - Traps EL0 accesses to the frequency register and physical\n                    counter register to EL1, or to EL2 when it is implemented\n                    and enabled for the current Security state and HCR_EL2.TGE\n                    is 1, as follows."
      },
      "CNTPCTSS_EL0": {
        "long_name": "Counter-timer Self-Synchronized Physical Count register",
        "purpose": "Holds the self-synchronized view of the 64-bit physical count value.\n\nbits [0:63] - Self-synchronized physical count value."
      },
      "CNTPCT_EL0": {
        "long_name": "Counter-timer Physical Count register",
        "purpose": "Holds the 64-bit physical count value.\n\nbits [0:63] - Physical count value. Reads of CNTPCT_EL0 from EL0 or EL1 return\n              (PCount<63:0> - CNTPOFF_EL2<63:0>) if the access is not trapped,\n              and all of the following are true:\n                -  CNTHCTL_EL2.ECV is 1.\n                -  HCR_EL2.{E2H, TGE} is not {1, 1}. Where PCount<63:0> is the\n              physical count returned when CNTPCT_EL0 is read from EL2 or EL3."
      },
      "CNTPOFF_EL2": {
        "long_name": "Counter-timer Physical Offset register",
        "purpose": "Holds the 64-bit physical offset. This is the offset for the AArch64 physical\ntimers and counters when Enhanced Counter Virtualization is enabled.\n\nPhysical offset, bits [0:63] - Physical offset."
      },
      "CNTPS_CTL_EL1": {
        "long_name": "Counter-timer Physical Secure Timer Control register",
        "purpose": "Control register for the secure physical timer, usually accessible at EL3 but\nconfigurably accessible at EL1 in Secure state.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown. For more information see 'Operation of the\n                   CompareValue views of the timers' and 'Operation of the\n                   TimerValue views of the timers' in the Arm\u00ae Architecture\n                   Reference Manual, Armv8, for Armv8-A architecture profile,\n                   chapter D6. This bit is read-only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTPS_TVAL_EL1 continues to\n                   count down. Disabling the output signal might be a power-\n                   saving option."
      },
      "CNTPS_CVAL_EL1": {
        "long_name": "Counter-timer Physical Secure Timer CompareValue register",
        "purpose": "Holds the compare value for the secure physical timer, usually accessible at EL3\nbut configurably accessible at EL1 in Secure state.\n\nCompareValue, bits [0:63] - Holds the secure physical timer CompareValue. When\n                            CNTPS_CTL_EL1.ENABLE is 1, the timer condition is\n                            met when (CNTPCT_EL0 - CompareValue) is greater than\n                            or equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTPS_CTL_EL1.ISTATUS is set to 1.\n                              - If CNTPS_CTL_EL1.IMASK is 0, an interrupt is\n                            generated. When CNTPS_CTL_EL1.ENABLE is 0, the timer\n                            condition is not met, but CNTPCT_EL0 continues to\n                            count. If the Generic counter is implemented at a\n                            size less than 64 bits, then this field is permitted\n                            to be implemented at the same width as the counter,\n                            and the upper bits are res0. The value of this field\n                            is treated as zero-extended in all counter\n                            calculations."
      },
      "CNTPS_TVAL_EL1": {
        "long_name": "Counter-timer Physical Secure Timer TimerValue register",
        "purpose": "Holds the timer value for the secure physical timer, usually accessible at EL3\nbut configurably accessible at EL1 in Secure state.\n\nTimerValue, bits [0:31] - The TimerValue view of the secure physical timer. On a\n                          read of this register:\n                            - If CNTPS_CTL_EL1.ENABLE is 0, the value returned\n                          is unknown.\n                            - If CNTPS_CTL_EL1.ENABLE is 1, the value returned\n                          is (CNTPS_CVAL_EL1 - CNTPCT_EL0). On a write of this\n                          register, CNTPS_CVAL_EL1 is set to (CNTPCT_EL0 +\n                          TimerValue), where TimerValue is treated as a signed\n                          32-bit integer. When CNTPS_CTL_EL1.ENABLE is 1, the\n                          timer condition is met when (CNTPCT_EL0 -\n                          CNTPS_CVAL_EL1) is greater than or equal to zero. This\n                          means that TimerValue acts like a 32-bit downcounter\n                          timer. When the timer condition is met:\n                            - CNTPS_CTL_EL1.ISTATUS is set to 1.\n                            - If CNTPS_CTL_EL1.IMASK is 0, an interrupt is\n                          generated. When CNTPS_CTL_EL1.ENABLE is 0, the timer\n                          condition is not met, but CNTPCT_EL0 continues to\n                          count, so the TimerValue view appears to continue to\n                          count down."
      },
      "CNTP_CTL_EL0": {
        "long_name": "Counter-timer Physical Timer Control register",
        "purpose": "Control register for the EL1 physical timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown. For more information see 'Operation of the\n                   CompareValue views of the timers' and 'Operation of the\n                   TimerValue views of the timers' in the Arm\u00ae Architecture\n                   Reference Manual, Armv8, for Armv8-A architecture profile,\n                   chapter D6. This bit is read-only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTP_TVAL_EL0 continues to\n                   count down. Disabling the output signal might be a power-\n                   saving option."
      },
      "CNTP_CVAL_EL0": {
        "long_name": "Counter-timer Physical Timer CompareValue register",
        "purpose": "Holds the compare value for the EL1 physical timer.\n\nCompareValue, bits [0:63] - Holds the EL1 physical timer CompareValue. When\n                            CNTP_CTL_EL0.ENABLE is 1, the timer condition is met\n                            when (CNTPCT_EL0 - CompareValue) is greater than or\n                            equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTP_CTL_EL0.ISTATUS is set to 1.\n                              - If CNTP_CTL_EL0.IMASK is 0, an interrupt is\n                            generated. When CNTP_CTL_EL0.ENABLE is 0, the timer\n                            condition is not met, but CNTPCT_EL0 continues to\n                            count. If the Generic counter is implemented at a\n                            size less than 64 bits, then this field is permitted\n                            to be implemented at the same width as the counter,\n                            and the upper bits are res0. The value of this field\n                            is treated as zero-extended in all counter\n                            calculations."
      },
      "CNTP_TVAL_EL0": {
        "long_name": "Counter-timer Physical Timer TimerValue register",
        "purpose": "Holds the timer value for the EL1 physical timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL1 physical timer. On a\n                          read of this register:\n                            - If CNTP_CTL_EL0.ENABLE is 0, the value returned is\n                          unknown.\n                            - If CNTP_CTL_EL0.ENABLE is 1, the value returned is\n                          (CNTP_CVAL_EL0 - CNTPCT_EL0). On a write of this\n                          register, CNTP_CVAL_EL0 is set to (CNTPCT_EL0 +\n                          TimerValue), where TimerValue is treated as a signed\n                          32-bit integer. When CNTP_CTL_EL0.ENABLE is 1, the\n                          timer condition is met when (CNTPCT_EL0 -\n                          CNTP_CVAL_EL0) is greater than or equal to zero. This\n                          means that TimerValue acts like a 32-bit downcounter\n                          timer. When the timer condition is met:\n                            - CNTP_CTL_EL0.ISTATUS is set to 1.\n                            - If CNTP_CTL_EL0.IMASK is 0, an interrupt is\n                          generated. When CNTP_CTL_EL0.ENABLE is 0, the timer\n                          condition is not met, but CNTPCT_EL0 continues to\n                          count, so the TimerValue view appears to continue to\n                          count down."
      },
      "CNTVCTSS_EL0": {
        "long_name": "Counter-timer Self-Synchronized Virtual Count register",
        "purpose": "Holds the 64-bit virtual count value. The virtual count value is equal to the\nphysical count value visible in CNTPCT_EL0 minus the virtual offset visible in\nCNTVOFF_EL2.\n\nbits [0:63] - Self-synchronized virtual count value."
      },
      "CNTVCT_EL0": {
        "long_name": "Counter-timer Virtual Count register",
        "purpose": "Holds the 64-bit virtual count value. The virtual count value is equal to the\nphysical count value minus the virtual offset visible in CNTVOFF_EL2.\n\nbits [0:63] - Virtual count value."
      },
      "CNTVOFF_EL2": {
        "long_name": "Counter-timer Virtual Offset register",
        "purpose": "Holds the 64-bit virtual offset. This is the offset between the physical count\nvalue visible in CNTPCT_EL0 and the virtual count value visible in CNTVCT_EL0.\n\nbits [0:63] - Virtual offset. If the Generic counter is implemented at a size\n              less than 64 bits, then this field is permitted to be implemented\n              at the same width as the counter, and the upper bits are res0. The\n              value of this field is treated as zero-extended in all counter\n              calculations."
      },
      "CNTV_CTL_EL0": {
        "long_name": "Counter-timer Virtual Timer Control register",
        "purpose": "Control register for the virtual timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown. For more information see 'Operation of the\n                   CompareValue views of the timers' and 'Operation of the\n                   TimerValue views of the timers' in the Arm\u00ae Architecture\n                   Reference Manual, Armv8, for Armv8-A architecture profile,\n                   chapter D6. This bit is read-only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTV_TVAL_EL0 continues to\n                   count down. Disabling the output signal might be a power-\n                   saving option."
      },
      "CNTV_CVAL_EL0": {
        "long_name": "Counter-timer Virtual Timer CompareValue register",
        "purpose": "Holds the compare value for the virtual timer.\n\nCompareValue, bits [0:63] - Holds the EL1 virtual timer CompareValue. When\n                            CNTV_CTL_EL0.ENABLE is 1, the timer condition is met\n                            when (CNTVCT_EL0 - CompareValue) is greater than or\n                            equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTV_CTL_EL0.ISTATUS is set to 1.\n                              - If CNTV_CTL_EL0.IMASK is 0, an interrupt is\n                            generated. When CNTV_CTL_EL0.ENABLE is 0, the timer\n                            condition is not met, but CNTVCT_EL0 continues to\n                            count. If the Generic counter is implemented at a\n                            size less than 64 bits, then this field is permitted\n                            to be implemented at the same width as the counter,\n                            and the upper bits are res0. The value of this field\n                            is treated as zero-extended in all counter\n                            calculations."
      },
      "CNTV_TVAL_EL0": {
        "long_name": "Counter-timer Virtual Timer TimerValue register",
        "purpose": "Holds the timer value for the EL1 virtual timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL1 virtual timer. On a\n                          read of this register:\n                            - If CNTV_CTL_EL0.ENABLE is 0, the value returned is\n                          unknown.\n                            - If CNTV_CTL_EL0.ENABLE is 1, the value returned is\n                          (CNTV_CVAL_EL0 - CNTVCT_EL0). On a write of this\n                          register, CNTV_CVAL_EL0 is set to (CNTVCT_EL0 +\n                          TimerValue), where TimerValue is treated as a signed\n                          32-bit integer. When CNTV_CTL_EL0.ENABLE is 1, the\n                          timer condition is met when (CNTVCT_EL0 -\n                          CNTV_CVAL_EL0) is greater than or equal to zero. This\n                          means that TimerValue acts like a 32-bit downcounter\n                          timer. When the timer condition is met:\n                            - CNTV_CTL_EL0.ISTATUS is set to 1.\n                            - If CNTV_CTL_EL0.IMASK is 0, an interrupt is\n                          generated. When CNTV_CTL_EL0.ENABLE is 0, the timer\n                          condition is not met, but CNTVCT_EL0 continues to\n                          count, so the TimerValue view appears to continue to\n                          count down."
      },
      "CONTEXTIDR_EL1": {
        "long_name": "Context ID Register (EL1)",
        "purpose": "Identifies the current Process Identifier.\n\nThe value of the whole of this register is called the Context ID and is used by:\n\n  - The debug logic, for Linked and Unlinked Context ID matching.\n  - The trace logic, to identify the current process.\n\nThe significance of this register is for debug and trace use only.\n\nThis register is used when ARMv8.1-VHE is not implemented, or whenARMv8.1-VHE is\nimplemented and HCR_EL2.E2H is set to 0.\n\nWhen ARMv8.1-VHE is implemented and HCR_EL2.E2H is set to 1, CONTEXTIDR_EL2 is\nused.\n\nPROCID, bits [0:31] - Process Identifier. This field must be programmed with a\n                      unique value that identifies the current process. In\n                      AArch32 state, when TTBCR.EAE is set to 0, CONTEXTIDR.ASID\n                      holds the ASID. In AArch64 state, CONTEXTIDR_EL1 is\n                      independent of the ASID, and for the EL1&0 translation\n                      regime either TTBR0_EL1 or TTBR1_EL1 holds the ASID."
      },
      "CONTEXTIDR_EL2": {
        "long_name": "Context ID Register (EL2)",
        "purpose": "When HCR_EL2.E2H is set to 1, identifies the current Process Identifier.\n\nThe value of the whole of this register is called the Context ID and is used by:\n\n  - The debug logic, for Linked and Unlinked Context ID matching.\n  - The trace logic, to identify the current process.\n\nThe significance of this register is for debug and trace use only.\n\nWhen HCR_EL2.E2H is 0, CONTEXTIDR_EL2 replaces CONTEXTIDR_EL1 where\nCONTEXTIDR_EL1 would usually be used.\n\nPROCID, bits [0:31] - Process Identifier. This field must be programmed with a\n                      unique value that identifies the current process. In\n                      AArch32 state, when TTBCR.EAE is set to 0, CONTEXTIDR.ASID\n                      holds the ASID. In AArch64 state, CONTEXTIDR_EL2 is\n                      independent of the ASID, and for the EL2&0 translation\n                      regime either TTBR0_EL2 or TTBR1_EL2 holds the ASID."
      },
      "CPACR_EL1": {
        "long_name": "Architectural Feature Access Control Register",
        "purpose": "Controls access to trace, SVE, Advanced SIMD and floating-point functionality.\n\nTTA, bit [28]      - Traps EL0 and EL1 System register accesses to all\n                     implemented trace registers to EL1, or to EL2 when it is\n                     implemented and enabled for the current Security state and\n                     HCR_EL2.TGE is 1, from both Execution states as follows.\nFPEN, bits [20:21] - Traps EL0 and EL1 accesses to the SVE, Advanced SIMD, and\n                     floating-point registers to EL1, reported using EC syndrome\n                     value 0x07, or to EL2 reported using EC syndrome value\n                     0x00, when EL2 is implemented and enabled for the current\n                     Security state and HCR_EL2.TGE is 1, from both Execution\n                     states as follows.\nZEN, bits [16:17]  - Traps SVE instructions and instructions that access SVE\n                     System registers at EL0 and EL1 to EL1, or to EL2 when it\n                     is implemented and enabled for the current Security state\n                     and HCR_EL2.TGE is 1."
      },
      "CPTR_EL2": {
        "long_name": "Architectural Feature Trap Register (EL2)",
        "purpose": "Controls:\n\n  - Trapping to EL2 of access to CPACR, CPACR_EL1, trace functionality, and to\nSVE, Advanced SIMD and floating-point functionality.\n  - EL2 access to trace functionality, and to SVE, Advanced SIMD and floating-\npoint functionality.\n\nTCPAC, bit [31]    - When HCR_EL2.TGE is 0, traps EL1 accesses to CPACR_EL1\n                     reported using EC syndrome value 0x18, and accesses to\n                     CPACR reported using EC syndrome value 0x03, to EL2 when\n                     EL2 is enabled in the current Security state.\nTAM, bit [30]      - Trap Activity Monitor access.\nTTA, bit [28]      - Traps System register accesses to all implemented trace\n                     registers to EL2 when EL2 is enabled in the current\n                     Security state, from both Execution states, as follows.\nFPEN, bits [20:21] - Traps EL0, EL2 and, when HCR_EL2.TGE is 0, EL1 accesses to\n                     the SVE, Advanced SIMD and floating-point registers to EL2\n                     when EL2 is enabled in the current Security state, from\n                     both Execution states.\nZEN, bits [16:17]  - Traps execution at EL2, EL1, and EL0 of SVE instructions or\n                     instructions that access SVE System registers to EL2 when\n                     EL2 is enabled in the current Security state."
      },
      "CPTR_EL3": {
        "long_name": "Architectural Feature Trap Register (EL3)",
        "purpose": "Controls trapping to EL3 of access to CPACR_EL1, CPTR_EL2, trace functionality\nand registers associated with SVE, Advanced SIMD and floating-point execution.\nAlso controls EL3 access to trace functionality and registers associated with\nSVE, Advanced SIMD and floating-point execution.\n\nTCPAC, bit [31] - Traps all of the following to EL3, from both Security states\n                  and both Execution states.\nTAM, bit [30]   - Trap Activity Monitor access.\nTTA, bit [20]   - Traps System register accesses.\nTFP, bit [10]   - Traps all accesses to SVE, Advanced SIMD and floating-point\n                  functionality, from all Exception levels, both Security\n                  states, and both Execution states, to EL3.\nEZ, bit [8]     - Traps all accesses to SVE functionality and registers from all\n                  Exception levels, and both Security states, to EL3."
      },
      "CSSELR_EL1": {
        "long_name": "Cache Size Selection Register",
        "purpose": "Selects the current Cache Size ID Register, CCSIDR_EL1, by specifying the\nrequired cache level and the cache type (either instruction or data cache).\n\nTnD, bit [4]      - Allocation Tag not Data bit.\n                        0b0 Data, Instruction or Unified cache.\n                        0b1 Separate Allocation Tag cache.\n                    When CSSELR_EL1.InD == 1, this bit is res0. If\n                    CSSELR_EL1.Level is programmed to a cache level that is not\n                    implemented, then the value for this field on a read of\n                    CSSELR_EL1 is unknown.\nLevel, bits [1:3] - Cache level of required cache.\n                        0b000 Level 1 cache.\n                        0b001 Level 2 cache.\n                        0b010 Level 3 cache.\n                        0b011 Level 4 cache.\n                        0b100 Level 5 cache.\n                        0b101 Level 6 cache.\n                        0b110 Level 7 cache.\n                    All other values are reserved. If CSSELR_EL1.Level is\n                    programmed to a cache level that is not implemented, then\n                    the value for this field on a read of CSSELR_EL1 is unknown.\nInD, bit [0]      - Instruction not Data bit.\n                        0b0 Data or unified cache.\n                        0b1 Instruction cache.\n                    If CSSELR_EL1.Level is programmed to a cache level that is\n                    not implemented, then a read of CSSELR_EL1 is constrained\n                    unpredictable, and returns unknown values for\n                    CSSELR_EL1.{Level, InD}."
      },
      "CTR_EL0": {
        "long_name": "Cache Type Register",
        "purpose": "Provides information about the architecture of the caches.\n\nTminLine, bits [32:37] - Tag minimum Line.\nDIC, bit [29]          - Instruction cache invalidation requirements for\n                         instruction to data coherence.\nIDC, bit [28]          - Data cache clean requirements for instruction to data\n                         coherence.\nCWG, bits [24:27]      - Cache writeback granule.\nERG, bits [20:23]      - Exclusives reservation granule.\nDminLine, bits [16:19] - Log_2 of the number of words in the smallest cache line\n                         of all the data caches and unified caches that are\n                         controlled by the PE.\nL1Ip, bits [14:15]     - Level 1 instruction cache policy.\nIminLine, bits [0:3]   - Log_2 of the number of words in the smallest cache line\n                         of all the instruction caches that are controlled by\n                         the PE."
      },
      "CurrentEL": {
        "long_name": "Current Exception Level",
        "purpose": "Holds the current Exception level.\n\nEL, bits [2:3] - Current Exception level. Possible values of this field are:\n                     0b00 EL0\n                     0b01 EL1\n                     0b10 EL2\n                     0b11 EL3\n                 When the HCR_EL2.NV bit is 1, EL1 read accesses to the\n                 CurrentEL register return the value of 0b10 in this field."
      },
      "DACR32_EL2": {
        "long_name": "Domain Access Control Register",
        "purpose": "Allows access to the AArch32 DACR register from AArch64 state only. Its value\nhas no effect on execution in AArch64 state.\n\nD<n>, bits [0:31] - Domain n access permission, where n = 0 to 15. Permitted\n                    values are:\n                        0b00 No access. Any access to the domain generates a\n                    Domain fault.\n                        0b01 Client. Accesses are checked against the permission\n                    bits in the translation tables.\n                        0b11 Manager. Accesses are not checked against the\n                    permission bits in the translation tables.\n                    The value 0b10 is reserved."
      },
      "DAIF": {
        "long_name": "Interrupt Mask Bits",
        "purpose": "Allows access to the interrupt mask bits.\n\nD, bit [9] - Process state D mask. The possible values of this bit are:\n                 0b0 Watchpoint, Breakpoint, and Software Step exceptions\n             targeted at the current Exception level are not masked.\n                 0b1 Watchpoint, Breakpoint, and Software Step exceptions\n             targeted at the current Exception level are masked.\n             When the target Exception level of the debug exception is higher\n             than the current Exception level, the exception is not masked by\n             this bit.\nA, bit [8] - SError interrupt mask bit. The possible values of this bit are:\n                 0b0 Exception not masked.\n                 0b1 Exception masked.\nI, bit [7] - IRQ mask bit. The possible values of this bit are:\n                 0b0 Exception not masked.\n                 0b1 Exception masked.\nF, bit [6] - FIQ mask bit. The possible values of this bit are:\n                 0b0 Exception not masked.\n                 0b1 Exception masked."
      },
      "DBGAUTHSTATUS_EL1": {
        "long_name": "Debug Authentication Status register",
        "purpose": "Provides information about the state of the implementation defined\nauthentication interface for debug.\n\nSNID, bits [6:7]  - Secure non-invasive debug.\nSNID, bits [6:7]  - Secure non-invasive debug.\nSID, bits [4:5]   - Secure invasive debug.\nNSNID, bits [2:3] - Non-secure non-invasive debug.\nNSNID, bits [2:3] - Non-secure non-invasive debug.\nNSID, bits [0:1]  - Non-secure invasive debug."
      },
      "DBGBCR<n>_EL1": {
        "long_name": "Debug Breakpoint Control Registers",
        "purpose": "Holds control information for a breakpoint. Forms breakpoint n together with\nvalue register DBGBVR<n>_EL1.\n\nBT, bits [20:23]  - Breakpoint Type.\nLBN, bits [16:19] - Linked breakpoint number.\nSSC, bits [14:15] - Security state control.\nHMC, bit [13]     - Higher mode control.\nBAS, bits [5:8]   - Byte address select.\nPMC, bits [1:2]   - Privilege mode control.\nE, bit [0]        - Enable breakpoint DBGBVR<n>_EL1."
      },
      "DBGBVR<n>_EL1": {
        "long_name": "Debug Breakpoint Value Registers",
        "purpose": "Holds a virtual address, or a VMID and/or a context ID, for use in breakpoint\nmatching. Forms breakpoint n together with control register DBGBCR<n>_EL1.\n\nVA[52:49], bits [49:52] - Extension to VA[48:2]. See VA[48:2] for more details.\nRESS[3:0], bits [49:52] - Extension to RESS[14:4]. See RESS[14:4] for more\n                          details.\nVA[48:2], bits [2:48]   - Bits[48:2] of the address value for comparison. When\n                          ARMv8.2-LVA is implemented, VA[52:49] forms the upper\n                          part of the address value. Otherwise, VA[52:49] are\n                          RESS."
      },
      "DBGCLAIMCLR_EL1": {
        "long_name": "Debug CLAIM Tag Clear register",
        "purpose": "Used by software to read the values of the CLAIM tag bits, and to clear CLAIM\ntag bits to 0.\n\nThe architecture does not define any functionality for the CLAIM tag bits.\n\nCLAIM tags are typically used for communication between the debugger and target\nsoftware.\n\nUsed in conjunction with the DBGCLAIMSET_EL1 register.\n\nCLAIM, bits [0:7] - Read or clear CLAIM tag bits. Reading this field returns the\n                    current value of the CLAIM tag bits. Writing a 1 to one of\n                    these bits clears the corresponding CLAIM tag bit to 0. This\n                    is an indirect write to the CLAIM tag bits. A single write\n                    operation can clear multiple CLAIM tag bits to 0. Writing 0\n                    to one of these bits has no effect."
      },
      "DBGCLAIMSET_EL1": {
        "long_name": "Debug CLAIM Tag Set register",
        "purpose": "Used by software to set the CLAIM tag bits to 1.\n\nThe architecture does not define any functionality for the CLAIM tag bits.\n\nCLAIM tags are typically used for communication between the debugger and target\nsoftware.\n\nUsed in conjunction with the DBGCLAIMCLR_EL1 register.\n\nCLAIM, bits [0:7] - Set CLAIM tag bits. This field is RAO. Writing a 1 to one of\n                    these bits sets the corresponding CLAIM tag bit to 1. This\n                    is an indirect write to the CLAIM tag bits. A single write\n                    operation can set multiple CLAIM tag bits to 1. Writing 0 to\n                    one of these bits has no effect."
      },
      "DBGDTRRX_EL0": {
        "long_name": "Debug Data Transfer Register, Receive",
        "purpose": "Transfers data from an external debugger to the PE. For example, it is used by a\ndebugger transferring commands and data to a debug target. See DBGDTR_EL0 for\nadditional architectural mappings. It is a component of the Debug Communications\nChannel.\n\nbits [0:31] - Update DTRRX. Reads of this register:\n                -  If RXfull is set to 1, return the last value written to\n              DTRRX.\n                -  If RXfull is set to 0, return an unknown value. After the\n              read, RXfull is cleared to 0. For the full behavior of the Debug\n              Communications Channel, see The Debug Communication Channel and\n              Instruction Transfer Register."
      },
      "DBGDTRTX_EL0": {
        "long_name": "Debug Data Transfer Register, Transmit",
        "purpose": "Transfers data from the PE to an external debugger. For example, it is used by a\ndebug target to transfer data to the debugger. See DBGDTR_EL0 for additional\narchitectural mappings. It is a component of the Debug Communication Channel.\n\nbits [0:31] - Return DTRTX. Writes to this register:\n                -  If TXfull is set to 1, set DTRRX and DTRTX to unknown.\n                -  If TXfull is set to 0, update the value in DTRTX. After the\n              write, TXfull is set to 1. For the full behavior of the Debug\n              Communications Channel, see The Debug Communication Channel and\n              Instruction Transfer Register."
      },
      "DBGDTR_EL0": {
        "long_name": "Debug Data Transfer Register, half-duplex",
        "purpose": "Transfers 64 bits of data between the PE and an external debugger. Can transfer\nboth ways using only a single register.\n\nHighWord, bits [32:63] - Writes to this register set DTRRX to the value in this\n                         field and do not change RXfull. Reads of this register:\n                           -  If RXfull is set to 1, return the last value\n                         written to DTRTX.\n                           -  If RXfull is set to 0, return an unknown value.\n                         After the read, RXfull is cleared to 0.\nLowWord, bits [0:31]   - Writes to this register set DTRTX to the value in this\n                         field and set TXfull to 1. Reads of this register:\n                           -  If RXfull is set to 1, return the last value\n                         written to DTRRX.\n                           -  If RXfull is set to 0, return an unknown value.\n                         After the read, RXfull is cleared to 0."
      },
      "DBGPRCR_EL1": {
        "long_name": "Debug Power Control Register",
        "purpose": "Controls behavior of the PE on powerdown request.\n\nCORENPDRQ, bit [0] - Core no powerdown request. Requests emulation of powerdown.\n                     This request is typically passed to an external power\n                     controller. This means that whether a request causes power\n                     up is dependent on the implementation defined nature of the\n                     system. The power controller must not allow the Core power\n                     domain to switch off while this bit is 1.\n                         0b0 If the system responds to a powerdown request, it\n                     powers down Core power domain.\n                         0b1 If the system responds to a powerdown request, it\n                     does not powerdown the Core power domain, but instead\n                     emulates a powerdown of that domain.\nCORENPDRQ, bit [0] - Core no powerdown request. Requests emulation of powerdown.\n                     This request is typically passed to an external power\n                     controller. This means that whether a request causes power\n                     up is dependent on the implementation defined nature of the\n                     system. The power controller must not allow the Core power\n                     domain to switch off while this bit is 1.\n                         0b0 If the system responds to a powerdown request, it\n                     powers down Core power domain.\n                         0b1 If the system responds to a powerdown request, it\n                     does not powerdown the Core power domain, but instead\n                     emulates a powerdown of that domain."
      },
      "DBGVCR32_EL2": {
        "long_name": "Debug Vector Catch Register",
        "purpose": "Allows access to the AArch32 register DBGVCR from AArch64 state only. Its value\nhas no effect on execution in AArch64 state.\n\nNSF, bit [31] - FIQ vector catch enable in Non-secure state. The exception\n                vector offset is 0x1C.\nNSI, bit [30] - IRQ vector catch enable in Non-secure state. The exception\n                vector offset is 0x18.\nNSD, bit [28] - Data Abort vector catch enable in Non-secure state. The\n                exception vector offset is 0x10.\nNSP, bit [27] - Prefetch Abort vector catch enable in Non-secure state. The\n                exception vector offset is 0x0C.\nNSS, bit [26] - Supervisor Call (SVC) vector catch enable in Non-secure state.\n                The exception vector offset is 0x08.\nNSU, bit [25] - Undefined Instruction vector catch enable in Non-secure state.\n                The exception vector offset is 0x04.\nSF, bit [7]   - FIQ vector catch enable in Secure state. The exception vector\n                offset is 0x1C.\nSI, bit [6]   - IRQ vector catch enable in Secure state. The exception vector\n                offset is 0x18.\nSD, bit [4]   - Data Abort vector catch enable in Secure state. The exception\n                vector offset is 0x10.\nSP, bit [3]   - Prefetch Abort vector catch enable in Secure state. The\n                exception vector offset is 0x0C.\nSS, bit [2]   - Supervisor Call (SVC) vector catch enable in Secure state. The\n                exception vector offset is 0x08.\nSU, bit [1]   - Undefined Instruction vector catch enable in Secure state. The\n                exception vector offset is 0x04."
      },
      "DBGWCR<n>_EL1": {
        "long_name": "Debug Watchpoint Control Registers",
        "purpose": "Holds control information for a watchpoint. Forms watchpoint n together with\nvalue register DBGWVR<n>_EL1.\n\nMASK, bits [24:28] - Address mask.\nWT, bit [20]       - Watchpoint type.\nLBN, bits [16:19]  - Linked breakpoint number.\nSSC, bits [14:15]  - Security state control.\nHMC, bit [13]      - Higher mode control.\nBAS, bits [5:12]   - Byte address select.\nLSC, bits [3:4]    - Load/store control.\nPAC, bits [1:2]    - Privilege of access control.\nE, bit [0]         - Enable watchpoint n."
      },
      "DBGWVR<n>_EL1": {
        "long_name": "Debug Watchpoint Value Registers",
        "purpose": "Holds a data address value for use in watchpoint matching. Forms watchpoint n\ntogether with control register DBGWCR<n>_EL1.\n\nVA[52:49], bits [49:52] - Extension to VA[48:2]. See VA[48:2] for more details.\nRESS[3:0], bits [49:52] - Extension to RESS[14:4]. See RESS[14:4] for more\n                          details.\nVA[48:2], bits [2:48]   - Bits[48:2] of the address value for comparison. When\n                          ARMv8.2-LVA is implemented, VA[52:49] forms the upper\n                          part of the address value. Otherwise, VA[52:49] are\n                          RESS. Arm deprecates setting DBGWVR<n>_EL1[2] == 1."
      },
      "DCZID_EL0": {
        "long_name": "Data Cache Zero ID register",
        "purpose": "Indicates the block size that is written with byte values of 0 by the DC ZVA\n(Data Cache Zero by Address) System instruction.\n\nIf ARMv8.5-MemTag is implemented, this register also indicates the granularity\nat which the DC GVA and DC GZVA instructions write.\n\nDZP, bit [4]   - Data Zero Prohibited. This field indicates whether use of DC\n                 ZVA instructions is permitted or prohibited. If ARMv8.5-MemTag\n                 is implemented, this field also indicates whether use of the DC\n                 GVA and DC GZVA instructions are permitted or prohibited.\n                     0b0 Instructions are permitted.\n                     0b1 Instructions are prohibited.\n                 The value read from this field is governed by the access state\n                 and the values of the HCR_EL2.TDZ and SCTLR_EL1.DZE bits.\nBS, bits [0:3] - Log_2 of the block size in words. The maximum size supported is\n                 2KB (value == 9)."
      },
      "DISR_EL1": {
        "long_name": "Deferred Interrupt Status Register",
        "purpose": "Records that an SError interrupt has been consumed by an ESB instruction.\n\nA, bit [31]       - Set to 1 when an ESB instruction defers an asynchronous\n                    SError interrupt. If the implementation does not include any\n                    sources of SError interrupt that can be synchronized by an\n                    Error Synchronization Barrier, then this bit is res0.\nIDS, bit [24]     - Indicates the deferred SError interrupt type.\n                        0b0 Deferred error uses architecturally-defined format.\nAET, bits [10:12] - Asynchronous Error Type. See the description of ESR_ELx.AET\n                    for an SError interrupt.\nEA, bit [9]       - External abort Type. See the description of ESR_ELx.EA for\n                    an SError interrupt.\nDFSC, bits [0:5]  - Fault Status Code. See the description of ESR_ELx.DFSC for\n                    an SError interrupt."
      },
      "DIT": {
        "long_name": "Data Independent Timing",
        "purpose": "Allows access to the Data Independent Timing bit.\n\nDIT, bit [24] - Data Independent Timing.\n                    0b0 The architecture makes no statement about the timing\n                properties of any instructions.\n                    0b1 The architecture requires that:\n                  -  The timing of every load and store instruction is\n                insensitive to the value of the data being loaded or stored.\n                  -  For certain data processing instructions, the instruction\n                takes a time which is independent of:\n                    -  The values of the data supplied in any of its registers.\n                    -  The values of the NZCV flags.\n                  -  For certain data processing instructions, the response of\n                the instruction to asynchronous exceptions does not vary based\n                on:\n                    -  The values of the data supplied in any of its registers.\n                    -  The values of the NZCV flags."
      },
      "DLR_EL0": {
        "long_name": "Debug Link Register",
        "purpose": "In Debug state, holds the address to restart from.\n\nbits [0:63] - Restart address."
      },
      "DSPSR_EL0": {
        "long_name": "Debug Saved Program Status Register",
        "purpose": "Holds the saved process state for Debug state. On entering Debug state, PSTATE\ninformation is written to this register. On exiting Debug state, values are\ncopied from this register to PSTATE.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT[1:0], bits [25:26] - If-Then.\nDIT, bit [24]         - Data Independent Timing.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nSS, bit [21]          - Software Step.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - If-Then.\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4], bit [4]         - Execution state.\nM[3:0], bits [0:3]    - AArch32 Mode."
      },
      "ELR_EL1": {
        "long_name": "Exception Link Register (EL1)",
        "purpose": "When taking an exception to EL1, holds the address to return to.\n\nbits [0:63] - Return address. An exception return from EL1 using AArch64 makes\n              ELR_EL1 become unknown."
      },
      "ELR_EL2": {
        "long_name": "Exception Link Register (EL2)",
        "purpose": "When taking an exception to EL2, holds the address to return to.\n\nbits [0:63] - Return address. An exception return from EL2 using AArch64 makes\n              ELR_EL2 become unknown. When EL2 is in AArch32 Execution state and\n              an exception is taken from EL0, EL1, or EL2 to EL3 and AArch64\n              execution, the upper 32-bits of ELR_EL2 are either set to 0 or\n              hold the same value that they did before AArch32 execution. Which\n              option is adopted is determined by an implementation, and might\n              vary dynamically within an implementation. Correspondingly\n              software must regard the value as being an unknown choice between\n              the two values."
      },
      "ELR_EL3": {
        "long_name": "Exception Link Register (EL3)",
        "purpose": "When taking an exception to EL3, holds the address to return to.\n\nbits [0:63] - Return address. An exception return from EL3 using AArch64 makes\n              ELR_EL3 become unknown."
      },
      "ERRIDR_EL1": {
        "long_name": "Error Record ID Register",
        "purpose": "Defines the highest numbered index of the error records that can be accessed\nthrough the Error Record System registers.\n\nNUM, bits [0:15] - Highest numbered index of the records that can be accessed\n                   through the Error Record System registers plus one. Zero\n                   indicates that no records can be accessed through the Error\n                   Record System registers. Each implemented record is owned by\n                   a node. A node might own multiple records."
      },
      "ERRSELR_EL1": {
        "long_name": "Error Record Select Register",
        "purpose": "Selects an error record to be accessed through the Error Record System\nregisters.\n\nSEL, bits [0:15] - Selects the record accessed through the ERX registers. For\n                   example, if ERRSELR_EL1.SEL is set to 0x4, then direct reads\n                   and writes of ERXSTATUS_EL1 access ERR4STATUS.\n                   If ERRSELR_EL1.SEL is set to a value greater than or equal to\n                   ERRIDR_EL1.NUM, then all of the following apply:\n                     -  The value read back from ERRSELR_EL1.SEL is unknown.\n                     -  One of the following occurs:\n                       -  An unknown error record is selected.\n                       -  The ERX* registers are RAZ/WI.\n                       -  ERX* register reads and writes are NOPs.\n                       -  ERX* register reads and writes are undefined."
      },
      "ERXADDR_EL1": {
        "long_name": "Selected Error Record Address Register",
        "purpose": "Accesses ERR<n>ADDR for the error record selected by ERRSELR_EL1.SEL.\n\nbits [0:63] - ERXADDR_EL1 accesses ERR<n>ADDR, where n is the value in\n              ERRSELR_EL1.SEL."
      },
      "ERXCTLR_EL1": {
        "long_name": "Selected Error Record Control Register",
        "purpose": "Accesses ERR<n>CTLR for the error record selected by ERRSELR_EL1.SEL.\n\nbits [0:63] - ERXCTLR_EL1 accesses ERR<n>CTLR, where n is the value in\n              ERRSELR_EL1.SEL."
      },
      "ERXFR_EL1": {
        "long_name": "Selected Error Record Feature Register",
        "purpose": "Accesses ERR<n>FR for the error record selected by ERRSELR_EL1.SEL.\n\nbits [0:63] - ERXFR_EL1 accesses ERR<n>FR, where n is the value in\n              ERRSELR_EL1.SEL."
      },
      "ERXMISC0_EL1": {
        "long_name": "Selected Error Record Miscellaneous Register 0",
        "purpose": "Accesses ERR<n>MISC0 for the error record selected by ERRSELR_EL1.SEL.\n\nbits [0:63] - ERXMISC0_EL1 accesses ERR<n>MISC0, where n is the value in\n              ERRSELR_EL1.SEL."
      },
      "ERXMISC1_EL1": {
        "long_name": "Selected Error Record Miscellaneous Register 1",
        "purpose": "Accesses ERR<n>MISC1 for the error record selected by ERRSELR_EL1.SEL.\n\nbits [0:63] - ERXMISC1_EL1 accesses ERR<n>MISC1, where n is the value in\n              ERRSELR_EL1.SEL."
      },
      "ERXMISC2_EL1": {
        "long_name": "Selected Error Record Miscellaneous Register 2",
        "purpose": "Accesses ERR<n>MISC2 for the error record selected by ERRSELR_EL1.SEL.\n\nbits [0:63] - ERXMISC2_EL1 accesses ERR<n>MISC2, where n is the value in\n              ERRSELR_EL1.SEL."
      },
      "ERXMISC3_EL1": {
        "long_name": "Selected Error Record Miscellaneous Register 3",
        "purpose": "Accesses ERR<n>MISC3 for the error record selected by ERRSELR_EL1.SEL.\n\nbits [0:63] - ERXMISC3_EL1 accesses ERR<n>MISC3, where n is the value in\n              ERRSELR_EL1.SEL."
      },
      "ERXPFGCDN_EL1": {
        "long_name": "Selected Pseudo-fault Generation Countdown Register",
        "purpose": "Accesses the ERR<n>PFGCDN register for the error record selected by\nERRSELR_EL1.SEL.\n\nbits [0:63] - ERXPFGCDN_EL1 accesses ERR<n>PFGCDN, where n is the value in\n              ERRSELR_EL1.SEL."
      },
      "ERXPFGCTL_EL1": {
        "long_name": "Selected Pseudo-fault Generation Control Register",
        "purpose": "Accesses the ERR<n>PFGCTL register for the error record selected by\nERRSELR_EL1.SEL.\n\nbits [0:63] - ERXPFGCTL_EL1 accesses ERR<n>PFGCTL, where n is the value in\n              ERRSELR_EL1.SEL."
      },
      "ERXPFGF_EL1": {
        "long_name": "Selected Pseudo-fault Generation Feature Register",
        "purpose": "Accesses the ERR<n>PFGF register for the error record selected by\nERRSELR_EL1.SEL.\n\nbits [0:63] - ERXPFGF_EL1 accesses ERR<n>PFGF, where n is the value in\n              ERRSELR_EL1.SEL."
      },
      "ERXSTATUS_EL1": {
        "long_name": "Selected Error Record Primary Status Register",
        "purpose": "Accesses ERR<n>STATUS for the error record selected by ERRSELR_EL1.SEL.\n\nbits [0:63] - ERXSTATUS_EL1 accesses ERR<n>STATUS, where n is the value in\n              ERRSELR_EL1.SEL."
      },
      "ESR_EL1": {
        "long_name": "Exception Syndrome Register (EL1)",
        "purpose": "Holds syndrome information for an exception taken to EL1.\n\nEC, bits [26:31] - Exception Class.\nIL, bit [25]     - Instruction Length for synchronous exceptions.\nISS, bits [0:24] - Instruction Specific Syndrome."
      },
      "ESR_EL2": {
        "long_name": "Exception Syndrome Register (EL2)",
        "purpose": "Holds syndrome information for an exception taken to EL2.\n\nEC, bits [26:31] - Exception Class.\nIL, bit [25]     - Instruction Length for synchronous exceptions.\nISS, bits [0:24] - Instruction Specific Syndrome."
      },
      "ESR_EL3": {
        "long_name": "Exception Syndrome Register (EL3)",
        "purpose": "Holds syndrome information for an exception taken to EL3.\n\nEC, bits [26:31] - Exception Class.\nIL, bit [25]     - Instruction Length for synchronous exceptions.\nISS, bits [0:24] - Instruction Specific Syndrome."
      },
      "FAR_EL1": {
        "long_name": "Fault Address Register (EL1)",
        "purpose": "Holds the faulting Virtual Address for all synchronous Instruction or Data\nAbort, PC alignment fault and Watchpoint exceptions that are taken to EL1.\n\nbits [0:63] - Faulting Virtual Address for synchronous exceptions taken to EL1."
      },
      "FAR_EL2": {
        "long_name": "Fault Address Register (EL2)",
        "purpose": "Holds the faulting Virtual Address for all synchronous Instruction or Data\nAbort, PC alignment fault and Watchpoint exceptions that are taken to EL2.\n\nbits [0:63] - Faulting Virtual Address for synchronous exceptions taken to EL2."
      },
      "FAR_EL3": {
        "long_name": "Fault Address Register (EL3)",
        "purpose": "Holds the faulting Virtual Address for all synchronous Instruction or Data Abort\nand PC alignment fault exceptions that are taken to EL3.\n\nbits [0:63] - Faulting Virtual Address for synchronous exceptions taken to EL3."
      },
      "FPCR": {
        "long_name": "Floating-point Control Register",
        "purpose": "Controls floating-point behavior.\n\nAHP, bit [26]        - Alternative half-precision control bit:\nDN, bit [25]         - Default NaN mode control bit:\nFZ, bit [24]         - Flush-to-zero mode control bit:\nRMode, bits [22:23]  - Rounding Mode control field.\nStride, bits [20:21] - This field has no function in AArch64 state, and non-zero\n                       values are ignored during execution in AArch64  state. It\n                       is included only for context saving and restoration of\n                       the AArch32 FPSCR.Stride field.\nFZ16, bit [19]       - Flush-to-zero mode control bit on half-precision data-\n                       processing instructions:\nLen, bits [16:18]    - This field has no function in AArch64 state, and non-zero\n                       values are ignored during execution in AArch64  state. It\n                       is included only for context saving and restoration of\n                       the AArch32 FPSCR.Len field.\nIDE, bit [15]        - Input Denormal floating-point exception trap enable.\nIXE, bit [12]        - Inexact floating-point exception trap enable.\nUFE, bit [11]        - Underflow floating-point exception trap enable.\nOFE, bit [10]        - Overflow floating-point exception trap enable.\nDZE, bit [9]         - Divide by Zero floating-point exception trap enable.\nIOE, bit [8]         - Invalid Operation floating-point exception trap enable."
      },
      "FPEXC32_EL2": {
        "long_name": "Floating-Point Exception Control register",
        "purpose": "Allows access to the AArch32 register FPEXC from AArch64 state only. Its value\nhas no effect on execution in AArch64 state.\n\nEX, bit [31]        - Exception bit.\nEN, bit [30]        - Enables access to the Advanced SIMD and floating-point\n                      functionality from all Exception levels, except that\n                      setting this field to 0 does not disable the following.\nDEX, bit [29]       - Defined synchronous exception on floating-point execution.\nFP2V, bit [28]      - FPINST2 instruction valid bit.\nVV, bit [27]        - VECITR valid bit.\nTFV, bit [26]       - Trapped Fault Valid bit.\nVECITR, bits [8:10] - Vector iteration count.\nIDF, bit [7]        - Input Denormal trapped exception bit.\nIXF, bit [4]        - Inexact trapped exception bit.\nUFF, bit [3]        - Underflow trapped exception bit.\nOFF, bit [2]        - Overflow trapped exception bit.\nDZF, bit [1]        - Divide by Zero trapped exception bit.\nIOF, bit [0]        - Invalid Operation trapped exception bit."
      },
      "FPSR": {
        "long_name": "Floating-point Status Register",
        "purpose": "Provides floating-point system status information.\n\nN, bit [31]  - Negative condition flag for AArch32 floating-point comparison\n               operations.\nZ, bit [30]  - Zero condition flag for AArch32 floating-point comparison\n               operations.\nC, bit [29]  - Carry condition flag for AArch32 floating-point comparison\n               operations.\nV, bit [28]  - Overflow condition flag for AArch32 floating-point comparison\n               operations.\nQC, bit [27] - Cumulative saturation bit, Advanced SIMD only.\nIDC, bit [7] - Input Denormal cumulative floating-point exception bit.\nIXC, bit [4] - Inexact cumulative floating-point exception bit.\nUFC, bit [3] - Underflow cumulative floating-point exception bit.\nOFC, bit [2] - Overflow cumulative floating-point exception bit.\nDZC, bit [1] - Divide by Zero cumulative floating-point exception bit.\nIOC, bit [0] - Invalid Operation cumulative floating-point exception bit."
      },
      "GCR_EL1": {
        "long_name": "Tag Control Register.",
        "purpose": "Tag Control Register.\n\nRRND, bit [16]       - Controls whether RandomTag() generates a deterministic\n                       value solely based on the contents of RGSR_EL1, or a non-\n                       deterministic value.\n                           0b0 Generate a deterministic value based on RGSR_EL1.\n                           0b1 Generate an implementation defined non-\n                       deterministic value.\n                       When the value of GCR_EL1.RRND is 1, the value generated\n                       does not need to be cryptographically random. A similar\n                       algorithm to that used when RRND=0 but with free running\n                       clock is sufficient.\nExclude, bits [0:15] - Allocation Tag values excluded from selection by\n                       ChooseNonExcludedTag()."
      },
      "GMID_EL1": {
        "long_name": " Multiple tag transfer ID register",
        "purpose": "Indicates the block size that is accessed by the LDGM and STGM System\ninstructions.\n\nBS, bits [0:3] - Log_2 of the block size in words. The minimum supported size is\n                 16B (value == 2) and the maximum is 256B (value == 6)."
      },
      "HACR_EL2": {
        "long_name": "Hypervisor Auxiliary Control Register",
        "purpose": "Controls trapping to EL2 of implementation defined aspects of EL1 or EL0\noperation.\n\nArm recommends that the values in this register do not cause unnecessary traps\nto EL2 when HCR_EL2.{E2H, TGE} == {1, 1}."
      },
      "HAFGRTR_EL2": {
        "long_name": "Hypervisor Activity Monitors Fine-Grained Read Trap Register",
        "purpose": "Provides controls for traps of MRS reads of Activity Monitors System registers.\n\nAMEVTYPER115_EL0, bit [49] - Trap MRS reads of AMEVTYPER1<15>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<15> at\n                             EL0 using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR115_EL0, bit [48]  - Trap MRS reads of AMEVCNTR1<15>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<15> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER114_EL0, bit [47] - Trap MRS reads of AMEVTYPER1<14>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<14> at\n                             EL0 using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR114_EL0, bit [46]  - Trap MRS reads of AMEVCNTR1<14>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<14> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER113_EL0, bit [45] - Trap MRS reads of AMEVTYPER1<13>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<13> at\n                             EL0 using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR113_EL0, bit [44]  - Trap MRS reads of AMEVCNTR1<13>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<13> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER112_EL0, bit [43] - Trap MRS reads of AMEVTYPER1<12>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<12> at\n                             EL0 using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR112_EL0, bit [42]  - Trap MRS reads of AMEVCNTR1<12>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<12> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER111_EL0, bit [41] - Trap MRS reads of AMEVTYPER1<11>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<11> at\n                             EL0 using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR111_EL0, bit [40]  - Trap MRS reads of AMEVCNTR1<11>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<11> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER110_EL0, bit [39] - Trap MRS reads of AMEVTYPER1<10>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<10> at\n                             EL0 using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR110_EL0, bit [38]  - Trap MRS reads of AMEVCNTR1<10>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<10> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER19_EL0, bit [37]  - Trap MRS reads of AMEVTYPER1<9>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<9> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR19_EL0, bit [36]   - Trap MRS reads of AMEVCNTR1<9>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<9> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER18_EL0, bit [35]  - Trap MRS reads of AMEVTYPER1<8>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<8> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR18_EL0, bit [34]   - Trap MRS reads of AMEVCNTR1<8>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<8> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER17_EL0, bit [33]  - Trap MRS reads of AMEVTYPER1<7>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<7> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR17_EL0, bit [32]   - Trap MRS reads of AMEVCNTR1<7>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<7> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER16_EL0, bit [31]  - Trap MRS reads of AMEVTYPER1<6>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<6> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR16_EL0, bit [30]   - Trap MRS reads of AMEVCNTR1<6>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<6> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER15_EL0, bit [29]  - Trap MRS reads of AMEVTYPER1<5>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<5> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR15_EL0, bit [28]   - Trap MRS reads of AMEVCNTR1<5>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<5> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER14_EL0, bit [27]  - Trap MRS reads of AMEVTYPER1<4>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<4> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR14_EL0, bit [26]   - Trap MRS reads of AMEVCNTR1<4>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<4> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER13_EL0, bit [25]  - Trap MRS reads of AMEVTYPER1<3>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<3> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR13_EL0, bit [24]   - Trap MRS reads of AMEVCNTR1<3>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<3> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER12_EL0, bit [23]  - Trap MRS reads of AMEVTYPER1<2>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<2> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR12_EL0, bit [22]   - Trap MRS reads of AMEVCNTR1<2>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<2> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER11_EL0, bit [21]  - Trap MRS reads of AMEVTYPER1<1>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<1> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR11_EL0, bit [20]   - Trap MRS reads of AMEVCNTR1<1>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<1> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVTYPER10_EL0, bit [19]  - Trap MRS reads of AMEVTYPER1<0>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVTYPER1<0> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR10_EL0, bit [18]   - Trap MRS reads of AMEVCNTR1<0>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR1<0> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMCNTEN1, bit [17]         - Trap MRS reads and MRC reads of multiple System\n                             registers.\nAMEVCNTR03_EL0, bit [4]    - Trap MRS reads of AMEVCNTR0<3>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR0<3> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR02_EL0, bit [3]    - Trap MRS reads of AMEVCNTR0<2>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR0<2> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR01_EL0, bit [2]    - Trap MRS reads of AMEVCNTR0<1>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR0<1> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMEVCNTR00_EL0, bit [1]    - Trap MRS reads of AMEVCNTR0<0>_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of AMEVCNTR0<0> at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nAMCNTEN0, bit [0]          - Trap MRS reads and MRC reads of multiple System\n                             registers."
      },
      "HCR_EL2": {
        "long_name": "Hypervisor Configuration Register",
        "purpose": "Provides configuration controls for virtualization, including defining whether\nvarious operations are trapped to EL2.\n\nTWEDEL, bits [60:63] - TWE Delay.\nTWEDEn, bit [59]     - TWE Delay Enable.\nTID5, bit [58]       - Trap ID group 5.\nDCT, bit [57]        - Default Cacheability Tagging.\nATA, bit [56]        - Allocation Tag Access.\nTTLBOS, bit [55]     - Trap TLB maintenance instructions that operate on the\n                       Outer Shareable domain.\nTTLBIS, bit [54]     - Trap TLB maintenance instructions that operate on the\n                       Inner Shareable domain.\nEnSCXT, bit [53]     - Enable Access to the SCXTNUM_EL1 and SCXTNUM_EL0\n                       registers.\nTOCU, bit [52]       - Trap cache maintenance instructions that operate to the\n                       Point of Unification.\nAMVOFFEN, bit [51]   - Activity Monitors Virtual Offsets Enable.\nTICAB, bit [50]      - Trap ICIALLUIS/IC IALLUIS cache maintenance instructions.\nTID4, bit [49]       - Trap ID group 4.\nFIEN, bit [47]       - Fault Injection Enable.\nFWB, bit [46]        - Defines the combined cacheability attributes in a 2 stage\n                       translation regime.\nNV2, bit [45]        - Nested Virtualization.\nAT, bit [44]         - Address Translation.\nNV1, bit [43]        - Nested Virtualization.\nNV1, bit [43]        - Nested Virtualization.\nNV, bit [42]         - Nested Virtualization.\nNV, bit [42]         - Nested Virtualization.\nAPI, bit [41]        - Controls the use of instructions related to Pointer\n                       Authentication.\nAPK, bit [40]        - Trap registers holding \"key\" values for Pointer\n                       Authentication.\nMIOCNCE, bit [38]    - Mismatched Inner/Outer Cacheable Non-Coherency Enable,\n                       for the EL1&0 translation regimes.\nTEA, bit [37]        - Route synchronous External abort exceptions to EL2.\nTERR, bit [36]       - Trap Error record accesses.\nTLOR, bit [35]       - Trap LOR registers.\nE2H, bit [34]        - EL2 Host.\nID, bit [33]         - Stage 2 Instruction access cacheability disable.\nCD, bit [32]         - Stage 2 Data access cacheability disable.\nRW, bit [31]         - Execution state control for lower Exception levels:\nTRVM, bit [30]       - Trap Reads of Virtual Memory controls.\nHCD, bit [29]        - HVC instruction disable.\nTDZ, bit [28]        - Trap DC ZVA instructions.\nTGE, bit [27]        - Trap General Exceptions, from EL0.\nTVM, bit [26]        - Trap Virtual Memory controls.\nTTLB, bit [25]       - Trap TLB maintenance instructions.\nTTLB, bit [25]       - Trap TLB maintenance instructions.\nTPU, bit [24]        - Trap cache maintenance instructions that operate to the\n                       Point of Unification.\nTPCP, bit [23]       - Trap data or unified cache maintenance instructions that\n                       operate to the Point of Coherency or Persistence.\nTPC, bit [23]        - Trap data or unified cache maintenance instructions that\n                       operate to the Point of Coherency.\nTSW, bit [22]        - Trap data or unified cache maintenance instructions that\n                       operate by Set/Way.\nTACR, bit [21]       - Trap Auxiliary Control Registers.\nTIDCP, bit [20]      - Trap implementation defined functionality.\nTSC, bit [19]        - Trap SMC instructions.\nTID3, bit [18]       - Trap ID group 3.\nTID2, bit [17]       - Trap ID group 2.\nTID1, bit [16]       - Trap ID group 1.\nTID0, bit [15]       - Trap ID group 0.\nTWE, bit [14]        - Traps EL0 and EL1 execution of WFE instructions to EL2,\n                       when EL2 is enabled in the current Security state, from\n                       both Execution states, reported using EC syndrome value\n                       0x01.\nTWI, bit [13]        - Traps EL0 and EL1 execution of WFI instructions to EL2,\n                       when EL2 is enabled in the current Security state, from\n                       both Execution states, reported using EC syndrome value\n                       0x01.\nDC, bit [12]         - Default Cacheability.\nBSU, bits [10:11]    - Barrier Shareability upgrade.\nFB, bit [9]          - Force broadcast.\nVSE, bit [8]         - Virtual SError interrupt.\nVI, bit [7]          - Virtual IRQ Interrupt.\nVF, bit [6]          - Virtual FIQ Interrupt.\nAMO, bit [5]         - Physical SError interrupt routing.\nIMO, bit [4]         - Physical IRQ Routing.\nFMO, bit [3]         - Physical FIQ Routing.\nPTW, bit [2]         - Protected Table Walk.\nSWIO, bit [1]        - Set/Way Invalidation Override.\nVM, bit [0]          - Virtualization enable."
      },
      "HDFGRTR_EL2": {
        "long_name": "Hypervisor Debug Fine-Grained Read Trap Register",
        "purpose": "Provides controls for traps of MRS and MRC reads of debug, trace, PMU, and\nStatistical Profiling System registers.\n\nPMUSERENR_EL0, bit [57]    - Trap MRS reads of PMUSERENR_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of PMUSERENR at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nTRCVICTLR, bit [48]        - Trap MRS reads of TRCVICTLR at EL1 using AArch64 to\n                             EL2.\nTRCSTATR, bit [47]         - Trap MRS reads of TRCSTATR at EL1 using AArch64 to\n                             EL2.\nTRCSSCSRn, bit [46]        - Trap MRS reads of TRCSSCSR<n> at EL1 using AArch64\n                             to EL2.\nTRCSEQSTR, bit [45]        - Trap MRS reads of TRCSEQSTR at EL1 using AArch64 to\n                             EL2.\nTRCPRGCTLR, bit [44]       - Trap MRS reads of TRCPRGCTLR at EL1 using AArch64\n                             to EL2.\nTRCOSLSR, bit [43]         - Trap MRS reads of TRCOSLSR at EL1 using AArch64 to\n                             EL2.\nTRCIMSPECn, bit [41]       - Trap MRS reads of TRCIMSPEC<n> at EL1 using AArch64\n                             to EL2.\nTRCID, bit [40]            - Trap MRS reads of multiple System registers.\nTRCCNTVRn, bit [37]        - Trap MRS reads of TRCCNTVR<n> at EL1 using AArch64\n                             to EL2.\nTRCCLAIM, bit [36]         - Trap MRS reads of multiple System registers.\nTRCAUXCTLR, bit [35]       - Trap MRS reads of TRCAUXCTLR at EL1 using AArch64\n                             to EL2.\nTRCAUTHSTATUS, bit [34]    - Trap MRS reads of TRCAUTHSTATUS at EL1 using\n                             AArch64 to EL2.\nTRC, bit [33]              - Trap MRS reads of multiple System registers.\nPMSLATFR_EL1, bit [32]     - Trap MRS reads of PMSLATFR_EL1 at EL1 using AArch64\n                             to EL2.\nPMSIRR_EL1, bit [31]       - Trap MRS reads of PMSIRR_EL1 at EL1 using AArch64\n                             to EL2.\nPMSIDR_EL1, bit [30]       - Trap MRS reads of PMSIDR_EL1 at EL1 using AArch64\n                             to EL2.\nPMSICR_EL1, bit [29]       - Trap MRS reads of PMSICR_EL1 at EL1 using AArch64\n                             to EL2.\nPMSFCR_EL1, bit [28]       - Trap MRS reads of PMSFCR_EL1 at EL1 using AArch64\n                             to EL2.\nPMSEVFR_EL1, bit [27]      - Trap MRS reads of PMSEVFR_EL1 at EL1 using AArch64\n                             to EL2.\nPMSCR_EL1, bit [26]        - Trap MRS reads of PMSCR_EL1 at EL1 using AArch64 to\n                             EL2.\nPMBSR_EL1, bit [25]        - Trap MRS reads of PMBSR_EL1 at EL1 using AArch64 to\n                             EL2.\nPMBPTR_EL1, bit [24]       - Trap MRS reads of PMBPTR_EL1 at EL1 using AArch64\n                             to EL2.\nPMBLIMITR_EL1, bit [23]    - Trap MRS reads of PMBLIMITR_EL1 at EL1 using\n                             AArch64 to EL2.\nPMMIR_EL1, bit [22]        - Trap MRS reads of PMMIR_EL1 at EL1 using AArch64 to\n                             EL2.\nPMSELR_EL0, bit [19]       - Trap MRS reads of PMSELR_EL0 at EL1 and EL0 using\n                             AArch64 and MRC reads of PMSELR at EL0 using\n                             AArch32 when EL1 is using AArch64 to EL2.\nPMOVS, bit [18]            - Trap MRS reads and MRC reads of multiple System\n                             registers.\nPMINTEN, bit [17]          - Trap MRS reads of multiple System registers.\nPMCNTEN, bit [16]          - Trap MRS reads and MRC reads of multiple System\n                             registers.\nPMCCNTR_EL0, bit [15]      - Trap MRS reads of PMCCNTR_EL0 at EL1 and EL0 using\n                             AArch64 and MRC and MRRC reads of PMCCNTR at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nPMCCFILTR_EL0, bit [14]    - Trap MRS reads of PMCCFILTR_EL0 at EL1 and EL0\n                             using AArch64 and MRC reads of PMCCFILTR at EL0\n                             using AArch32 when EL1 is using AArch64 to EL2.\nPMEVTYPERn_EL0, bit [13]   - Trap MRS reads and MRC reads of multiple System\n                             registers.\nPMEVCNTRn_EL0, bit [12]    - Trap MRS reads and MRC reads of multiple System\n                             registers.\nOSDLR_EL1, bit [11]        - Trap MRS reads of OSDLR_EL1 at EL1 using AArch64 to\n                             EL2.\nOSECCR_EL1, bit [10]       - Trap MRS reads of OSECCR_EL1 at EL1 using AArch64\n                             to EL2.\nOSLSR_EL1, bit [9]         - Trap MRS reads of OSLSR_EL1 at EL1 using AArch64 to\n                             EL2.\nDBGPRCR_EL1, bit [7]       - Trap MRS reads of DBGPRCR_EL1 at EL1 using AArch64\n                             to EL2.\nDBGAUTHSTATUS_EL1, bit [6] - Trap MRS reads of DBGAUTHSTATUS_EL1 at EL1 using\n                             AArch64 to EL2.\nDBGCLAIM, bit [5]          - Trap MRS reads of multiple System registers.\nMDSCR_EL1, bit [4]         - Trap MRS reads of MDSCR_EL1 at EL1 using AArch64 to\n                             EL2.\nDBGWVRn_EL1, bit [3]       - Trap MRS reads of DBGWVR<n>_EL1 at EL1 using\n                             AArch64 to EL2.\nDBGWCRn_EL1, bit [2]       - Trap MRS reads of DBGWCR<n>_EL1 at EL1 using\n                             AArch64 to EL2.\nDBGBVRn_EL1, bit [1]       - Trap MRS reads of DBGBVR<n>_EL1 at EL1 using\n                             AArch64 to EL2.\nDBGBCRn_EL1, bit [0]       - Trap MRS reads of DBGBCR<n>_EL1 at EL1 using\n                             AArch64 to EL2."
      },
      "HDFGWTR_EL2": {
        "long_name": "Hypervisor Debug Fine-Grained Write Trap Register",
        "purpose": "Provides controls for traps of MSR and MCR writes of debug, trace, PMU, and\nStatistical Profiling System registers.\n\nPMUSERENR_EL0, bit [57]  - Trap MSR writes of PMUSERENR_EL0 at EL1 using AArch64\n                           to EL2.\nTRFCR_EL1, bit [49]      - Trap MSR writes of TRFCR_EL1 at EL1 using AArch64 to\n                           EL2.\nTRCVICTLR, bit [48]      - Trap MSR writes of TRCVICTLR at EL1 using AArch64 to\n                           EL2.\nTRCSSCSRn, bit [46]      - Trap MSR writes of TRCSSCSR<n> at EL1 using AArch64\n                           to EL2.\nTRCSEQSTR, bit [45]      - Trap MSR writes of TRCSEQSTR at EL1 using AArch64 to\n                           EL2.\nTRCPRGCTLR, bit [44]     - Trap MSR writes of TRCPRGCTLR at EL1 using AArch64 to\n                           EL2.\nTRCOSLAR, bit [42]       - Trap MSR writes of TRCOSLAR at EL1 using AArch64 to\n                           EL2.\nTRCIMSPECn, bit [41]     - Trap MSR writes of TRCIMSPEC<n> at EL1 using AArch64\n                           to EL2.\nTRCID, bit [40]          - Trap MSR writes of multiple System registers.\nTRCCNTVRn, bit [37]      - Trap MSR writes of TRCCNTVR<n> at EL1 using AArch64\n                           to EL2.\nTRCCLAIM, bit [36]       - Trap MSR writes of multiple System registers.\nTRCAUXCTLR, bit [35]     - Trap MSR writes of TRCAUXCTLR at EL1 using AArch64 to\n                           EL2.\nTRC, bit [33]            - Trap MSR writes of multiple System registers.\nPMSLATFR_EL1, bit [32]   - Trap MSR writes of PMSLATFR_EL1 at EL1 using AArch64\n                           to EL2.\nPMSIRR_EL1, bit [31]     - Trap MSR writes of PMSIRR_EL1 at EL1 using AArch64 to\n                           EL2.\nPMSICR_EL1, bit [29]     - Trap MSR writes of PMSICR_EL1 at EL1 using AArch64 to\n                           EL2.\nPMSFCR_EL1, bit [28]     - Trap MSR writes of PMSFCR_EL1 at EL1 using AArch64 to\n                           EL2.\nPMSEVFR_EL1, bit [27]    - Trap MSR writes of PMSEVFR_EL1 at EL1 using AArch64\n                           to EL2.\nPMSCR_EL1, bit [26]      - Trap MSR writes of PMSCR_EL1 at EL1 using AArch64 to\n                           EL2.\nPMBSR_EL1, bit [25]      - Trap MSR writes of PMBSR_EL1 at EL1 using AArch64 to\n                           EL2.\nPMBPTR_EL1, bit [24]     - Trap MSR writes of PMBPTR_EL1 at EL1 using AArch64 to\n                           EL2.\nPMBLIMITR_EL1, bit [23]  - Trap MSR writes of PMBLIMITR_EL1 at EL1 using AArch64\n                           to EL2.\nPMCR_EL0, bit [21]       - Trap MSR writes of PMCR_EL0 at EL1 and EL0 using\n                           AArch64 and MCR writes of PMCR at EL0 using AArch32\n                           when EL1 is using AArch64 to EL2.\nPMSWINC_EL0, bit [20]    - Trap MSR writes of PMSWINC_EL0 at EL1 and EL0 using\n                           AArch64 and MCR writes of PMSWINC at EL0 using\n                           AArch32 when EL1 is using AArch64 to EL2.\nPMSELR_EL0, bit [19]     - Trap MSR writes of PMSELR_EL0 at EL1 and EL0 using\n                           AArch64 and MCR writes of PMSELR at EL0 using AArch32\n                           when EL1 is using AArch64 to EL2.\nPMOVS, bit [18]          - Trap MSR writes and MCR writes of multiple System\n                           registers.\nPMINTEN, bit [17]        - Trap MSR writes of multiple System registers.\nPMCNTEN, bit [16]        - Trap MSR writes and MCR writes of multiple System\n                           registers.\nPMCCNTR_EL0, bit [15]    - Trap MSR writes of PMCCNTR_EL0 at EL1 and EL0 using\n                           AArch64 and MCR and MCRR writes of PMCCNTR at EL0\n                           using AArch32 when EL1 is using AArch64 to EL2.\nPMCCFILTR_EL0, bit [14]  - Trap MSR writes of PMCCFILTR_EL0 at EL1 and EL0 using\n                           AArch64 and MCR writes of PMCCFILTR at EL0 using\n                           AArch32 when EL1 is using AArch64 to EL2.\nPMEVTYPERn_EL0, bit [13] - Trap MSR writes and MCR writes of multiple System\n                           registers.\nPMEVCNTRn_EL0, bit [12]  - Trap MSR writes and MCR writes of multiple System\n                           registers.\nOSDLR_EL1, bit [11]      - Trap MSR writes of OSDLR_EL1 at EL1 using AArch64 to\n                           EL2.\nOSECCR_EL1, bit [10]     - Trap MSR writes of OSECCR_EL1 at EL1 using AArch64 to\n                           EL2.\nOSLAR_EL1, bit [8]       - Trap MSR writes of OSLAR_EL1 at EL1 using AArch64 to\n                           EL2.\nDBGPRCR_EL1, bit [7]     - Trap MSR writes of DBGPRCR_EL1 at EL1 using AArch64\n                           to EL2.\nDBGCLAIM, bit [5]        - Trap MSR writes of multiple System registers.\nMDSCR_EL1, bit [4]       - Trap MSR writes of MDSCR_EL1 at EL1 using AArch64 to\n                           EL2.\nDBGWVRn_EL1, bit [3]     - Trap MSR writes of DBGWVR<n>_EL1 at EL1 using AArch64\n                           to EL2.\nDBGWCRn_EL1, bit [2]     - Trap MSR writes of DBGWCR<n>_EL1 at EL1 using AArch64\n                           to EL2.\nDBGBVRn_EL1, bit [1]     - Trap MSR writes of DBGBVR<n>_EL1 at EL1 using AArch64\n                           to EL2.\nDBGBCRn_EL1, bit [0]     - Trap MSR writes of DBGBCR<n>_EL1 at EL1 using AArch64\n                           to EL2."
      },
      "HFGITR_EL2": {
        "long_name": "Hypervisor Fine-Grained Instruction Trap Register",
        "purpose": "Provides controls for traps of execution of System instructions.\n\nDCCVAC, bit [54]        - Trap execution of multiple System instructions.\nSVC_EL1, bit [53]       - Trap execution of SVC at EL1 using AArch64 to EL2.\nSVC_EL0, bit [52]       - Trap execution of SVC at EL0 using AArch64 and\n                          execution of SVC at EL0 using AArch32 when EL1 is\n                          using AArch64 to EL2.\nERET, bit [51]          - Trap execution of multiple System instructions.\nCPPRCTX, bit [50]       - Trap execution of CPP RCTX at EL1 and EL0 using\n                          AArch64 and execution of CPPRCTX at EL0 using AArch32\n                          when EL1 is using AArch64 to EL2.\nDVPRCTX, bit [49]       - Trap execution of DVP RCTX at EL1 and EL0 using\n                          AArch64 and execution of DVPRCTX at EL0 using AArch32\n                          when EL1 is using AArch64 to EL2.\nCFPRCTX, bit [48]       - Trap execution of CFP RCTX at EL1 and EL0 using\n                          AArch64 and execution of CFPRCTX at EL0 using AArch32\n                          when EL1 is using AArch64 to EL2.\nTLBIVAALE1, bit [47]    - Trap execution of TLBI VAALE1 at EL1 using AArch64 to\n                          EL2.\nTLBIVALE1, bit [46]     - Trap execution of TLBI VALE1 at EL1 using AArch64 to\n                          EL2.\nTLBIVAAE1, bit [45]     - Trap execution of TLBI VAAE1 at EL1 using AArch64 to\n                          EL2.\nTLBIASIDE1, bit [44]    - Trap execution of TLBI ASIDE1 at EL1 using AArch64 to\n                          EL2.\nTLBIVAE1, bit [43]      - Trap execution of TLBI VAE1 at EL1 using AArch64 to\n                          EL2.\nTLBIVMALLE1, bit [42]   - Trap execution of TLBI VMALLE1 at EL1 using AArch64 to\n                          EL2.\nTLBIRVAALE1, bit [41]   - Trap execution of TLBI RVAALE1 at EL1 using AArch64 to\n                          EL2.\nTLBIRVALE1, bit [40]    - Trap execution of TLBI RVALE1 at EL1 using AArch64 to\n                          EL2.\nTLBIRVAAE1, bit [39]    - Trap execution of TLBI RVAAE1 at EL1 using AArch64 to\n                          EL2.\nTLBIRVAE1, bit [38]     - Trap execution of TLBI RVAE1 at EL1 using AArch64 to\n                          EL2.\nTLBIRVAALE1IS, bit [37] - Trap execution of TLBI RVAALE1IS at EL1 using AArch64\n                          to EL2.\nTLBIRVALE1IS, bit [36]  - Trap execution of TLBI RVALE1IS at EL1 using AArch64\n                          to EL2.\nTLBIRVAAE1IS, bit [35]  - Trap execution of TLBI RVAAE1IS at EL1 using AArch64\n                          to EL2.\nTLBIRVAE1IS, bit [34]   - Trap execution of TLBI RVAE1IS at EL1 using AArch64 to\n                          EL2.\nTLBIVAALE1IS, bit [33]  - Trap execution of TLBI VAALE1IS at EL1 using AArch64\n                          to EL2.\nTLBIVALE1IS, bit [32]   - Trap execution of TLBI VALE1IS at EL1 using AArch64 to\n                          EL2.\nTLBIVAAE1IS, bit [31]   - Trap execution of TLBI VAAE1IS at EL1 using AArch64 to\n                          EL2.\nTLBIASIDE1IS, bit [30]  - Trap execution of TLBI ASIDE1IS at EL1 using AArch64\n                          to EL2.\nTLBIVAE1IS, bit [29]    - Trap execution of TLBI VAE1IS at EL1 using AArch64 to\n                          EL2.\nTLBIVMALLE1IS, bit [28] - Trap execution of TLBI VMALLE1IS at EL1 using AArch64\n                          to EL2.\nTLBIRVAALE1OS, bit [27] - Trap execution of TLBI RVAALE1OS at EL1 using AArch64\n                          to EL2.\nTLBIRVALE1OS, bit [26]  - Trap execution of TLBI RVALE1OS at EL1 using AArch64\n                          to EL2.\nTLBIRVAAE1OS, bit [25]  - Trap execution of TLBI RVAAE1OS at EL1 using AArch64\n                          to EL2.\nTLBIRVAE1OS, bit [24]   - Trap execution of TLBI RVAE1OS at EL1 using AArch64 to\n                          EL2.\nTLBIVAALE1OS, bit [23]  - Trap execution of TLBI VAALE1OS at EL1 using AArch64\n                          to EL2.\nTLBIVALE1OS, bit [22]   - Trap execution of TLBI VALE1OS at EL1 using AArch64 to\n                          EL2.\nTLBIVAAE1OS, bit [21]   - Trap execution of TLBI VAAE1OS at EL1 using AArch64 to\n                          EL2.\nTLBIASIDE1OS, bit [20]  - Trap execution of TLBI ASIDE1OS at EL1 using AArch64\n                          to EL2.\nTLBIVAE1OS, bit [19]    - Trap execution of TLBI VAE1OS at EL1 using AArch64 to\n                          EL2.\nTLBIVMALLE1OS, bit [18] - Trap execution of TLBI VMALLE1OS at EL1 using AArch64\n                          to EL2.\nATS1E1WP, bit [17]      - Trap execution of AT S1E1WP at EL1 using AArch64 to\n                          EL2.\nATS1E1RP, bit [16]      - Trap execution of AT S1E1RP at EL1 using AArch64 to\n                          EL2.\nATS1E0W, bit [15]       - Trap execution of AT S1E0W at EL1 using AArch64 to\n                          EL2.\nATS1E0R, bit [14]       - Trap execution of AT S1E0R at EL1 using AArch64 to\n                          EL2.\nATS1E1W, bit [13]       - Trap execution of AT S1E1W at EL1 using AArch64 to\n                          EL2.\nATS1E1R, bit [12]       - Trap execution of AT S1E1R at EL1 using AArch64 to\n                          EL2.\nDCZVA, bit [11]         - Trap execution of multiple System instructions.\nDCCIVAC, bit [10]       - Trap execution of multiple System instructions.\nDCCVADP, bit [9]        - Trap execution of multiple System instructions.\nDCCVAP, bit [8]         - Trap execution of multiple System instructions.\nDCCVAU, bit [7]         - Trap execution of DC CVAU at EL1 and EL0 using AArch64\n                          to EL2.\nDCCISW, bit [6]         - Trap execution of multiple System instructions.\nDCCSW, bit [5]          - Trap execution of multiple System instructions.\nDCISW, bit [4]          - Trap execution of multiple System instructions.\nDCIVAC, bit [3]         - Trap execution of multiple System instructions.\nICIVAU, bit [2]         - Trap execution of IC IVAU at EL1 and EL0 using AArch64\n                          to EL2.\nICIALLU, bit [1]        - Trap execution of IC IALLU at EL1 using AArch64 to\n                          EL2.\nICIALLUIS, bit [0]      - Trap execution of IC IALLUIS at EL1 using AArch64 to\n                          EL2."
      },
      "HFGRTR_EL2": {
        "long_name": "Hypervisor Fine-Grained Read Trap Register",
        "purpose": "Provides controls for traps of MRS and MRC reads of System registers.\n\nERXADDR_EL1, bit [49]     - Trap MRS reads of ERXADDR_EL1 at EL1 using AArch64\n                            to EL2.\nERXPFGCDN_EL1, bit [48]   - Trap MRS reads of ERXPFGCDN_EL1 at EL1 using AArch64\n                            to EL2.\nERXPFGCTL_EL1, bit [47]   - Trap MRS reads of ERXPFGCTL_EL1 at EL1 using AArch64\n                            to EL2.\nERXPFGF_EL1, bit [46]     - Trap MRS reads of ERXPFGF_EL1 at EL1 using AArch64\n                            to EL2.\nERXMISCn_EL1, bit [45]    - Trap MRS reads of ERXMISC<n>_EL1 at EL1 using\n                            AArch64 to EL2.\nERXSTATUS_EL1, bit [44]   - Trap MRS reads of ERXSTATUS_EL1 at EL1 using AArch64\n                            to EL2.\nERXCTLR_EL1, bit [43]     - Trap MRS reads of ERXCTLR_EL1 at EL1 using AArch64\n                            to EL2.\nERXFR_EL1, bit [42]       - Trap MRS reads of ERXFR_EL1 at EL1 using AArch64 to\n                            EL2.\nERRSELR_EL1, bit [41]     - Trap MRS reads of ERRSELR_EL1 at EL1 using AArch64\n                            to EL2.\nERRIDR_EL1, bit [40]      - Trap MRS reads of ERRIDR_EL1 at EL1 using AArch64 to\n                            EL2.\nICC_IGRPENn_EL1, bit [39] - Trap MRS reads of ICC_IGRPEN<n>_EL1 at EL1 using\n                            AArch64 to EL2.\nVBAR_EL1, bit [38]        - Trap MRS reads of VBAR_EL1 at EL1 using AArch64 to\n                            EL2.\nTTBR1_EL1, bit [37]       - Trap MRS reads of TTBR1_EL1 at EL1 using AArch64 to\n                            EL2.\nTTBR0_EL1, bit [36]       - Trap MRS reads of TTBR0_EL1 at EL1 using AArch64 to\n                            EL2.\nTPIDR_EL0, bit [35]       - Trap MRS reads of TPIDR_EL0 at EL1 and EL0 using\n                            AArch64 and MRC reads of TPIDRURW at EL0 using\n                            AArch32 when EL1 is using AArch64 to EL2.\nTPIDRRO_EL0, bit [34]     - Trap MRS reads of TPIDRRO_EL0 at EL1 and EL0 using\n                            AArch64 and MRC reads of TPIDRURO at EL0 using\n                            AArch32 when EL1 is using AArch64 to EL2.\nTPIDR_EL1, bit [33]       - Trap MRS reads of TPIDR_EL1 at EL1 using AArch64 to\n                            EL2.\nTCR_EL1, bit [32]         - Trap MRS reads of TCR_EL1 at EL1 using AArch64 to\n                            EL2.\nSCXTNUM_EL0, bit [31]     - Trap MRS reads of SCXTNUM_EL0 at EL1 and EL0 using\n                            AArch64 to EL2.\nSCXTNUM_EL1, bit [30]     - Trap MRS reads of SCXTNUM_EL1 at EL1 using AArch64\n                            to EL2.\nSCTLR_EL1, bit [29]       - Trap MRS reads of SCTLR_EL1 at EL1 using AArch64 to\n                            EL2.\nREVIDR_EL1, bit [28]      - Trap MRS reads of REVIDR_EL1 at EL1 using AArch64 to\n                            EL2.\nPAR_EL1, bit [27]         - Trap MRS reads of PAR_EL1 at EL1 using AArch64 to\n                            EL2.\nMPIDR_EL1, bit [26]       - Trap MRS reads of MPIDR_EL1 at EL1 using AArch64 to\n                            EL2.\nMIDR_EL1, bit [25]        - Trap MRS reads of MIDR_EL1 at EL1 using AArch64 to\n                            EL2.\nMAIR_EL1, bit [24]        - Trap MRS reads of MAIR_EL1 at EL1 using AArch64 to\n                            EL2.\nLORSA_EL1, bit [23]       - Trap MRS reads of LORSA_EL1 at EL1 using AArch64 to\n                            EL2.\nLORN_EL1, bit [22]        - Trap MRS reads of LORN_EL1 at EL1 using AArch64 to\n                            EL2.\nLORID_EL1, bit [21]       - Trap MRS reads of LORID_EL1 at EL1 using AArch64 to\n                            EL2.\nLOREA_EL1, bit [20]       - Trap MRS reads of LOREA_EL1 at EL1 using AArch64 to\n                            EL2.\nLORC_EL1, bit [19]        - Trap MRS reads of LORC_EL1 at EL1 using AArch64 to\n                            EL2.\nISR_EL1, bit [18]         - Trap MRS reads of ISR_EL1 at EL1 using AArch64 to\n                            EL2.\nFAR_EL1, bit [17]         - Trap MRS reads of FAR_EL1 at EL1 using AArch64 to\n                            EL2.\nESR_EL1, bit [16]         - Trap MRS reads of ESR_EL1 at EL1 using AArch64 to\n                            EL2.\nDCZID_EL0, bit [15]       - Trap MRS reads of DCZID_EL0 at EL1 and EL0 using\n                            AArch64 to EL2.\nCTR_EL0, bit [14]         - Trap MRS reads of CTR_EL0 at EL1 and EL0 using\n                            AArch64 and MRC reads of CTR at EL0 using AArch32\n                            when EL1 is using AArch64 to EL2.\nCSSELR_EL1, bit [13]      - Trap MRS reads of CSSELR_EL1 at EL1 using AArch64 to\n                            EL2.\nCPACR_EL1, bit [12]       - Trap MRS reads of CPACR_EL1 at EL1 using AArch64 to\n                            EL2.\nCONTEXTIDR_EL1, bit [11]  - Trap MRS reads of CONTEXTIDR_EL1 at EL1 using\n                            AArch64 to EL2.\nCLIDR_EL1, bit [10]       - Trap MRS reads of CLIDR_EL1 at EL1 using AArch64 to\n                            EL2.\nCCSIDR_EL1, bit [9]       - Trap MRS reads of CCSIDR_EL1 at EL1 using AArch64 to\n                            EL2.\nAPIBKey, bit [8]          - Trap MRS reads of multiple System registers.\nAPIAKey, bit [7]          - Trap MRS reads of multiple System registers.\nAPGAKey, bit [6]          - Trap MRS reads of multiple System registers.\nAPDBKey, bit [5]          - Trap MRS reads of multiple System registers.\nAPDAKey, bit [4]          - Trap MRS reads of multiple System registers.\nAMAIR_EL1, bit [3]        - Trap MRS reads of AMAIR_EL1 at EL1 using AArch64 to\n                            EL2.\nAIDR_EL1, bit [2]         - Trap MRS reads of AIDR_EL1 at EL1 using AArch64 to\n                            EL2.\nAFSR1_EL1, bit [1]        - Trap MRS reads of AFSR1_EL1 at EL1 using AArch64 to\n                            EL2.\nAFSR0_EL1, bit [0]        - Trap MRS reads of AFSR0_EL1 at EL1 using AArch64 to\n                            EL2."
      },
      "HFGWTR_EL2": {
        "long_name": "Hypervisor Fine-Grained Write Trap Register",
        "purpose": "Provides controls for traps of MSR and MCR writes of System registers.\n\nERXADDR_EL1, bit [49]     - Trap MSR writes of ERXADDR_EL1 at EL1 using AArch64\n                            to EL2.\nERXPFGCDN_EL1, bit [48]   - Trap MSR writes of ERXPFGCDN_EL1 at EL1 using\n                            AArch64 to EL2.\nERXPFGCTL_EL1, bit [47]   - Trap MSR writes of ERXPFGCTL_EL1 at EL1 using\n                            AArch64 to EL2.\nERXMISCn_EL1, bit [45]    - Trap MSR writes of ERXMISC<n>_EL1 at EL1 using\n                            AArch64 to EL2.\nERXSTATUS_EL1, bit [44]   - Trap MSR writes of ERXSTATUS_EL1 at EL1 using\n                            AArch64 to EL2.\nERXCTLR_EL1, bit [43]     - Trap MSR writes of ERXCTLR_EL1 at EL1 using AArch64\n                            to EL2.\nERRSELR_EL1, bit [41]     - Trap MSR writes of ERRSELR_EL1 at EL1 using AArch64\n                            to EL2.\nICC_IGRPENn_EL1, bit [39] - Trap MSR writes of ICC_IGRPEN<n>_EL1 at EL1 using\n                            AArch64 to EL2.\nVBAR_EL1, bit [38]        - Trap MSR writes of VBAR_EL1 at EL1 using AArch64 to\n                            EL2.\nTTBR1_EL1, bit [37]       - Trap MSR writes of TTBR1_EL1 at EL1 using AArch64 to\n                            EL2.\nTTBR0_EL1, bit [36]       - Trap MSR writes of TTBR0_EL1 at EL1 using AArch64 to\n                            EL2.\nTPIDR_EL0, bit [35]       - Trap MSR writes of TPIDR_EL0 at EL1 and EL0 using\n                            AArch64 and MCR writes of TPIDRURW at EL0 using\n                            AArch32 when EL1 is using AArch64 to EL2.\nTPIDRRO_EL0, bit [34]     - Trap MSR writes of TPIDRRO_EL0 at EL1 using AArch64\n                            to EL2.\nTPIDR_EL1, bit [33]       - Trap MSR writes of TPIDR_EL1 at EL1 using AArch64 to\n                            EL2.\nTCR_EL1, bit [32]         - Trap MSR writes of TCR_EL1 at EL1 using AArch64 to\n                            EL2.\nSCXTNUM_EL0, bit [31]     - Trap MSR writes of SCXTNUM_EL0 at EL1 and EL0 using\n                            AArch64 to EL2.\nSCXTNUM_EL1, bit [30]     - Trap MSR writes of SCXTNUM_EL1 at EL1 using AArch64\n                            to EL2.\nSCTLR_EL1, bit [29]       - Trap MSR writes of SCTLR_EL1 at EL1 using AArch64 to\n                            EL2.\nPAR_EL1, bit [27]         - Trap MSR writes of PAR_EL1 at EL1 using AArch64 to\n                            EL2.\nMAIR_EL1, bit [24]        - Trap MSR writes of MAIR_EL1 at EL1 using AArch64 to\n                            EL2.\nLORSA_EL1, bit [23]       - Trap MSR writes of LORSA_EL1 at EL1 using AArch64 to\n                            EL2.\nLORN_EL1, bit [22]        - Trap MSR writes of LORN_EL1 at EL1 using AArch64 to\n                            EL2.\nLOREA_EL1, bit [20]       - Trap MSR writes of LOREA_EL1 at EL1 using AArch64 to\n                            EL2.\nLORC_EL1, bit [19]        - Trap MSR writes of LORC_EL1 at EL1 using AArch64 to\n                            EL2.\nFAR_EL1, bit [17]         - Trap MSR writes of FAR_EL1 at EL1 using AArch64 to\n                            EL2.\nESR_EL1, bit [16]         - Trap MSR writes of ESR_EL1 at EL1 using AArch64 to\n                            EL2.\nCSSELR_EL1, bit [13]      - Trap MSR writes of CSSELR_EL1 at EL1 using AArch64\n                            to EL2.\nCPACR_EL1, bit [12]       - Trap MSR writes of CPACR_EL1 at EL1 using AArch64 to\n                            EL2.\nCONTEXTIDR_EL1, bit [11]  - Trap MSR writes of CONTEXTIDR_EL1 at EL1 using\n                            AArch64 to EL2.\nAPIBKey, bit [8]          - Trap MSR writes of multiple System registers.\nAPIAKey, bit [7]          - Trap MSR writes of multiple System registers.\nAPGAKey, bit [6]          - Trap MSR writes of multiple System registers.\nAPDBKey, bit [5]          - Trap MSR writes of multiple System registers.\nAPDAKey, bit [4]          - Trap MSR writes of multiple System registers.\nAMAIR_EL1, bit [3]        - Trap MSR writes of AMAIR_EL1 at EL1 using AArch64 to\n                            EL2.\nAFSR1_EL1, bit [1]        - Trap MSR writes of AFSR1_EL1 at EL1 using AArch64 to\n                            EL2.\nAFSR0_EL1, bit [0]        - Trap MSR writes of AFSR0_EL1 at EL1 using AArch64 to\n                            EL2."
      },
      "HPFAR_EL2": {
        "long_name": "Hypervisor IPA Fault Address Register",
        "purpose": "Holds the faulting IPA for some aborts on a stage 2 translation taken to EL2.\n\nNS, bit [63]              - Faulting IPA address space.\nFIPA[51:48], bits [40:43] - Extension to FIPA[47:12].\nFIPA[47:12], bits [4:39]  - Bits [47:12] of the faulting intermediate physical\n                            address."
      },
      "HSTR_EL2": {
        "long_name": "Hypervisor System Trap Register",
        "purpose": "Controls trapping to EL2 of EL1 or lower AArch32 accesses to the System register\nin the coproc == 0b1111 encoding space, by the CRn value used to access the\nregister using MCR or MRC instruction. When the register is accessible using an\nMCRR or MRRC instruction, this is the CRm value used to access the register.\n\nT<n>, bits [0:15] - Fields T14 and T4 are res0. The remaining fields control\n                    whether EL0 and EL1 accesses, using MCR, MRC, MCRR, and MRRC\n                    instructions, to the System registers in the coproc ==\n                    0b1111 encoding space are trapped to EL2 as follows:\n                      - MCR or MRC accesses to these registers that are trapped\n                    to EL2 are reported using EC syndrome value 0x03, unless the\n                    access is undefined.\n                      - MCRR or MRRC accesses to these registers that are\n                    trapped to EL2 are reported using EC syndrome value 0x04,\n                    unless the access is undefined."
      },
      "ICC_AP0R<n>_EL1": {
        "long_name": "Interrupt Controller Active Priorities Group 0 Registers",
        "purpose": "Provides information about Group 0 active priorities."
      },
      "ICC_AP1R<n>_EL1": {
        "long_name": "Interrupt Controller Active Priorities Group 1 Registers",
        "purpose": "Provides information about Group 1 active priorities."
      },
      "ICC_ASGI1R_EL1": {
        "long_name": "Interrupt Controller Alias Software Generated Interrupt Group 1 Register",
        "purpose": "Generates Group 1 SGIs for the Security state that is not the current Security\nstate.\n\nAff3, bits [48:55]      - The affinity 3 value of the affinity path of the\n                          luster for which SGI interrupts will be generated.\nRS, bits [44:47]        - RangeSelector Controls which group of 16 values is\n                          represented by the TargetList field.\nIRM, bit [40]           - Interrupt Routing Mode.\nAff2, bits [32:39]      - The affinity 2 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nINTID, bits [24:27]     - The INTID of the SGI.\nAff1, bits [16:23]      - The affinity 1 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nTargetList, bits [0:15] - Target List."
      },
      "ICC_BPR0_EL1": {
        "long_name": "Interrupt Controller Binary Point Register 0",
        "purpose": "Defines the point at which the priority value fields split into two parts, the\ngroup priority field and the subpriority field. The group priority field\ndetermines Group 0 interrupt preemption.\n\nBinaryPoint, bits [0:2] - The value of this field controls how the 8-bit\n                          interrupt priority field is split into a group\n                          priority field, that determines interrupt preemption,\n                          and a subpriority field. This is done as follows:"
      },
      "ICC_BPR1_EL1": {
        "long_name": "Interrupt Controller Binary Point Register 1",
        "purpose": "Defines the point at which the priority value fields split into two parts, the\ngroup priority field and the subpriority field. The group priority field\ndetermines Group 1 interrupt preemption.\n\nBinaryPoint, bits [0:2] - If the GIC is configured to use separate binary point\n                          fields for Group 0 and Group 1 interrupts, the value\n                          of this field controls how the 8-bit interrupt\n                          priority field is split into a group priority field,\n                          that determines interrupt preemption, and a\n                          subpriority field. For more information about\n                          priorities, see Priority grouping. The minimum value\n                          of the Non-secure copy of this register is the minimum\n                          value of ICC_BPR0_EL1 + 1. The minimum value of the\n                          Secure copy of this register is the minimum value of\n                          ICC_BPR0_EL1. If EL3 is implemented and\n                          ICC_CTLR_EL3.CBPR_EL1S is 1:\n                            -  When SCR_EL3.EEL2 is 1 and HCR_EL2.IMO is 1,\n                          Secure accesses to this register at EL1 access the\n                          state of ICV_BPR1_EL1.\n                            -  Otherwise, Secure accesses to this register at\n                          EL1 access the state of ICC_BPR0_EL1. If EL3 is\n                          implemented and ICC_CTLR_EL3.CBPR_EL1NS is 1, Non-\n                          secure accesses to this register at EL1 or EL2 behave\n                          as follows, depending on the values of HCR_EL2.IMO and\n                          SCR_EL3.IRQ: If EL3 is not implemented and\n                          ICC_CTLR_EL1.CBPR is 1, Non-secure accesses to this\n                          register at EL1 or EL2 behave as follows, depending on\n                          the values of HCR_EL2.IMO:"
      },
      "ICC_CTLR_EL1": {
        "long_name": "Interrupt Controller Control Register (EL1)",
        "purpose": "Controls aspects of the behavior of the GIC CPU interface and provides\ninformation about the features implemented.\n\nExtRange, bit [19]   - Extended INTID range (read-only).\nRSS, bit [18]        - Range Selector Support.\nA3V, bit [15]        - Affinity 3 Valid. Read-only and writes are ignored.\nSEIS, bit [14]       - SEI Support. Read-only and writes are ignored.\nIDbits, bits [11:13] - Identifier bits. Read-only and writes are ignored.\nPRIbits, bits [8:10] - Priority bits. Read-only and writes are ignored. The\n                       number of priority bits implemented, minus one. An\n                       implementation that supports two Security states must\n                       implement at least 32 levels of physical priority (5\n                       priority bits). An implementation that supports only a\n                       single Security state must implement at least 16 levels\n                       of physical priority (4 priority bits). This field always\n                       returns the number of priority bits implemented,\n                       regardless of the Security state of the access or the\n                       value of GICD_CTLR.DS. For physical accesses, this field\n                       determines the minimum value of ICC_BPR0_EL1. If EL3 is\n                       implemented, physical accesses return the value from\n                       ICC_CTLR_EL3.PRIbits. If EL3 is not implemented, physical\n                       accesses return the value from this field.\nPMHE, bit [6]        - Priority Mask Hint Enable.\nEOImode, bit [1]     - EOI mode for the current Security state.\nCBPR, bit [0]        - Common Binary Point Register."
      },
      "ICC_CTLR_EL3": {
        "long_name": "Interrupt Controller Control Register (EL3)",
        "purpose": "Controls aspects of the behavior of the GIC CPU interface and provides\ninformation about the features implemented.\n\nExtRange, bit [19]     - Extended INTID range (read-only).\nRSS, bit [18]          - Range Selector Support.\nnDS, bit [17]          - Disable Security not supported.\nA3V, bit [15]          - Affinity 3 Valid.\nSEIS, bit [14]         - SEI Support.\nIDbits, bits [11:13]   - Identifier bits.\nPRIbits, bits [8:10]   - Priority bits.\nPMHE, bit [6]          - Priority Mask Hint Enable.\nRM, bit [5]            - Routing Modifier.\nEOImode_EL1NS, bit [4] - EOI mode for interrupts handled at Non-secure EL1 and\n                         EL2.\nEOImode_EL1S, bit [3]  - EOI mode for interrupts handled at Secure EL1.\nEOImode_EL3, bit [2]   - EOI mode for interrupts handled at EL3.\nCBPR_EL1NS, bit [1]    - Common Binary Point Register, EL1 Non-secure.\nCBPR_EL1S, bit [0]     - Common Binary Point Register, EL1 Secure."
      },
      "ICC_DIR_EL1": {
        "long_name": "Interrupt Controller Deactivate Interrupt Register",
        "purpose": "When interrupt priority drop is separated from interrupt deactivation, a write\nto this register deactivates the specified interrupt.\n\nINTID, bits [0:23] - The INTID of the interrupt to be deactivated. This field\n                     has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICC_CTLR_EL1.IDbits and\n                     ICC_CTLR_EL3.IDbits. If only 16 bits are implemented, bits\n                     [23:16] of this register are res0."
      },
      "ICC_EOIR0_EL1": {
        "long_name": "Interrupt Controller End Of Interrupt Register 0",
        "purpose": "A PE writes to this register to inform the CPU interface that it has completed\nthe processing of the specified Group 0 interrupt.\n\nINTID, bits [0:23] - The INTID from the corresponding ICC_IAR0_EL1 access. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICC_CTLR_EL1.IDbits and\n                     ICC_CTLR_EL3.IDbits. If only 16 bits are implemented, bits\n                     [23:16] of this register are res0. If the EOImode bit for\n                     the current Exception level and Security state is 0, a\n                     write to this register drops the priority for the\n                     interrupt, and also deactivates the interrupt. If the\n                     EOImode bit for the current Exception level and Security\n                     state is 1, a write to this register only drops the\n                     priority for the interrupt. Software must write to\n                     ICC_DIR_EL1 to deactivate the interrupt. The EOImode bit\n                     for the current Exception level and Security state is\n                     determined as follows:\n                       - If EL3 is not implemented, the appropriate bit is\n                     ICC_CTLR_EL1.EOImode.\n                       - If EL3 is implemented and the software is executing at\n                     EL3, the appropriate bit is ICC_CTLR_EL3.EOImode_EL3.\n                       - If EL3 is implemented and the software is not executing\n                     at EL3, the bit depends on the current Security state:\n                         - If the software is executing in Secure state, the bit\n                     is ICC_CTLR_EL3.EOImode_EL1S.\n                         - If the software is executing in Non-secure state, the\n                     bit is ICC_CTLR_EL3.EOImode_EL1NS."
      },
      "ICC_EOIR1_EL1": {
        "long_name": "Interrupt Controller End Of Interrupt Register 1",
        "purpose": "A PE writes to this register to inform the CPU interface that it has completed\nthe processing of the specified Group 1 interrupt.\n\nINTID, bits [0:23] - The INTID from the corresponding ICC_IAR1_EL1 access. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICC_CTLR_EL1.IDbits and\n                     ICC_CTLR_EL3.IDbits. If only 16 bits are implemented, bits\n                     [23:16] of this register are res0. If the EOImode bit for\n                     the current Exception level and Security state is 0, a\n                     write to this register drops the priority for the\n                     interrupt, and also deactivates the interrupt. If the\n                     EOImode bit for the current Exception level and Security\n                     state is 1, a write to this register only drops the\n                     priority for the interrupt. Software must write to\n                     ICC_DIR_EL1 to deactivate the interrupt. The EOImode bit\n                     for the current Exception level and Security state is\n                     determined as follows:\n                       - If EL3 is not implemented, the appropriate bit is\n                     ICC_CTLR_EL1.EOImode.\n                       - If EL3 is implemented and the software is executing at\n                     EL3, the appropriate bit is ICC_CTLR_EL3.EOImode_EL3.\n                       - If EL3 is implemented and the software is not executing\n                     at EL3, the bit depends on the current Security state:\n                         - If the software is executing in Secure state, the bit\n                     is ICC_CTLR_EL3.EOImode_EL1S.\n                         - If the software is executing in Non-secure state, the\n                     bit is ICC_CTLR_EL3.EOImode_EL1NS."
      },
      "ICC_HPPIR0_EL1": {
        "long_name": "Interrupt Controller Highest Priority Pending Interrupt Register 0",
        "purpose": "Indicates the highest priority pending Group 0 interrupt on the CPU interface.\n\nINTID, bits [0:23] - The INTID of the highest priority pending interrupt, if\n                     that interrupt is observable at the current Security state\n                     and Exception level. If the highest priority pending\n                     interrupt is not observable, this field contains a special\n                     INTID to indicate the reason. These special INTIDs can be\n                     one of: 1020, 1021, or 1023. See Special INTIDs, for more\n                     information. This field has either 16 or 24 bits\n                     implemented. The number of implemented bits can be found in\n                     ICC_CTLR_EL1.IDbits and ICC_CTLR_EL3.IDbits. If only 16\n                     bits are implemented, bits [23:16] of this register are\n                     res0."
      },
      "ICC_HPPIR1_EL1": {
        "long_name": "Interrupt Controller Highest Priority Pending Interrupt Register 1",
        "purpose": "Indicates the highest priority pending Group 1 interrupt on the CPU interface.\n\nINTID, bits [0:23] - The INTID of the highest priority pending interrupt, if\n                     that interrupt is observable at the current Security state\n                     and Exception level. If the highest priority pending\n                     interrupt is not observable, this field contains a special\n                     INTID to indicate the reason. These special INTIDs can be\n                     one of: 1020, 1021, or 1023. See Special INTIDs, for more\n                     information. This field has either 16 or 24 bits\n                     implemented. The number of implemented bits can be found in\n                     ICC_CTLR_EL1.IDbits and ICC_CTLR_EL3.IDbits. If only 16\n                     bits are implemented, bits [23:16] of this register are\n                     res0."
      },
      "ICC_IAR0_EL1": {
        "long_name": "Interrupt Controller Interrupt Acknowledge Register 0",
        "purpose": "The PE reads this register to obtain the INTID of the signaled Group 0\ninterrupt. This read acts as an acknowledge for the interrupt.\n\nINTID, bits [0:23] - The INTID of the signaled interrupt. This is the INTID of\n                     the highest priority pending interrupt, if that interrupt\n                     is of sufficient priority for it to be signaled to the PE,\n                     and if it can be acknowledged at the current Security state\n                     and Exception level. If the highest priority pending\n                     interrupt is not observable, this field contains a special\n                     INTID to indicate the reason. These special INTIDs can be\n                     one of: 1020, 1021, or 1023. See Special INTIDs, for more\n                     information. This field has either 16 or 24 bits\n                     implemented. The number of implemented bits can be found in\n                     ICC_CTLR_EL1.IDbits and ICC_CTLR_EL3.IDbits. If only 16\n                     bits are implemented, bits [23:16] of this register are\n                     res0."
      },
      "ICC_IAR1_EL1": {
        "long_name": "Interrupt Controller Interrupt Acknowledge Register 1",
        "purpose": "The PE reads this register to obtain the INTID of the signaled Group 1\ninterrupt. This read acts as an acknowledge for the interrupt.\n\nINTID, bits [0:23] - The INTID of the signaled interrupt. This is the INTID of\n                     the highest priority pending interrupt, if that interrupt\n                     is of sufficient priority for it to be signaled to the PE,\n                     and if it can be acknowledged at the current Security state\n                     and Exception level. If the highest priority pending\n                     interrupt is not observable, this field contains a special\n                     INTID to indicate the reason. These special INTIDs can be\n                     one of: 1020, 1021, or 1023. See Special INTIDs, for more\n                     information. This field has either 16 or 24 bits\n                     implemented. The number of implemented bits can be found in\n                     ICC_CTLR_EL1.IDbits and ICC_CTLR_EL3.IDbits. If only 16\n                     bits are implemented, bits [23:16] of this register are\n                     res0."
      },
      "ICC_IGRPEN0_EL1": {
        "long_name": "Interrupt Controller Interrupt Group 0 Enable register",
        "purpose": "Controls whether Group 0 interrupts are enabled or not.\n\nEnable, bit [0] - Enables Group 0 interrupts.\n                      0b0 Group 0 interrupts are disabled.\n                      0b1 Group 0 interrupts are enabled.\n                  Virtual accesses to this register update ICH_VMCR_EL2.VENG0.\n                  If the highest priority pending interrupt for that PE is a\n                  Group 0 interrupt using 1 of N model, then the interrupt will\n                  be targeted to another PE as a result of the Enable bit\n                  changing from 1 to 0."
      },
      "ICC_IGRPEN1_EL1": {
        "long_name": "Interrupt Controller Interrupt Group 1 Enable register",
        "purpose": "Controls whether Group 1 interrupts are enabled for the current Security state.\n\nEnable, bit [0] - Enables Group 1 interrupts for the current Security state.\n                      0b0 Group 1 interrupts are disabled for the current\n                  Security state.\n                      0b1 Group 1 interrupts are enabled for the current\n                  Security state.\n                  Virtual accesses to this register update ICH_VMCR_EL2.VENG1.\n                  If EL3 is present:\n                    - The Secure ICC_IGRPEN1_EL1.Enable bit is a read/write\n                  alias of the ICC_IGRPEN1_EL3.EnableGrp1S bit.\n                    - The Non-secure ICC_IGRPEN1_EL1.Enable bit is a read/write\n                  alias of the ICC_IGRPEN1_EL3.EnableGrp1NS bit. If the highest\n                  priority pending interrupt for that PE is a Group 1 interrupt\n                  using 1 of N model, then the interrupt will target another PE\n                  as a result of the Enable bit changing from 1 to 0."
      },
      "ICC_IGRPEN1_EL3": {
        "long_name": "Interrupt Controller Interrupt Group 1 Enable register (EL3)",
        "purpose": "Controls whether Group 1 interrupts are enabled or not.\n\nEnableGrp1S, bit [1]  - Enables Group 1 interrupts for the Secure state.\n                            0b0 Secure Group 1 interrupts are disabled.\n                            0b1 Secure Group 1 interrupts are enabled.\n                        The Secure ICC_IGRPEN1_EL1.Enable bit is a read/write\n                        alias of the ICC_IGRPEN1_EL3.EnableGrp1S bit. If the\n                        highest priority pending interrupt for that PE is a\n                        Group 1 interrupt using 1 of N model, then the interrupt\n                        will target another PE as a result of the Enable bit\n                        changing from 1 to 0.\nEnableGrp1NS, bit [0] - Enables Group 1 interrupts for the Non-secure state.\n                            0b0 Non-secure Group 1 interrupts are disabled.\n                            0b1 Non-secure Group 1 interrupts are enabled.\n                        The Non-secure ICC_IGRPEN1_EL1.Enable bit is a\n                        read/write alias of the ICC_IGRPEN1_EL3.EnableGrp1NS\n                        bit. If the highest priority pending interrupt for that\n                        PE is a Group 1 interrupt using 1 of N model, then the\n                        interrupt will target another PE as a result of the\n                        Enable bit changing from 1 to 0."
      },
      "ICC_PMR_EL1": {
        "long_name": "Interrupt Controller Interrupt Priority Mask Register",
        "purpose": "Provides an interrupt priority filter. Only interrupts with a higher priority\nthan the value in this register are signaled to the PE.\n\nWrites to this register must be high performance and must ensure that no\ninterrupt of lower priority than the written value occurs after the write,\nwithout requiring an ISB or an exception boundary.\n\nPriority, bits [0:7] - The priority mask level for the CPU interface. If the\n                       priority of an interrupt is higher than the value\n                       indicated by this field, the interface signals the\n                       interrupt to the PE. The possible priority field values\n                       are as follows: Unimplemented priority bits are RAZ/WI."
      },
      "ICC_RPR_EL1": {
        "long_name": "Interrupt Controller Running Priority Register",
        "purpose": "Indicates the Running priority of the CPU interface.\n\nPriority, bits [0:7] - The current running priority on the CPU interface. This\n                       is the group priority of the current active interrupt. If\n                       there are no active interrupts on the CPU interface, or\n                       all active interrupts have undergone a priority drop, the\n                       value returned is the Idle priority. The priority\n                       returned is the group priority as if the BPR for the\n                       current Exception level and Security state was set to the\n                       minimum value of BPR for the number of implemented\n                       priority bits. If 8 bits of priority are implemented the\n                       group priority is bits[7:1] of the priority."
      },
      "ICC_SGI0R_EL1": {
        "long_name": "Interrupt Controller Software Generated Interrupt Group 0 Register",
        "purpose": "Generates Secure Group 0 SGIs.\n\nAff3, bits [48:55]      - The affinity 3 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nRS, bits [44:47]        - RangeSelector Controls which group of 16 values is\n                          represented by the TargetList field.\nIRM, bit [40]           - Interrupt Routing Mode.\nAff2, bits [32:39]      - The affinity 2 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nINTID, bits [24:27]     - The INTID of the SGI.\nAff1, bits [16:23]      - The affinity 1 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nTargetList, bits [0:15] - Target List."
      },
      "ICC_SGI1R_EL1": {
        "long_name": "Interrupt Controller Software Generated Interrupt Group 1 Register",
        "purpose": "Generates Group 1 SGIs for the current Security state.\n\nAff3, bits [48:55]      - The affinity 3 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nRS, bits [44:47]        - RangeSelector Controls which group of 16 values is\n                          represented by the TargetList field.\nIRM, bit [40]           - Interrupt Routing Mode.\nAff2, bits [32:39]      - The affinity 2 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nINTID, bits [24:27]     - The INTID of the SGI.\nAff1, bits [16:23]      - The affinity 1 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nTargetList, bits [0:15] - Target List."
      },
      "ICC_SRE_EL1": {
        "long_name": "Interrupt Controller System Register Enable register (EL1)",
        "purpose": "Controls whether the System register interface or the memory-mapped interface to\nthe GIC CPU interface is used for EL1.\n\nDIB, bit [2] - Disable IRQ bypass.\n                   0b0 IRQ bypass enabled.\n                   0b1 IRQ bypass disabled.\nDFB, bit [1] - Disable FIQ bypass.\n                   0b0 FIQ bypass enabled.\n                   0b1 FIQ bypass disabled.\nSRE, bit [0] - System Register Enable.\n                   0b0 The memory-mapped interface must be used. Access at EL1\n               to any ICC_* System register other than ICC_SRE_EL1 is trapped to\n               EL1.\n                   0b1 The System register interface for the current Security\n               state is enabled."
      },
      "ICC_SRE_EL2": {
        "long_name": "Interrupt Controller System Register Enable register (EL2)",
        "purpose": "Controls whether the System register interface or the memory-mapped interface to\nthe GIC CPU interface is used for EL2.\n\nEnable, bit [3] - Enable. Enables lower Exception level access to ICC_SRE_EL1.\n                      0b0 When EL2 is implemented and enabled in the current\n                  Security state, EL1 accesses to ICC_SRE_EL1 trap to EL2.\n                      0b1 EL1 accesses to ICC_SRE_EL1 do not trap to EL2.\nDIB, bit [2]    - Disable IRQ bypass.\n                      0b0 IRQ bypass enabled.\n                      0b1 IRQ bypass disabled.\nDFB, bit [1]    - Disable FIQ bypass.\n                      0b0 FIQ bypass enabled.\n                      0b1 FIQ bypass disabled.\nSRE, bit [0]    - System Register Enable.\n                      0b0 The memory-mapped interface must be used. Access at\n                  EL2 to any ICH_* or ICC_* register other than ICC_SRE_EL1 or\n                  ICC_SRE_EL2, is trapped to EL2.\n                      0b1 The System register interface to the ICH_* registers\n                  and the EL1 and EL2 ICC_* registers is enabled for EL2."
      },
      "ICC_SRE_EL3": {
        "long_name": "Interrupt Controller System Register Enable register (EL3)",
        "purpose": "Controls whether the System register interface or the memory-mapped interface to\nthe GIC CPU interface is used for EL3.\n\nEnable, bit [3] - Enable. Enables lower Exception level access to ICC_SRE_EL1\n                  and ICC_SRE_EL2.\n                      0b0 EL1 accesses to ICC_SRE_EL1 trap to EL3, unless these\n                  accesses are trapped to EL2 as a result of ICC_SRE_EL2.Enable\n                  == 0. EL2 accesses to ICC_SRE_EL1 and ICC_SRE_EL2 trap to EL3.\n                      0b1 EL1 accesses to ICC_SRE_EL1 do not trap to EL3. EL2\n                  accesses to ICC_SRE_EL1 and ICC_SRE_EL2 do not trap to EL3.\nDIB, bit [2]    - Disable IRQ bypass.\n                      0b0 IRQ bypass enabled.\n                      0b1 IRQ bypass disabled.\nDFB, bit [1]    - Disable FIQ bypass.\n                      0b0 FIQ bypass enabled.\n                      0b1 FIQ bypass disabled.\nSRE, bit [0]    - System Register Enable.\n                      0b0 The memory-mapped interface must be used. Access at\n                  EL3 to any ICH_* or ICC_* register other than ICC_SRE_EL1,\n                  ICC_SRE_EL2, or ICC_SRE_EL3 is trapped to EL3\n                      0b1 The System register interface to the ICH_* registers\n                  and the EL1, EL2, and EL3 ICC_* registers is enabled for EL3."
      },
      "ICH_AP0R<n>_EL2": {
        "long_name": "Interrupt Controller Hyp Active Priorities Group 0 Registers",
        "purpose": "Provides information about Group 0 virtual active priorities for EL2.\n\nP<x>, bits [0:31] - Provides the access to the virtual active priorities for\n                    Group 0 interrupts. Possible values of each bit are:\n                        0b0 There is no Group 0 interrupt active with this\n                    priority level, or all active Group 0 interrupts with this\n                    priority level have undergone priority-drop.\n                        0b1 There is a Group 0 interrupt active with this\n                    priority level which has not undergone priority drop."
      },
      "ICH_AP1R<n>_EL2": {
        "long_name": "Interrupt Controller Hyp Active Priorities Group 1 Registers",
        "purpose": "Provides information about Group 1 virtual active priorities for EL2.\n\nP<x>, bits [0:31] - Group 1 interrupt active priorities. Possible values of each\n                    bit are:\n                        0b0 There is no Group 1 interrupt active with this\n                    priority level, or all active Group 1 interrupts with this\n                    priority level have undergone priority-drop.\n                        0b1 There is a Group 1 interrupt active with this\n                    priority level which has not undergone priority drop."
      },
      "ICH_EISR_EL2": {
        "long_name": "Interrupt Controller End of Interrupt Status Register",
        "purpose": "Indicates which List registers have outstanding EOI maintenance interrupts.\n\nStatus<n>, bits [0:15] - EOI maintenance interrupt status bit for List register\n                         <n>:\n                             0b0 List register <n>, ICH_LR<n>_EL2, does not have\n                         an EOI maintenance interrupt.\n                             0b1 List register <n>, ICH_LR<n>_EL2, has an EOI\n                         maintenance interrupt that has not been handled.\n                         For any ICH_LR<n>_EL2, the corresponding status bit is\n                         set to 1 if all of the following are true:\n                           - ICH_LR<n>_EL2.State is 0b00.\n                           - ICH_LR<n>_EL2.HW is 0.\n                           - ICH_LR<n>_EL2.EOI (bit [41]) is 1, indicating that\n                         when the interrupt corresponding to that List register\n                         is deactivated, a maintenance interrupt is asserted.\n                         Otherwise the status bit takes the value 0."
      },
      "ICH_ELRSR_EL2": {
        "long_name": "Interrupt Controller Empty List Register Status Register",
        "purpose": "These registers can be used to locate a usable List register when the hypervisor\nis delivering an interrupt to a VM.\n\nStatus<n>, bits [0:15] - Status bit for List register <n>, ICH_LR<n>_EL2:\n                             0b0 List register ICH_LR<n>_EL2, if implemented,\n                         contains a valid interrupt. Using this List register\n                         can result in overwriting a valid interrupt.\n                             0b1 List register ICH_LR<n>_EL2 does not contain a\n                         valid interrupt. The List register is empty and can be\n                         used without overwriting a valid interrupt or losing an\n                         EOI maintenance interrupt.\n                         For any List register <n>, the corresponding status bit\n                         is set to 1 if ICH_LR<n>_EL2.State is 0b00 and either\n                         ICH_LR<n>_EL2.HW is 1 or ICH_LR<n>_EL2.EOI (bit [41])\n                         is 0. Otherwise the status bit takes the value 0."
      },
      "ICH_HCR_EL2": {
        "long_name": "Interrupt Controller Hyp Control Register",
        "purpose": "Controls the environment for VMs.\n\nEOIcount, bits [27:31] - This field is incremented whenever a successful write\n                         to a virtual EOIR or DIR register would have resulted\n                         in a virtual interrupt deactivation.\nTDIR, bit [14]         - Trap EL1 writes to ICC_DIR_EL1 and ICV_DIR_EL1.\nTSEI, bit [13]         - Trap all locally generated SEIs.\nTALL1, bit [12]        - Trap all EL1 accesses to ICC_* and ICV_* System\n                         registers for Group 1 interrupts to EL2.\nTALL0, bit [11]        - Trap all EL1 accesses to ICC_* and ICV_* System\n                         registers for Group 0 interrupts to EL2.\nTC, bit [10]           - Trap all EL1 accesses to System registers that are\n                         common to Group 0 and Group 1 to EL2.\nVGrp1DIE, bit [7]      - VM Group 1 Disabled Interrupt Enable.\nVGrp1EIE, bit [6]      - VM Group 1 Enabled Interrupt Enable.\nVGrp0DIE, bit [5]      - VM Group 0 Disabled Interrupt Enable.\nVGrp0EIE, bit [4]      - VM Group 0 Enabled Interrupt Enable.\nNPIE, bit [3]          - No Pending Interrupt Enable.\nLRENPIE, bit [2]       - List Register Entry Not Present Interrupt Enable.\nUIE, bit [1]           - Underflow Interrupt Enable.\nEn, bit [0]            - Enable."
      },
      "ICH_LR<n>_EL2": {
        "long_name": "Interrupt Controller List Registers",
        "purpose": "Provides interrupt context information for the virtual CPU interface.\n\nState, bits [62:63]    - The state of the interrupt:\nHW, bit [61]           - Indicates whether this virtual interrupt maps directly\n                         to a hardware interrupt, meaning that it corresponds to\n                         a physical interrupt.\nGroup, bit [60]        - Indicates the group for this virtual interrupt.\nPriority, bits [48:55] - The priority of this interrupt.\npINTID, bits [32:44]   - Physical INTID, for hardware interrupts.\nvINTID, bits [0:31]    - Virtual INTID of the interrupt."
      },
      "ICH_MISR_EL2": {
        "long_name": "Interrupt Controller Maintenance Interrupt State Register",
        "purpose": "Indicates which maintenance interrupts are asserted.\n\nVGrp1D, bit [7] - vPE Group 1 Disabled.\nVGrp1E, bit [6] - vPE Group 1 Enabled.\nVGrp0D, bit [5] - vPE Group 0 Disabled.\nVGrp0E, bit [4] - vPE Group 0 Enabled.\nNP, bit [3]     - No Pending.\nLRENP, bit [2]  - List Register Entry Not Present.\nU, bit [1]      - Underflow.\nEOI, bit [0]    - End Of Interrupt."
      },
      "ICH_VMCR_EL2": {
        "long_name": "Interrupt Controller Virtual Machine Control Register",
        "purpose": "Enables the hypervisor to save and restore the virtual machine view of the GIC\nstate.\n\nVPMR, bits [24:31]  - Virtual Priority Mask.\nVBPR0, bits [21:23] - Virtual Binary Point Register, Group 0.\nVBPR1, bits [18:20] - Virtual Binary Point Register, Group 1.\nVEOIM, bit [9]      - Virtual EOI mode.\nVCBPR, bit [4]      - Virtual Common Binary Point Register.\nVFIQEn, bit [3]     - Virtual FIQ enable.\nVAckCtl, bit [2]    - Virtual AckCtl.\nVENG1, bit [1]      - Virtual Group 1 interrupt enable.\nVENG0, bit [0]      - Virtual Group 0 interrupt enable."
      },
      "ICH_VTR_EL2": {
        "long_name": "Interrupt Controller VGIC Type Register",
        "purpose": "Reports supported GIC virtualisartion features.\n\nPRIbits, bits [29:31] - Priority bits. The number of virtual priority bits\n                        implemented, minus one. An implementation must implement\n                        at least 32 levels of virtual priority (5 priority\n                        bits). This field is an alias of ICV_CTLR_EL1.PRIbits.\nPREbits, bits [26:28] - The number of virtual preemption bits implemented, minus\n                        one. An implementation must implement at least 32 levels\n                        of virtual preemption priority (5 preemption bits). The\n                        value of this field must be less than or equal to the\n                        value of ICH_VTR_EL2.PRIbits. The maximum value of this\n                        field is 6, indicating 7 bits of preemption. This field\n                        determines the minimum value of ICH_VMCR_EL2.VBPR0.\nIDbits, bits [23:25]  - The number of virtual interrupt identifier bits\n                        supported:\nSEIS, bit [22]        - SEI Support.\nA3V, bit [21]         - Affinity 3 Valid.\nnV4, bit [20]         - Direct injection of virtual interrupts not supported.\nTDS, bit [19]         - Separate trapping of EL1 writes to ICV_DIR_EL1\n                        supported.\nListRegs, bits [0:4]  - The number of implemented List registers, minus one. For\n                        example, a value of 0b01111 indicates that the maximum\n                        of 16 List registers are implemented."
      },
      "ICV_AP0R<n>_EL1": {
        "long_name": "Interrupt Controller Virtual Active Priorities Group 0 Registers",
        "purpose": "Provides information about virtual Group 0 active priorities."
      },
      "ICV_AP1R<n>_EL1": {
        "long_name": "Interrupt Controller Virtual Active Priorities Group 1 Registers",
        "purpose": "Provides information about virtual Group 1 active priorities."
      },
      "ICV_BPR0_EL1": {
        "long_name": "Interrupt Controller Virtual Binary Point Register 0",
        "purpose": "Defines the point at which the priority value fields split into two parts, the\ngroup priority field and the subpriority field. The group priority field\ndetermines virtual Group 0 interrupt preemption.\n\nBinaryPoint, bits [0:2] - The value of this field controls how the 8-bit\n                          interrupt priority field is split into a group\n                          priority field, that determines interrupt preemption,\n                          and a subpriority field. This is done as follows:"
      },
      "ICV_BPR1_EL1": {
        "long_name": "Interrupt Controller Virtual Binary Point Register 1",
        "purpose": "Defines the point at which the priority value fields split into two parts, the\ngroup priority field and the subpriority field. The group priority field\ndetermines virtual Group 1 interrupt preemption.\n\nBinaryPoint, bits [0:2] - If the GIC is configured to use separate binary point\n                          fields for virtual Group 0 and virtual Group 1\n                          interrupts, the value of this field controls how the\n                          8-bit interrupt priority field is split into a group\n                          priority field, that determines interrupt preemption,\n                          and a subpriority field. This is done as follows:\n                          Writing 0 to this field will set this field to its\n                          reset value. If ICV_CTLR_EL1.CBPR is set to 1, Non-\n                          secure EL1 reads return ICV_BPR0_EL1 + 1 saturated to\n                          0b111. Non-secure EL1 writes are ignored. If\n                          ICV_CTLR_EL1.CBPR is set to 1, Secure EL1 reads return\n                          ICV_BPR0_EL1. Secure EL1 writes modify ICV_BPR0_EL1."
      },
      "ICV_CTLR_EL1": {
        "long_name": "Interrupt Controller Virtual Control Register",
        "purpose": "Controls aspects of the behavior of the GIC virtual CPU interface and provides\ninformation about the features implemented.\n\nExtRange, bit [19]   - Extended INTID range (read-only).\nRSS, bit [18]        - Range Selector Support.\nA3V, bit [15]        - Affinity 3 Valid. Read-only and writes are ignored.\nSEIS, bit [14]       - SEI Support. Read-only and writes are ignored.\nIDbits, bits [11:13] - Identifier bits. Read-only and writes are ignored.\nPRIbits, bits [8:10] - Priority bits. Read-only and writes are ignored. The\n                       number of priority bits implemented, minus one. An\n                       implementation must implement at least 32 levels of\n                       physical priority (5 priority bits). This field always\n                       returns the number of priority bits implemented. The\n                       division between group priority and subpriority is\n                       defined in the binary point registers ICV_BPR0_EL1 and\n                       ICV_BPR1_EL1.\nEOImode, bit [1]     - Virtual EOI mode.\nCBPR, bit [0]        - Common Binary Point Register."
      },
      "ICV_DIR_EL1": {
        "long_name": "Interrupt Controller Deactivate Virtual Interrupt Register",
        "purpose": "When interrupt priority drop is separated from interrupt deactivation, a write\nto this register deactivates the specified virtual interrupt.\n\nINTID, bits [0:23] - The INTID of the virtual interrupt to be deactivated. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR_EL1.IDbits. If\n                     only 16 bits are implemented, bits [23:16] of this register\n                     are res0."
      },
      "ICV_EOIR0_EL1": {
        "long_name": "Interrupt Controller Virtual End Of Interrupt Register 0",
        "purpose": "A PE writes to this register to inform the CPU interface that it has completed\nthe processing of the specified virtual Group 0 interrupt.\n\nINTID, bits [0:23] - The INTID from the corresponding ICV_IAR0_EL1 access. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR_EL1.IDbits. If\n                     only 16 bits are implemented, bits [23:16] of this register\n                     are res0. If the ICV_CTLR.EOImode bit is 0, a write to this\n                     register drops the priority for the virtual interrupt, and\n                     also deactivates the virtual interrupt. If the\n                     ICV_CTLR.EOImode bit is 1, a write to this register only\n                     drops the priority for the virtual interrupt. Software must\n                     write to ICV_DIR_EL1 to deactivate the virtual interrupt."
      },
      "ICV_EOIR1_EL1": {
        "long_name": "Interrupt Controller Virtual End Of Interrupt Register 1",
        "purpose": "A PE writes to this register to inform the CPU interface that it has completed\nthe processing of the specified virtual Group 1 interrupt.\n\nINTID, bits [0:23] - The INTID from the corresponding ICV_IAR1_EL1 access. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR_EL1.IDbits. If\n                     only 16 bits are implemented, bits [23:16] of this register\n                     are res0. If the ICV_CTLR.EOImode bit is 0, a write to this\n                     register drops the priority for the virtual interrupt, and\n                     also deactivates the virtual interrupt. If the\n                     ICV_CTLR.EOImode bit is 1, a write to this register only\n                     drops the priority for the virtual interrupt. Software must\n                     write to ICV_DIR_EL1 to deactivate the virtual interrupt."
      },
      "ICV_HPPIR0_EL1": {
        "long_name": "Interrupt Controller Virtual Highest Priority Pending Interrupt Register 0",
        "purpose": "Indicates the highest priority pending virtual Group 0 interrupt on the virtual\nCPU interface.\n\nINTID, bits [0:23] - The INTID of the highest priority pending virtual\n                     interrupt. If the highest priority pending interrupt is not\n                     observable, this field contains a special INTID to indicate\n                     the reason. This special INTID can take the value 1023\n                     only. See Special INTIDs, for more information. This field\n                     has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR_EL1.IDbits. If\n                     only 16 bits are implemented, bits [23:16] of this register\n                     are res0."
      },
      "ICV_HPPIR1_EL1": {
        "long_name": "Interrupt Controller Virtual Highest Priority Pending Interrupt Register 1",
        "purpose": "Indicates the highest priority pending virtual Group 1 interrupt on the virtual\nCPU interface.\n\nINTID, bits [0:23] - The INTID of the highest priority pending virtual\n                     interrupt. If the highest priority pending interrupt is not\n                     observable, this field contains a special INTID to indicate\n                     the reason. This special INTID can take the value 1023\n                     only. See Special INTIDs, for more information. This field\n                     has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR_EL1.IDbits. If\n                     only 16 bits are implemented, bits [23:16] of this register\n                     are res0."
      },
      "ICV_IAR0_EL1": {
        "long_name": "Interrupt Controller Virtual Interrupt Acknowledge Register 0",
        "purpose": "The PE reads this register to obtain the INTID of the signaled virtual Group 0\ninterrupt. This read acts as an acknowledge for the interrupt.\n\nINTID, bits [0:23] - The INTID of the signaled virtual interrupt. This is the\n                     INTID of the highest priority pending virtual interrupt, if\n                     that interrupt is of sufficient priority for it to be\n                     signaled to the PE, and if it can be acknowledged. If the\n                     highest priority pending interrupt is not observable, this\n                     field contains a special INTID to indicate the reason. This\n                     special INTID can take the value 1023 only. See Special\n                     INTIDs, for more information. This field has either 16 or\n                     24 bits implemented. The number of implemented bits can be\n                     found in ICV_CTLR_EL1.IDbits. If only 16 bits are\n                     implemented, bits [23:16] of this register are res0."
      },
      "ICV_IAR1_EL1": {
        "long_name": "Interrupt Controller Virtual Interrupt Acknowledge Register 1",
        "purpose": "The PE reads this register to obtain the INTID of the signaled virtual Group 1\ninterrupt. This read acts as an acknowledge for the interrupt.\n\nINTID, bits [0:23] - The INTID of the signaled virtual interrupt. This is the\n                     INTID of the highest priority pending virtual interrupt, if\n                     that interrupt is of sufficient priority for it to be\n                     signaled to the PE, and if it can be acknowledged. If the\n                     highest priority pending interrupt is not observable, this\n                     field contains a special INTID to indicate the reason. This\n                     special INTID can take the value 1023 only. See Special\n                     INTIDs, for more information. This field has either 16 or\n                     24 bits implemented. The number of implemented bits can be\n                     found in ICV_CTLR_EL1.IDbits. If only 16 bits are\n                     implemented, bits [23:16] of this register are res0."
      },
      "ICV_IGRPEN0_EL1": {
        "long_name": "Interrupt Controller Virtual Interrupt Group 0 Enable register",
        "purpose": "Controls whether virtual Group 0 interrupts are enabled or not.\n\nEnable, bit [0] - Enables virtual Group 0 interrupts.\n                      0b0 Virtual Group 0 interrupts are disabled.\n                      0b1 Virtual Group 0 interrupts are enabled."
      },
      "ICV_IGRPEN1_EL1": {
        "long_name": "Interrupt Controller Virtual Interrupt Group 1 Enable register",
        "purpose": "Controls whether virtual Group 1 interrupts are enabled for the current Security\nstate.\n\nEnable, bit [0] - Enables virtual Group 1 interrupts.\n                      0b0 Virtual Group 1 interrupts are disabled.\n                      0b1 Virtual Group 1 interrupts are enabled."
      },
      "ICV_PMR_EL1": {
        "long_name": "Interrupt Controller Virtual Interrupt Priority Mask Register",
        "purpose": "Provides a virtual interrupt priority filter. Only virtual interrupts with a\nhigher priority than the value in this register are signaled to the PE.\n\nPriority, bits [0:7] - The priority mask level for the virtual CPU interface. If\n                       the priority of a virtual interrupt is higher than the\n                       value indicated by this field, the interface signals the\n                       virtual interrupt to the PE. The possible priority field\n                       values are as follows: Unimplemented priority bits are\n                       RAZ/WI."
      },
      "ICV_RPR_EL1": {
        "long_name": "Interrupt Controller Virtual Running Priority Register",
        "purpose": "Indicates the Running priority of the virtual CPU interface.\n\nPriority, bits [0:7] - The current running priority on the virtual CPU\n                       interface. This is the group priority of the current\n                       active virtual interrupt. If there are no active\n                       interrupts on the virtual CPU interface, or all active\n                       interrupts have undergone a priority drop, the value\n                       returned is the Idle priority. The priority returned is\n                       the group priority as if the BPR for the current\n                       Exception level and Security state was set to the minimum\n                       value of BPR for the number of implemented priority bits.\n                       If 8 bits of priority are implemented the group priority\n                       is bits[7:1] of the priority."
      },
      "ID_AA64AFR0_EL1": {
        "long_name": "AArch64 Auxiliary Feature Register 0",
        "purpose": "Provides information about the implementation defined features of the PE in\nAArch64 state.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1."
      },
      "ID_AA64AFR1_EL1": {
        "long_name": "AArch64 Auxiliary Feature Register 1",
        "purpose": "Reserved for future expansion of information about the implementation defined\nfeatures of the PE in AArch64 state.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1."
      },
      "ID_AA64DFR0_EL1": {
        "long_name": "AArch64 Debug Feature Register 0",
        "purpose": "Provides top level information about the debug system in AArch64 state.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nMTPMU, bits [48:51]      - Multi-threaded PMU extension.\nTraceFilt, bits [40:43]  - Armv8.4 Self-hosted Trace Extension version.\nDoubleLock, bits [36:39] - OS Double Lock implemented.\nPMSVer, bits [32:35]     - Statistical Profiling Extension version.\nCTX_CMPs, bits [28:31]   - Number of breakpoints that are context-aware, minus\n                           1. These are the highest numbered breakpoints.\nWRPs, bits [20:23]       - Number of watchpoints, minus 1. The value of 0b0000\n                           is reserved.\nBRPs, bits [12:15]       - Number of breakpoints, minus 1. The value of 0b0000\n                           is reserved.\nPMUVer, bits [8:11]      - Performance Monitors Extension version. This field\n                           does not follow the standard ID scheme, but uses the\n                           Alternative ID scheme described in 'Alternative ID\n                           scheme used for the Performance Monitors Extension\n                           version' in the Arm\u00ae Architecture Reference Manual,\n                           Armv8, for Armv8-A architecture profile.\nTraceVer, bits [4:7]     - Trace support. Indicates whether System register\n                           interface to a PE trace unit is implemented.\nDebugVer, bits [0:3]     - Debug architecture version. Indicates presence of\n                           Armv8 debug architecture."
      },
      "ID_AA64DFR1_EL1": {
        "long_name": "AArch64 Debug Feature Register 1",
        "purpose": "Reserved for future expansion of top level information about the debug system in\nAArch64 state.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1."
      },
      "ID_AA64ISAR0_EL1": {
        "long_name": "AArch64 Instruction Set Attribute Register 0",
        "purpose": "Provides information about the instructions implemented in AArch64 state.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nRNDR, bits [60:63]   - Indicates support for Random Number instructions in\n                       AArch64 state.\nTLB, bits [56:59]    - Indicates support for Outer shareable and TLB range\n                       maintenance instructions.\nTS, bits [52:55]     - Indicates support for flag manipulation instructions.\nFHM, bits [48:51]    - Indicates whether FMLAL and FMLSL instructions are\n                       implemented.\nDP, bits [44:47]     - Dot Product instructions implemented in AArch64 state.\nSM4, bits [40:43]    - SM4 instructions implemented in AArch64 state.\nSM3, bits [36:39]    - SM3 instructions implemented in AArch64 state.\nSHA3, bits [32:35]   - SHA3 instructions implemented in AArch64 state.\nRDM, bits [28:31]    - SQRDMLAH and SQRDMLSH instructions implemented in AArch64\n                       state.\nAtomic, bits [20:23] - Atomic instructions implemented in AArch64 state.\nCRC32, bits [16:19]  - CRC32 instructions implemented in AArch64 state.\nSHA2, bits [12:15]   - SHA2 instructions implemented in AArch64 state.\nSHA1, bits [8:11]    - SHA1 instructions implemented in AArch64 state.\nAES, bits [4:7]      - AES instructions implemented in AArch64 state."
      },
      "ID_AA64ISAR1_EL1": {
        "long_name": "AArch64 Instruction Set Attribute Register 1",
        "purpose": "Provides information about the features and instructions implemented in AArch64\nstate.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nI8MM, bits [52:55]    - Indicates support for Advanced SIMD and floating-point\n                        Int8 matrix multiplication instructions in AArch64\n                        state.\nDGH, bits [48:51]     - Indicates presence of the Data Gathering Hint\n                        instruction.\nBF16, bits [44:47]    - Indicates support for Advanced SIMD and floating-point\n                        BFloat16 instructions in AArch64 state.\nSPECRES, bits [40:43] - Speculation invalidation instruction support in AArch64\n                        state.\nSB, bits [36:39]      - SB instruction support in AArch64 state.\nFRINTTS, bits [32:35] - Indicates whether FRINT32Z, FRINT32X, FRINT64Z, and\n                        FRINT64X instructions are implemented.\nGPI, bits [28:31]     - Indicates whether an implementation defined algorithm is\n                        implemented in the PE for generic code authentication,\n                        in AArch64 state.\nGPA, bits [24:27]     - Indicates whether QARMA or Architected algorithm is\n                        implemented in the PE for generic code authentication,\n                        in AArch64 state.\nLRCPC, bits [20:23]   - Indicates support for weaker release consistency, RCpc\n                        based model.\nLRCPC, bits [20:23]   - Indicates support for weaker release consistency, RCpc\n                        based model.\nFCMA, bits [16:19]    - Indicates support for complex number addition and\n                        multiplication, where numbers are stored in vectors.\nJSCVT, bits [12:15]   - Indicates support for javascript conversion from double\n                        precision floating point values to integers in AArch64\n                        state.\nAPI, bits [8:11]      - Indicates whether an implementation defined algorithm is\n                        implemented in the PE for address authentication, in\n                        AArch64 state.\nAPA, bits [4:7]       - Indicates whether QARMA or Architected algorithm is\n                        implemented in the PE for address authentication, in\n                        AArch64 state.\nDPB, bits [0:3]       - Data Persistence writeback."
      },
      "ID_AA64MMFR0_EL1": {
        "long_name": "AArch64 Memory Model Feature Register 0",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch64 state.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nECV, bits [60:63]       - Presence of Enhanced Counter Virtualization.\nFGT, bits [56:59]       - Presence of the Fine-Grained Trap controls:\n                            - HAFGRTR_EL2, HDFGRTR_EL2, HDFGWTR_EL2, HFGRTR_EL2,\n                          HFGITR_EL2 and HFGWTR_EL2 registers, and their\n                          associated traps.\n                            - MDCR_EL2.TDCC and MDCR_EL3.TDCC.\n                            - SCR_EL3.FGTEn.\nExS, bits [44:47]       - Support for disabling context synchronizing exception\n                          entry and exit.\nTGran4_2, bits [40:43]  - Support for 4KB memory granule size for stage 2.\nTGran64_2, bits [36:39] - Support for 64KB memory granule size for stage 2.\nTGran16_2, bits [32:35] - Support for 16KB memory granule size for stage 2.\nTGran4, bits [28:31]    - Support for 4KB memory translation granule size.\nTGran64, bits [24:27]   - Support for 64KB memory translation granule size.\nTGran16, bits [20:23]   - Support for 16KB memory translation granule size.\nBigEndEL0, bits [16:19] - Mixed-endian support at EL0 only.\nSNSMem, bits [12:15]    - Secure versus Non-secure Memory distinction.\nBigEnd, bits [8:11]     - Mixed-endian configuration support.\nASIDBits, bits [4:7]    - Number of ASID bits.\nPARange, bits [0:3]     - Physical Address range supported."
      },
      "ID_AA64MMFR1_EL1": {
        "long_name": "AArch64 Memory Model Feature Register 1",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch64 state.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nETS, bits [36:39]     - Support for Enhanced Translation Synchronization.\nTWED, bits [32:35]    - Support for the configurable delayed trapping of WFE.\nXNX, bits [28:31]     - Support for execute-never control distinction by\n                        Exception level at stage 2.\nSpecSEI, bits [24:27] - Describes whether the PE can generate SError interrupt\n                        exceptions from speculative reads of memory, including\n                        speculative instruction fetches.\nPAN, bits [20:23]     - Privileged Access Never. Indicates support for the PAN\n                        bit in PSTATE, SPSR_EL1, SPSR_EL2, SPSR_EL3, and\n                        DSPSR_EL0.\nLO, bits [16:19]      - LORegions. Indicates support for LORegions.\nHPDS, bits [12:15]    - Hierarchical permission disables bits in translation\n                        tables.\nVH, bits [8:11]       - Virtualization Host Extensions.\nVMIDBits, bits [4:7]  - Number of VMID bits.\nHAFDBS, bits [0:3]    - Hardware updates to Access flag and Dirty state in\n                        translation tables."
      },
      "ID_AA64MMFR2_EL1": {
        "long_name": "AArch64 Memory Model Feature Register 2",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch64 state.\n\nFor general information about the interpretation of the ID registers see\nPrinciples of the ID scheme for fields in ID registers.\n\nE0PD, bits [60:63]    - Indicates support for the E0PD mechanism.\nEVT, bits [56:59]     - Enhanced Virtualization Traps.\nBBM, bits [52:55]     - Allows identification of the requirements of the\n                        hardware to have break-before-make sequences when\n                        changing block size for a translation.\nTTL, bits [48:51]     - Indicates support for TTL field in address operations.\nFWB, bits [40:43]     - Indicates support for HCR_EL2.FWB\nIDS, bits [36:39]     - Indicates the value of ESR_ELx.EC that reports an\n                        exception generated by a read access to the feature ID\n                        space.\nAT, bits [32:35]      - Identifies support for unaligned single-copy atomicity\n                        and atomic functions.\nST, bits [28:31]      - Identifies support for small translation tables.\nNV, bits [24:27]      - Nested Virtualization.\nCCIDX, bits [20:23]   - Support for the use of revised CCSIDR_EL1 register\n                        format.\nVARange, bits [16:19] - Indicates support for a larger virtual address.\nIESB, bits [12:15]    - Indicates support for the IESB bit in the SCTLR_ELx\n                        registers.\nLSM, bits [8:11]      - Indicates support for LSMAOE and nTLSMD bits in\n                        SCTLR_EL1 and SCTLR_EL2.\nUAO, bits [4:7]       - User Access Override.\nCnP, bits [0:3]       - Common not Private translations."
      },
      "ID_AA64PFR0_EL1": {
        "long_name": "AArch64 Processor Feature Register 0",
        "purpose": "Provides additional information about implemented PE features in AArch64 state.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nCSV3, bits [60:63]    - Speculative use of faulting data.\nCSV2, bits [56:59]    - Speculative use of out of context branch targets.\nDIT, bits [48:51]     - Data Independent Timing.\nAMU, bits [44:47]     - Activity Monitors Extension.\nMPAM, bits [40:43]    - MPAM Extension.\nSEL2, bits [36:39]    - Secure EL2.\nSVE, bits [32:35]     - Scalable Vector Extension.\nRAS, bits [28:31]     - RAS Extension version.\nGIC, bits [24:27]     - System register GIC interface support.\nAdvSIMD, bits [20:23] - Advanced SIMD.\nFP, bits [16:19]      - Floating-point.\nEL3, bits [12:15]     - EL3 Exception level handling.\nEL2, bits [8:11]      - EL2 Exception level handling.\nEL1, bits [4:7]       - EL1 Exception level handling.\nEL0, bits [0:3]       - EL0 Exception level handling."
      },
      "ID_AA64PFR1_EL1": {
        "long_name": "AArch64 Processor Feature Register 1",
        "purpose": "Reserved for future expansion of information about implemented PE features in\nAArch64 state.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nMPAM_frac, bits [16:19] - MPAM Extension fractional field.\nRAS_frac, bits [12:15]  - RAS Extension fractional field.\nMTE, bits [8:11]        - Support for the Memory Tagging Extension.\nSSBS, bits [4:7]        - Speculative Store Bypassing controls in AArch64 state.\nBT, bits [0:3]          - Branch Target Identification mechanism support in\n                          AArch64 state."
      },
      "ID_AA64ZFR0_EL1": {
        "long_name": "SVE Feature ID register 0",
        "purpose": "Provides additional information about the implemented features of the AArch64\nScalable Vector Extension, when the ID_AA64PFR0_EL1.SVE field is not zero.\n\nFor general information about the interpretation of the ID registers see\nPrinciples of the ID scheme for fields in ID registers.\n\nF64MM, bits [56:59] - Indicates support for SVE FP64 double-precision floating-\n                      point matrix multiplication instructions.\nF32MM, bits [52:55] - Indicates support for the SVE FP32 single-precision\n                      floating-point matrix multiplication instruction.\nI8MM, bits [44:47]  - Indicates support for SVE Int8 matrix multiplication\n                      instructions.\nBF16, bits [20:23]  - Indicates support for SVE BFloat16 instructions.\nSVEver, bits [0:3]  - Scalable Vector Extension instruction set version."
      },
      "ID_AFR0_EL1": {
        "long_name": "AArch32 Auxiliary Feature Register 0",
        "purpose": "Provides information about the implementation defined features of the PE in\nAArch32 state.\n\nMust be interpreted with the Main ID Register, MIDR_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1."
      },
      "ID_DFR0_EL1": {
        "long_name": "AArch32 Debug Feature Register 0",
        "purpose": "Provides top level information about the debug system in AArch32 state.\n\nMust be interpreted with the Main ID Register, MIDR_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nTraceFilt, bits [28:31] - Armv8.4 Self-hosted Trace Extension version.\nPerfMon, bits [24:27]   - Performance Monitors Extension version.\nMProfDbg, bits [20:23]  - M Profile Debug.\nMMapTrc, bits [16:19]   - Memory Mapped Trace.\nCopTrc, bits [12:15]    - Support for System registers-based trace model, using\n                          registers in the coproc == 0b1110 encoding space.\nMMapDbg, bits [8:11]    - Memory Mapped Debug.\nCopSDbg, bits [4:7]     - Support for  a System registers-based Secure debug\n                          model, using registers in the coproc = 0b1110 encoding\n                          space, for an A profile processor that includes EL3.\nCopDbg, bits [0:3]      - Support for System registers-based debug model, using\n                          registers in the coproc == 0b1110 encoding space, for\n                          A and R profile processors."
      },
      "ID_DFR1_EL1": {
        "long_name": "Debug Feature Register 1",
        "purpose": "Provides top level information about the debug system in AArch32.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nMTPMU, bits [0:3] - Multi-threaded PMU extension. Defined values are:\n                        0b0000 ARMv8.6-MTPMU not implemented. If PMUv3 is\n                    implemented, it is implementation defined whether\n                    PMEVTYPER<n>_EL0.MT are read/write or res0.\n                        0b0001 ARMv8.6-MTPMU implemented and PMEVTYPER<n>_EL0.MT\n                    are read/write. When ARMv8.6-MTPMU is disabled, the\n                    Effective values of PMEVTYPER<n>.MT are 0.\n                        0b1111 ARMv8.6-MTPMU not implemented. If PMUv3 is\n                    implemented, PMEVTYPER<n>_EL0.MT are res0.\n                    All other values are reserved. ARMv8.6-MTPMU implements the\n                    functionality identified by the value 0b0001. In an\n                    Armv8.6-compliant implementation that includes PMUv3, the\n                    value 0b0000 is not permitted. In an implementation that\n                    does not include PMUv3, the value 0b0001 is not permitted."
      },
      "ID_ISAR0_EL1": {
        "long_name": "AArch32 Instruction Set Attribute Register 0",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR1_EL1, ID_ISAR2_EL1, ID_ISAR3_EL1, ID_ISAR4_EL1,\nand ID_ISAR5_EL1.\n\nFor general information about the interpretation of the ID registers, see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD7.1.3.\n\nDivide, bits [24:27]    - Indicates the implemented Divide instructions.\nDebug, bits [20:23]     - Indicates the implemented Debug instructions.\nCoproc, bits [16:19]    - Indicates the implemented System register access\n                          instructions.\nCmpBranch, bits [12:15] - Indicates the implemented combined Compare and Branch\n                          instructions in the T32 instruction set.\nBitField, bits [8:11]   - Indicates the implemented BitField instructions.\nBitCount, bits [4:7]    - Indicates the implemented Bit Counting instructions.\nSwap, bits [0:3]        - Indicates the implemented Swap instructions in the A32\n                          instruction set."
      },
      "ID_ISAR1_EL1": {
        "long_name": "AArch32 Instruction Set Attribute Register 1",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0_EL1, ID_ISAR2_EL1, ID_ISAR3_EL1, ID_ISAR4_EL1,\nand ID_ISAR5_EL1.\n\nFor general information about the interpretation of the ID registers, see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD7.1.3.\n\nJazelle, bits [28:31]   - Indicates the implemented Jazelle extension\n                          instructions.\nInterwork, bits [24:27] - Indicates the implemented Interworking instructions.\nImmediate, bits [20:23] - Indicates the implemented data-processing instructions\n                          with long immediates.\nIfThen, bits [16:19]    - Indicates the implemented If-Then instructions in the\n                          T32 instruction set.\nExtend, bits [12:15]    - Indicates the implemented Extend instructions.\nExcept_AR, bits [8:11]  - Indicates the implemented A and R profile exception-\n                          handling instructions.\nExcept, bits [4:7]      - Indicates the implemented exception-handling\n                          instructions in the A32 instruction set.\nEndian, bits [0:3]      - Indicates the implemented Endian instructions."
      },
      "ID_ISAR2_EL1": {
        "long_name": "AArch32 Instruction Set Attribute Register 2",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0_EL1, ID_ISAR1_EL1, ID_ISAR3_EL1, ID_ISAR4_EL1,\nand ID_ISAR5_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nReversal, bits [28:31]      - Indicates the implemented Reversal instructions.\nPSR_AR, bits [24:27]        - Indicates the implemented A and R profile\n                              instructions to manipulate the PSR.\nMultU, bits [20:23]         - Indicates the implemented advanced unsigned\n                              Multiply instructions.\nMultS, bits [16:19]         - Indicates the implemented advanced signed Multiply\n                              instructions.\nMult, bits [12:15]          - Indicates the implemented additional Multiply\n                              instructions.\nMultiAccessInt, bits [8:11] - Indicates the support for interruptible multi-\n                              access instructions.\nMemHint, bits [4:7]         - Indicates the implemented Memory Hint\n                              instructions.\nLoadStore, bits [0:3]       - Indicates the implemented additional load/store\n                              instructions."
      },
      "ID_ISAR3_EL1": {
        "long_name": "AArch32 Instruction Set Attribute Register 3",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0_EL1, ID_ISAR1_EL1, ID_ISAR2_EL1, ID_ISAR4_EL1,\nand ID_ISAR5_EL1.\n\nFor general information about the interpretation of the ID registers, see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD7.1.3.\n\nT32EE, bits [28:31]     - Indicates the implemented T32EE instructions.\nTrueNOP, bits [24:27]   - Indicates the implemented true NOP instructions.\nT32Copy, bits [20:23]   - Indicates the support for T32 non flag-setting MOV\n                          instructions.\nTabBranch, bits [16:19] - Indicates the implemented Table Branch instructions in\n                          the T32 instruction set.\nSynchPrim, bits [12:15] - Used in conjunction with ID_ISAR4.SynchPrim_frac to\n                          indicate the implemented Synchronization Primitive\n                          instructions.\nSVC, bits [8:11]        - Indicates the implemented SVC instructions.\nSIMD, bits [4:7]        - Indicates the implemented SIMD instructions.\nSaturate, bits [0:3]    - Indicates the implemented Saturate instructions."
      },
      "ID_ISAR4_EL1": {
        "long_name": "AArch32 Instruction Set Attribute Register 4",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0_EL1, ID_ISAR1_EL1, ID_ISAR2_EL1, ID_ISAR3_EL1,\nand ID_ISAR5_EL1.\n\nFor general information about the interpretation of the ID registers, see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD7.1.3.\n\nSWP_frac, bits [28:31]       - Indicates support for the memory system locking\n                               the bus for SWP or SWPB instructions.\nPSR_M, bits [24:27]          - Indicates the implemented M profile instructions\n                               to modify the PSRs.\nSynchPrim_frac, bits [20:23] - Used in conjunction with ID_ISAR3.SynchPrim to\n                               indicate the implemented Synchronization\n                               Primitive instructions.\nBarrier, bits [16:19]        - Indicates the implemented Barrier instructions in\n                               the A32 and T32 instruction sets.\nSMC, bits [12:15]            - Indicates the implemented SMC instructions.\nWriteback, bits [8:11]       - Indicates the support for Writeback addressing\n                               modes.\nWithShifts, bits [4:7]       - Indicates the support for instructions with\n                               shifts.\nUnpriv, bits [0:3]           - Indicates the implemented unprivileged\n                               instructions."
      },
      "ID_ISAR5_EL1": {
        "long_name": "AArch32 Instruction Set Attribute Register 5",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0_EL1, ID_ISAR1_EL1, ID_ISAR2_EL1, ID_ISAR3_EL1,\nand ID_ISAR4_EL1.\n\nFor general information about the interpretation of the ID registers, see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD7.1.3.\n\nVCMA, bits [28:31]  - Indicates AArch32 support for complex number addition and\n                      multiplication where numbers are stored in vectors.\nRDM, bits [24:27]   - Indicates whether the VQRDMLAH and VQRDMLSH instructions\n                      are implemented in AArch32 state.\nCRC32, bits [16:19] - Indicates whether the CRC32 instructions are implemented\n                      in AArch32 state.\nSHA2, bits [12:15]  - Indicates whether the SHA2 instructions are implemented in\n                      AArch32 state.\nSHA1, bits [8:11]   - Indicates whether the SHA1 instructions are implemented in\n                      AArch32 state.\nAES, bits [4:7]     - Indicates whether the AES instructions are implemented in\n                      AArch32 state.\nSEVL, bits [0:3]    - Indicates whether the SEVL instruction is implemented in\n                      AArch32 state."
      },
      "ID_ISAR6_EL1": {
        "long_name": "AArch32 Instruction Set Attribute Register 6",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0_EL1, ID_ISAR1_EL1, ID_ISAR2_EL1, ID_ISAR3_EL1,\nID_ISAR4_EL1 and ID_ISAR5_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nI8MM, bits [24:27]    - Indicates support for Advanced SIMD and floating-point\n                        Int8 matrix multiplication instructions in AArch32\n                        state.\nBF16, bits [20:23]    - Indicates support for Advanced SIMD and floating-point\n                        BFloat16 instructions in AArch32 state.\nSPECRES, bits [16:19] - Indicates supporte for Speculation invalidation\n                        instruction in AArch32 state.\nSB, bits [12:15]      - Indicates support for SB instruction in AArch32 state.\nFHM, bits [8:11]      - Indicates support for Advanced SIMD and floating-point\n                        VFMAL and VFMSL instructions in AArch32 state.\nDP, bits [4:7]        - Indicates the support for dot product instructions in\n                        AArch32 state.\nJSCVT, bits [0:3]     - Indicates support for the Javascript conversion\n                        instruction in AArch32 state."
      },
      "ID_MMFR0_EL1": {
        "long_name": "AArch32 Memory Model Feature Register 0",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR1_EL1, ID_MMFR2_EL1, ID_MMFR3_EL1, and\nID_MMFR4_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nInnerShr, bits [28:31] - Innermost Shareability. Indicates the innermost\n                         shareability domain implemented.\nFCSE, bits [24:27]     - Indicates whether the implementation includes the FCSE.\nAuxReg, bits [20:23]   - Auxiliary Registers. Indicates support for Auxiliary\n                         registers.\nTCM, bits [16:19]      - Indicates support for TCMs and associated DMAs.\nShareLvl, bits [12:15] - Shareability Levels. Indicates the number of\n                         shareability levels implemented.\nOuterShr, bits [8:11]  - Outermost Shareability. Indicates the outermost\n                         shareability domain implemented.\nPMSA, bits [4:7]       - Indicates support for a PMSA.\nVMSA, bits [0:3]       - Indicates support for a VMSA."
      },
      "ID_MMFR1_EL1": {
        "long_name": "AArch32 Memory Model Feature Register 1",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR0_EL1, ID_MMFR2_EL1, ID_MMFR3_EL1, and\nID_MMFR4_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nBPred, bits [28:31]    - Branch Predictor.\nL1TstCln, bits [24:27] - Level 1 cache Test and Clean.\nL1Uni, bits [20:23]    - Level 1 Unified cache.\nL1Hvd, bits [16:19]    - Level 1 Harvard cache.\nL1UniSW, bits [12:15]  - Level 1 Unified cache by Set/Way.\nL1HvdSW, bits [8:11]   - Level 1 Harvard cache by Set/Way.\nL1UniVA, bits [4:7]    - Level 1 Unified cache by Virtual Address.\nL1HvdVA, bits [0:3]    - Level 1 Harvard cache by Virtual Address."
      },
      "ID_MMFR2_EL1": {
        "long_name": "AArch32 Memory Model Feature Register 2",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR0_EL1, ID_MMFR1_EL1, ID_MMFR3_EL1, and\nID_MMFR4_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nHWAccFlg, bits [28:31] - Hardware Access Flag.\nWFIStall, bits [24:27] - Wait For Interrupt Stall.\nMemBarr, bits [20:23]  - Memory Barrier.\nUniTLB, bits [16:19]   - Unified TLB.\nHvdTLB, bits [12:15]   - If the Unified TLB field (UniTLB, bits [19:16]) is not\n                         0000, then the meaning of this field is implementation\n                         defined.\nL1HvdRng, bits [8:11]  - Level 1 Harvard cache Range.\nL1HvdBG, bits [4:7]    - Level 1 Harvard cache Background fetch.\nL1HvdFG, bits [0:3]    - Level 1 Harvard cache Foreground fetch."
      },
      "ID_MMFR3_EL1": {
        "long_name": "AArch32 Memory Model Feature Register 3",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR0_EL1, ID_MMFR1_EL1, ID_MMFR2_EL1, and\nID_MMFR4_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nSupersec, bits [28:31]  - Supersections.\nCMemSz, bits [24:27]    - Cached Memory Size.\nCohWalk, bits [20:23]   - Coherent Walk.\nPAN, bits [16:19]       - Privileged Access Never.\nMaintBcst, bits [12:15] - Maintenance Broadcast.\nBPMaint, bits [8:11]    - Branch Predictor Maintenance.\nCMaintSW, bits [4:7]    - Cache Maintenance by Set/Way.\nCMaintVA, bits [0:3]    - Cache Maintenance by  Virtual Address."
      },
      "ID_MMFR4_EL1": {
        "long_name": "AArch32 Memory Model Feature Register 4",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR0_EL1, ID_MMFR1_EL1, ID_MMFR2_EL1, and\nID_MMFR3_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nEVT, bits [28:31]   - Enhanced Virtualization Traps. If EL2 is implemented,\n                      indicates support for the HCR2.{TTLBIS, TOCU, TICAB, TID4}\n                      traps.\nCCIDX, bits [24:27] - Support for use of the revised CCSIDR format and the\n                      presence of the CCSIDR2 is indicated.\nLSM, bits [20:23]   - Indicates support for LSMAOE and nTLSMD bits in HSCTLR and\n                      SCTLR.\nHPDS, bits [16:19]  - Hierarchical permission disables bits in translation\n                      tables.\nCnP, bits [12:15]   - Common not Private translations.\nXNX, bits [8:11]    - Support for execute-never control distinction by Exception\n                      level at stage 2.\nAC2, bits [4:7]     - Indicates the extension of the ACTLR and HACTLR registers\n                      using ACTLR2 and HACTLR2.\nSpecSEI, bits [0:3] - Describes whether the PE can generate SError interrupt\n                      exceptions from speculative reads of memory, including\n                      speculative instruction fetches."
      },
      "ID_MMFR5_EL1": {
        "long_name": "AArch32 Memory Model Feature Register 5",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nETS, bits [0:3] - Support for Enhanced Translation Synchronization. Defined\n                  values are:\n                      0b0000 Enhanced Translation Synchronization is not\n                  supported.\n                      0b0001 Enhanced Translation Synchronization is supported.\n                  All other values are reserved. ARMv8.0-ETS implements the\n                  functionality identified by the value 0b0001. From Armv8.0,\n                  the permitted values are 0b0000 and 0b0001."
      },
      "ID_PFR0_EL1": {
        "long_name": "AArch32 Processor Feature Register 0",
        "purpose": "Gives top-level information about the instruction sets supported by the PE in\nAArch32 state.\n\nMust be interpreted with ID_PFR1_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nRAS, bits [28:31]    - RAS Extension version.\nDIT, bits [24:27]    - Data Independent Timing.\nAMU, bits [20:23]    - Activity Monitors Extension.\nCSV2, bits [16:19]   - Speculative use of out of context branch targets.\nState3, bits [12:15] - T32EE instruction set support.\nState2, bits [8:11]  - Jazelle extension support.\nState1, bits [4:7]   - T32 instruction set support.\nState0, bits [0:3]   - A32 instruction set support."
      },
      "ID_PFR1_EL1": {
        "long_name": "AArch32 Processor Feature Register 1",
        "purpose": "Gives information about the AArch32 programmers' model.\n\nMust be interpreted with ID_PFR0_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nGIC, bits [28:31]            - System register GIC CPU interface.\nVirt_frac, bits [24:27]      - Virtualization fractional field. When the\n                               Virtualization field is 0b0000, determines the\n                               support for features from the ARMv7\n                               Virtualization Extensions.\nSec_frac, bits [20:23]       - Security fractional field. When the Security\n                               field is 0b0000, determines the support for\n                               features from the ARMv7 Security Extensions.\nGenTimer, bits [16:19]       - Generic Timer support.\nVirtualization, bits [12:15] - Virtualization support.\nMProgMod, bits [8:11]        - M profile programmers' model support.\nSecurity, bits [4:7]         - Security support.\nProgMod, bits [0:3]          - Support for the standard programmers' model for\n                               Armv4 and later. Model must support User, FIQ,\n                               IRQ, Supervisor, Abort, Undefined, and System\n                               modes."
      },
      "ID_PFR2_EL1": {
        "long_name": "AArch32 Processor Feature Register 2",
        "purpose": "Gives information about the AArch32 programmers' model.\n\nMust be interpreted with ID_PFR0_EL1 and ID_PFR1_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nRAS_frac, bits [8:11] - RAS Extension fractional field.\nSSBS, bits [4:7]      - Speculative Store Bypassing controls in AArch64 state.\nCSV3, bits [0:3]      - Speculative use of faulting data."
      },
      "IFSR32_EL2": {
        "long_name": "Instruction Fault Status Register (EL2)",
        "purpose": "Allows access to the AArch32 IFSR register from AArch64 state only. Its value\nhas no effect on execution in AArch64 state.\n\nFnV, bit [16]       - FAR not Valid, for a synchronous External abort other than\n                      a synchronous External abort on a translation table walk.\nExT, bit [12]       - External abort type. This bit can be used to provide an\n                      implementation defined classification of External aborts.\n                      In an implementation that does not provide any\n                      classification of External aborts, this bit is res0. For\n                      aborts other than External aborts this bit always returns\n                      0.\nFS[4], bit [10]     - This field is bit[4] of FS[4:0]. Fault Status bits. Bits\n                      [10] and [3:0] are interpreted together.\nLPAE, bit [9]       - On taking a Data Abort exception, this bit is set as\n                      follows:\nFS[3:0], bits [0:3] - This field is bits[3:0] of FS[4:0]. See FS[4] for the\n                      field description."
      },
      "ISR_EL1": {
        "long_name": "Interrupt Status Register",
        "purpose": "Shows the pending status of the IRQ, FIQ, or SError interrupt.\n\nWhen executing at EL2, EL3 or Secure EL1 when SCR_EL3.EEL2 == 0b0, this shows\nthe pending status of the physical IRQ, FIQ, or SError interrupts.\n\nWhen executing at either Non-secure EL1 or at Secure EL1 when SCR_EL3.EEL2 ==\n0b1:\n\n  - If the HCR_EL2.{IMO,FMO,AMO} bit has a value of 1, the corresponding\nISR_EL1.{I,F,A} bit shows the pending status of the virtual IRQ, FIQ, or SError.\n  - If the HCR_EL2.{IMO,FMO,AMO} bit has a value of 0, the corresponding\nISR_EL1.{I,F,A} bit shows the pending status of the physical IRQ, FIQ, or\nSError.\n\nA, bit [8] - SError interrupt pending bit.\n                 0b0 No pending SError.\n                 0b1 An SError interrupt is pending.\n             If the SError interrupt is edge-triggered, this field is cleared to\n             zero when the physical SError interrupt is taken.\nI, bit [7] - IRQ pending bit. Indicates whether an IRQ interrupt is pending:\n                 0b0 No pending IRQ.\n                 0b1 An IRQ interrupt is pending.\nF, bit [6] - FIQ pending bit. Indicates whether an FIQ interrupt is pending.\n                 0b0 No pending FIQ.\n                 0b1 An FIQ interrupt is pending."
      },
      "LORC_EL1": {
        "long_name": "LORegion Control (EL1)",
        "purpose": "Enables and disables LORegions, and selects the current LORegion descriptor.\n\nDS, bits [2:9] - Descriptor Select. Selects the current LORegion descriptor\n                 accessed by LORSA_EL1, LOREA_EL1, and LORN_EL1. The number of\n                 LORegion descriptors in implementation defined. The maximum\n                 number of LORegion descriptors supported is 256. If the number\n                 is less than 256, then bits[63:M+2] are res0, where M is\n                 Log_2(Number of LORegion descriptors supported by the\n                 implementation). If this field points to an LORegion descriptor\n                 that is not supported by an implementation, then the registers\n                 LORN_EL1, LOREA_EL1, and LORSA_EL1 are res0.\nEN, bit [0]    - Enable. Indicates whether LORegions are enabled.\n                     0b0 Disabled. Memory accesses do not match any LORegions.\n                     0b1 Enabled. Memory accesses may match a LORegion.\n                 This bit is permitted to be cached in a TLB."
      },
      "LOREA_EL1": {
        "long_name": "LORegion End Address (EL1)",
        "purpose": "Holds the physical address of the end of the LORegion described in the current\nLORegion descriptor selected by LORC_EL1.DS.\n\nEA[51:48], bits [48:51] - Extension to EA[47:16]. See EA[47:16] for more\n                          details.\nEA[47:16], bits [16:47] - Bits [47:16] of the end physical address of an\n                          LORegion described in the current LORegion descriptor\n                          selected by LORC_EL1.DS. Bits[15:0] of this address\n                          are defined to be 0xFFFF. For implementations with\n                          fewer than 48 bits, the upper bits of this field are\n                          res0. When ARMv8.2-LPA is implemented, and 52-bit\n                          addresses and a 64KB translation granule are in use,\n                          EA[51:48] form the upper part of the address value.\n                          Otherwise, for implementations with fewer than 52\n                          physical address bits, EA[51:48] are res0."
      },
      "LORID_EL1": {
        "long_name": "LORegionID (EL1)",
        "purpose": "Indicates the number of LORegions and LORegion descriptors supported by the PE.\n\nLD, bits [16:23] - Number of LORegion descriptors supported by the PE. This is\n                   an 8-bit binary number.\nLR, bits [0:7]   - Number of LORegions supported by the PE. This is an 8-bit\n                   binary number. If LORID_EL1 indicates that no LORegions are\n                   implemented, then LoadLOAcquire and StoreLORelease will\n                   behave as LoadAcquire and StoreRelease."
      },
      "LORN_EL1": {
        "long_name": "LORegion Number (EL1)",
        "purpose": "Holds the number of the LORegion described in the current LORegion descriptor\nselected by LORC_EL1.DS.\n\nNum, bits [0:7] - Number of the LORegion described in the current LORegion\n                  descriptor selected by LORC_EL1.DS. The maximum number of\n                  LORegions supported by the PE is 256. If the maximum number is\n                  less than 256, then bits[8:N] are res0, where N is\n                  (Log_2(Number of LORegions supported by the PE)). If this\n                  field points to a LORegion that is not supported by the PE,\n                  then the current LORegion descriptor does not match any\n                  LORegion."
      },
      "LORSA_EL1": {
        "long_name": "LORegion Start Address (EL1)",
        "purpose": "Indicates whether the current LORegion descriptor selected by LORC_EL1.DS is\nenabled, and holds the physical address of the start of the LORegion.\n\nSA[51:48], bits [48:51] - Extension to SA[47:16]. See SA[47:16] for more\n                          details.\nSA[47:16], bits [16:47] - Bits [47:16] of the start physical address of the\n                          LORegion described in the current LORegion descriptor\n                          selected by LORC_EL1.DS. Bits[15:0] of this address\n                          are defined to be 0x0000. For implementations with\n                          fewer than 48 bits, the upper bits of this field are\n                          res0. When ARMv8.2-LPA is implemented, and 52-bit\n                          addresses and a 64KB translation granule are in use,\n                          SA[51:48] form the upper part of the address value.\n                          Otherwise, for implementations with fewer than 52\n                          physical address bits, SA[51:48] are res0.\nValid, bit [0]          - Indicates whether the current LORegion Descriptor is\n                          enabled.\n                              0b0 Disabled\n                              0b1 Enabled"
      },
      "MAIR_EL1": {
        "long_name": "Memory Attribute Indirection Register (EL1)",
        "purpose": "Provides the memory attribute encodings corresponding to the possible AttrIndx\nvalues in a Long-descriptor format translation table entry for stage 1\ntranslations at EL1.\n\nAttr<n>, bits [0:63] - The memory attribute encoding for an AttrIndx[2:0] entry\n                       in a Long descriptor format translation table entry,\n                       where AttrIndx[2:0] gives the value of <n> in Attr<n>.\n                       Attr is encoded as follows: 'dd' is encoded as follows:\n                       'oooo' is encoded as follows: R = Outer Read-Allocate\n                       policy, W = Outer Write-Allocate policy. 'iiii' is\n                       encoded as follows: R = Inner Read-Allocate policy, W =\n                       Inner Write-Allocate policy. The R and W bits in 'oooo'\n                       and 'iiii' fields have the following meanings:"
      },
      "MAIR_EL2": {
        "long_name": "Memory Attribute Indirection Register (EL2)",
        "purpose": "Provides the memory attribute encodings corresponding to the possible AttrIndx\nvalues in a Long-descriptor format translation table entry for stage 1\ntranslations at EL2.\n\nAttr<n>, bits [0:63] - The memory attribute encoding for an AttrIndx[2:0] entry\n                       in a Long descriptor format translation table entry,\n                       where AttrIndx[2:0] gives the value of <n> in Attr<n>.\n                       Attr is encoded as follows: 'dd' is encoded as follows:\n                       'oooo' is encoded as follows: R = Outer Read-Allocate\n                       policy, W = Outer Write-Allocate policy. 'iiii' is\n                       encoded as follows: R = Inner Read-Allocate policy, W =\n                       Inner Write-Allocate policy. The R and W bits in 'oooo'\n                       and 'iiii' fields have the following meanings:"
      },
      "MAIR_EL3": {
        "long_name": "Memory Attribute Indirection Register (EL3)",
        "purpose": "Provides the memory attribute encodings corresponding to the possible AttrIndx\nvalues in a Long-descriptor format translation table entry for stage 1\ntranslations at EL3.\n\nAttr<n>, bits [0:63] - The memory attribute encoding for an AttrIndx[2:0] entry\n                       in a Long descriptor format translation table entry,\n                       where AttrIndx[2:0] gives the value of <n> in Attr<n>.\n                       Attr is encoded as follows: 'dd' is encoded as follows:\n                       'oooo' is encoded as follows: R = Outer Read-Allocate\n                       policy, W = Outer Write-Allocate policy. 'iiii' is\n                       encoded as follows: R = Inner Read-Allocate policy, W =\n                       Inner Write-Allocate policy. The R and W bits in 'oooo'\n                       and 'iiii' fields have the following meanings:"
      },
      "MDCCINT_EL1": {
        "long_name": "Monitor DCC Interrupt Enable Register",
        "purpose": "Enables interrupt requests to be signaled based on the DCC status flags.\n\nRX, bit [30] - DCC interrupt request enable control for DTRRX. Enables a common\n               COMMIRQ interrupt request to be signaled based on the DCC status\n               flags.\n                   0b0 No interrupt request generated by DTRRX.\n                   0b1 Interrupt request will be generated on RXfull == 1.\n               If legacy COMMRX and COMMTX signals are implemented, then these\n               are not affected by the value of this bit.\nTX, bit [29] - DCC interrupt request enable control for DTRTX. Enables a common\n               COMMIRQ interrupt request to be signaled based on the DCC status\n               flags.\n                   0b0 No interrupt request generated by DTRTX.\n                   0b1 Interrupt request will be generated on TXfull == 0.\n               If legacy COMMRX and COMMTX signals are implemented, then these\n               are not affected by the value of this bit."
      },
      "MDCCSR_EL0": {
        "long_name": "Monitor DCC Status Register",
        "purpose": "Read-only register containing control status flags for the DCC.\n\nRXfull, bit [30] - DTRRX full. Read-only view of the equivalent bit in the\n                   EDSCR.\nTXfull, bit [29] - DTRTX full. Read-only view of the equivalent bit in the\n                   EDSCR."
      },
      "MDCR_EL2": {
        "long_name": "Monitor Debug Configuration Register (EL2)",
        "purpose": "Provides EL2 configuration options for self-hosted debug and the Performance\nMonitors Extension.\n\nMTPME, bit [28]    - Multi-threaded PMU Enable.\nTDCC, bit [27]     - Trap DCC.\nHLP, bit [26]      - Hypervisor Long event counter enable.\nHCCD, bit [23]     - Hypervisor Cycle Counter Disable.\nTTRF, bit [19]     - Traps use of the Trace Filter Control registers at EL1 to\n                     EL2, as follows.\nHPMD, bit [17]     - Guest Performance Monitors Disable.\nTPMS, bit [14]     - Trap Performance Monitor Sampling.\nE2PB, bits [12:13] - EL2 Profiling Buffer.\nTDRA, bit [11]     - Trap Debug ROM Address register access.\nTDOSA, bit [10]    - Trap debug OS-related register access.\nTDOSA, bit [10]    - Trap debug OS-related register access.\nTDA, bit [9]       - Trap Debug Access.\nTDE, bit [8]       - Trap Debug exceptions.\nHPME, bit [7]      - [MDCR_EL2.HPMN..(N-1)] event counters enable.\nTPM, bit [6]       - Trap Performance Monitors accesses.\nTPMCR, bit [5]     - Trap PMCR_EL0 or PMCR accesses.\nHPMN, bits [0:4]   - Defines the number of event counters that are accessible\n                     from EL3, EL2, EL1, and from EL0 if permitted."
      },
      "MDCR_EL3": {
        "long_name": "Monitor Debug Configuration Register (EL3)",
        "purpose": "Provides EL3 configuration options for self-hosted debug and the Performance\nMonitors Extension.\n\nMTPME, bit [28]     - Multi-threaded PMU Enable.\nTDCC, bit [27]      - Trap DCC.\nSCCD, bit [23]      - Secure Cycle Counter Disable.\nEPMAD, bit [21]     - External Performance Monitors Non-secure Access Disable.\nEPMAD, bit [21]     - External Performance Monitors Access Disable.\nEDAD, bit [20]      - External Debug Non-secure Access Disable.\nEDAD, bit [20]      - External Debug Access Disable.\nEDAD, bit [20]      - External Debug Access disable.\nTTRF, bit [19]      - Trap Trace Filter controls.\nSTE, bit [18]       - Secure Trace enable.\nSPME, bit [17]      - Secure Performance Monitors enable.\nSPME, bit [17]      - Secure Performance Monitors enable.\nSDD, bit [16]       - AArch64 Secure Self-hosted invasive debug disable.\nSPD32, bits [14:15] - AArch32 Secure self-hosted privileged debug.\nNSPB, bits [12:13]  - Non-secure Profiling Buffer.\nTDOSA, bit [10]     - Trap debug OS-related register access.\nTDOSA, bit [10]     - Trap debug OS-related register access.\nTDA, bit [9]        - Trap Debug Access.\nTPM, bit [6]        - Trap Performance Monitor register accesses."
      },
      "MDRAR_EL1": {
        "long_name": "Monitor Debug ROM Address Register",
        "purpose": "Defines the base physical address of a 4KB-aligned memory-mapped debug\ncomponent, usually a ROM table that locates and describes the memory-mapped\ndebug components in the system. Armv8 deprecates any use of this register.\n\nROMADDR[51:48], bits [48:51] - Extension to ROMADDR[47:12]. See ROMADDR[47:12]\n                               for more details.\nROMADDR[47:12], bits [12:47] - Bits[47:12] of the ROM table physical address.\n                               When ARMv8.2-LPA is implemented, ROMADDR[51:48]\n                               forms the upper part of the address value.\n                               Otherwise, ROMADDR[51:48] is res0. If the\n                               physical address size in bits (PAsize) is less\n                               than 52, then the register bits corresponding to\n                               ROMADDR [51:PAsize] are res0. Bits [11:0] of the\n                               ROM table physical address are zero. Arm strongly\n                               recommends that bits ROMADDR[(PAsize-1):32] are\n                               zero in any system that supports AArch32 at the\n                               highest implemented Exception level. In an\n                               implementation that includes EL3, ROMADDR is an\n                               address in Non-secure memory. It is\n                               implementation defined whether the ROM table is\n                               also accessible in Secure memory.\nValid, bits [0:1]            - This field indicates whether the ROM Table\n                               address is valid. The permitted values of this\n                               field are:\n                                   0b00 ROM Table address is not valid. Software\n                               must ignore ROMADDR.\n                                   0b11 ROM Table address is valid.\n                               Other values are reserved."
      },
      "MDSCR_EL1": {
        "long_name": "Monitor Debug System Control Register",
        "purpose": "Main control register for the debug implementation.\n\nTFO, bit [31]        - Trace Filter override.\nRXfull, bit [30]     - Used for save/restore of EDSCR.RXfull.\nTXfull, bit [29]     - Used for save/restore of EDSCR.TXfull.\nRXO, bit [27]        - Used for save/restore of EDSCR.RXO.\nTXU, bit [26]        - Used for save/restore of EDSCR.TXU.\nINTdis, bits [22:23] - Used for save/restore of EDSCR.INTdis.\nTDA, bit [21]        - Used for save/restore of EDSCR.TDA.\nSC2, bit [19]        - Used for save/restore of EDSCR.SC2.\nMDE, bit [15]        - Monitor debug events.\nHDE, bit [14]        - Used for save/restore of EDSCR.HDE.\nKDE, bit [13]        - Local (kernel) debug enable.\nTDCC, bit [12]       - Traps EL0 accesses to the Debug Communication Channel\n                       (DCC) registers to EL1, or to EL2 when it is implemented\n                       and enabled for the current Security state and\n                       HCR_EL2.TGE is 1, from both Execution states, as follows.\nERR, bit [6]         - Used for save/restore of EDSCR.ERR.\nSS, bit [0]          - Software step control bit."
      },
      "MIDR_EL1": {
        "long_name": "Main ID Register",
        "purpose": "Provides identification information for the PE, including an implementer code\nfor the device and a device ID number.\n\nImplementer, bits [24:31]  - The Implementer code. This field must hold an\n                             implementer code that has been assigned by Arm.\n                             Assigned codes include the following: Arm can\n                             assign codes that are not published in this manual.\n                             All values not assigned by Arm are reserved and\n                             must not be used.\nVariant, bits [20:23]      - An implementation defined variant number.\n                             Typically, this field is used to distinguish\n                             between different product variants, or major\n                             revisions of a product.\nArchitecture, bits [16:19] - The permitted values of this field are:\nPartNum, bits [4:15]       - An implementation defined primary part number for\n                             the device. On processors implemented by Arm, if\n                             the top four bits of the primary part number are\n                             0x0 or 0x7, the variant and architecture are\n                             encoded differently.\nRevision, bits [0:3]       - An implementation defined revision number for the\n                             device."
      },
      "MPAM0_EL1": {
        "long_name": "MPAM0 Register (EL1)",
        "purpose": "Holds information to generate MPAM labels for memory requests when executing at\nEL0. When EL2 is present and enabled, the MPAM virtualization option is present,\nMPAMHCR_EL2.GSTAPP_PLK == 1 and HCR_EL2.TGE == 0, MPAM1_EL1 is used instead of\nMPAM0_EL1 to generate MPAM information to label memory requests.\n\nIf EL2 is present and enabled, and HCR_EL2.E2H == 0 or HCR_EL2.TGE == 0, the\nMPAM virtualization option is present and MPAMHCR_EL2.EL0_VPMEN == 1, then MPAM\nPARTIDs in MPAM0_EL1 are virtual and mapped into physical PARTIDs for the\ncurrent Security state.\n\nPMG_D, bits [40:47]    - Performance monitoring group property for PARTID_D.\nPMG_I, bits [32:39]    - Performance monitoring group property for PARTID_I.\nPARTID_D, bits [16:31] - Partition ID for data accesses, including load and\n                         store accesses, made from EL0.\nPARTID_I, bits [0:15]  - Partition ID for instruction accesses made from EL0."
      },
      "MPAM1_EL1": {
        "long_name": "MPAM1 Register (EL1)",
        "purpose": "Holds information to generate MPAM labels for memory requests when executing at\nEL1.\n\nWhen EL2 is present and enabled, the MPAM virtualization option is present,\nMPAMHCR_EL2.GSTAPP_PLK == 1 and HCR_EL2.TGE == 0, MPAM1_EL1 is used instead of\nMPAM0_EL1 to generate MPAM labels for memory requests when executing at EL0.\n\nMPAM1_EL1 is an alias for MPAM2_EL2 when executing at EL2 with HCR_EL2.E2H == 1.\n\nMPAM1_EL12 is an alias for MPAM1_EL1 when executing at EL2 or EL3 with\nHCR_EL2.E2H == 1.\n\nIf EL2 is is present and enabled, the MPAM virtualization option is present and\nMPAMHCR_EL2.EL1_VPMEN == 1, MPAM PARTIDs in MPAM1_EL1 are virtual and mapped\ninto physical PARTIDs for the current Security state. This mapping of MPAM1_EL1\nvirtual PARTIDs to physical PARTIDs when EL1_VPMEN is 1 also applies when\nMPAM1_EL1 is used at EL0 due to MPAMHCR_EL2.GSTAPP_PLK.\n\nMPAMEN, bit [63]       - MPAM Enable. MPAM is enabled when MPAMEN == 1. When\n                         disabled, all PARTIDs and PMGs are output as their\n                         default value in the corresponding ID space.\nFORCED_NS, bit [60]    - In the Secure state, FORCED_NS Secure state indicates\n                         the state of MPAM3_EL3.FORCE_NS.\nPMG_D, bits [40:47]    - Performance monitoring group property for PARTID_D.\nPMG_I, bits [32:39]    - Performance monitoring group property for PARTID_I.\nPARTID_D, bits [16:31] - Partition ID for data accesses, including load and\n                         store accesses, made from EL1.\nPARTID_I, bits [0:15]  - Partition ID for instruction accesses made from EL1."
      },
      "MPAM2_EL2": {
        "long_name": "MPAM2 Register (EL2)",
        "purpose": "Holds information to generate MPAM labels for memory requests when executing at\nEL2.\n\nMPAMEN, bit [63]       - MPAM Enable. MPAM is enabled when MPAMEN == 1. When\n                         disabled, all PARTIDs and PMGs are output as their\n                         default value in the corresponding ID space.\nTIDR, bit [58]         - TIDR traps accesses to MPAMIDR_EL1 from EL1 to EL2.\nTRAPMPAM0EL1, bit [49] - TRAPMPAM0EL1: Trap accesses from EL1 to the MPAM0_EL1\n                         register trap to EL2.\nTRAPMPAM1EL1, bit [48] - TRAPMPAM1EL1: Trap accesses from EL1 to the MPAM1_EL1\n                         register trap to EL2.\nPMG_D, bits [40:47]    - Performance monitoring group for data accesses.\nPMG_I, bits [32:39]    - Performance monitoring group for instruction accesses.\nPARTID_D, bits [16:31] - Partition ID for data accesses, including load and\n                         store accesses, made from EL2.\nPARTID_I, bits [0:15]  - Partition ID for instruction accesses made from EL2."
      },
      "MPAM3_EL3": {
        "long_name": "MPAM3 Register (EL3)",
        "purpose": "Holds information to generate MPAM labels for memory requests when executing at\nEL3.\n\nMPAMEN, bit [63]       - MPAM Enable. MPAM is enabled when MPAMEN == 1. When\n                         disabled, all PARTIDs and PMGs are output as their\n                         default value in the corresponding ID space.\nTRAPLOWER, bit [62]    - Trap direct accesses to any MPAM system registers that\n                         are not undefined from all ELn lower than EL3.\nSDEFLT, bit [61]       - SDEFLT overrides the PARTID with the default PARTID\n                         when executing in the Secure state.\nFORCE_NS, bit [60]     - FORCE_NS forces MPAM_NS to always be 1 in the Secure\n                         state.\nPMG_D, bits [40:47]    - Performance monitoring group for data accesses.\nPMG_I, bits [32:39]    - Performance monitoring group for instruction accesses.\nPARTID_D, bits [16:31] - Partition ID for data accesses, including load and\n                         store accesses, made from EL3.\nPARTID_I, bits [0:15]  - Partition ID for instruction accesses made from EL3."
      },
      "MPAMHCR_EL2": {
        "long_name": "MPAM Hypervisor Control Register (EL2)",
        "purpose": "Controls the PARTID virtualization features of MPAM. It controls the mapping of\nvirtual PARTIDs into physical PARTIDs in MPAM0_EL1 when EL0_VPMEN == 1 and in\nMPAM1_EL1 when EL1_VPMEN == 1.\n\nTRAP_MPAMIDR_EL1, bit [31] - Trap accesses from EL1 to MPAMIDR_EL1 to EL2.\nGSTAPP_PLK, bit [8]        - Make the PARTIDs at EL0 the same as the PARTIDs at\n                             EL1. When executing at EL0, EL2 is enabled,\n                             HCR_EL2.TGE == 0 and GSTAPP_PLK = 1, MPAM1_EL1 is\n                             used instead of MPAM0_EL1 to generate MPAM labels\n                             for memory requests.\nEL1_VPMEN, bit [1]         - Enable the virtual PARTID mapping of the PARTID\n                             fields in MPAM1_EL1 when executing at EL1. This bit\n                             also enables virtual PARTID mapping when MPAM1_EL1\n                             is used to generate MPAM labels for memory requests\n                             at EL0 due to GSTAPP_PLK == 1.\nEL0_VPMEN, bit [0]         - Enable the virtual PARTID mapping of the PARTID\n                             fields of MPAM0_EL1 unless HCR_EL2.E2H == 1 and\n                             HCR_EL2.TGE == 1. When HCR_EL2.E2H == 1 and\n                             HCR_EL2.TGE == 1, EL0_VPMEN is ignored and\n                             MPAM0_EL1 PARTID fields are not mapped. When\n                             MPAMHCR_EL2.GSTAPP_PLK == 1 and HCR_EL2.TGE == 0,\n                             MPAM1_EL1 is used as the source of PARTIDs and the\n                             virtual PARTID mapping of MPAM1_EL1 PARTIDs is\n                             controlled by MPAMHCR_EL2.EL1_VPMEN."
      },
      "MPAMIDR_EL1": {
        "long_name": "MPAM ID Register (EL1)",
        "purpose": "Indicates the presence and maximum PARTID and PMG values supported in the\nimplementation. It also indicates whether the implementation supports MPAM\nvirtualization.\n\nHAS_SDEFLT, bit [61]    - HAS_SDEFLT indicates support for MPAM3_EL3.SDEFLT bit.\nHAS_FORCE_NS, bit [60]  - HAS_FORCE_NS indicates support for MPAM3_EL3.FORCE_NS\n                          bit.\nHAS_TIDR, bit [58]      - HAS_TIDR indicates support for MPAM2_EL2.TIDR bit.\nPMG_MAX, bits [32:39]   - The largest value of PMG that the implementation can\n                          generate. The PMG_I and PMG_D fields of every\n                          MPAMn_ELx must implement at least enough bits to\n                          represent PMG_MAX.\nVPMR_MAX, bits [18:20]  - If HAS_HCR == 0, VPMR_MAX must be 0b000. Otherwise, it\n                          indicates the maximum register index n for the\n                          MPAMVPM<n>_EL2 registers.\nHAS_HCR, bit [17]       - HAS_HCR indicates that the PE implementation supports\n                          MPAM virtualization, including MPAMHCR_EL2,\n                          MPAMVPMV_EL2 and MPAMVPM<n>_EL2 with n in the range 0\n                          to VPMR_MAX. Must be 0 if EL2 is not implemented in\n                          either security state.\nPARTID_MAX, bits [0:15] - The largest value of PARTID that the implementation\n                          can generate. The PARTID_I and PARTID_D fields of\n                          every MPAMn_ELx must implement at least enough bits to\n                          represent PARTID_MAX."
      },
      "MPAMVPM0_EL2": {
        "long_name": "MPAM Virtual PARTID Mapping Register 0",
        "purpose": "MPAMVPM0_EL2 provides mappings from virtual PARTIDs 0 - 3 to physical PARTIDs.\n\nMPAMIDR_EL1.VPMR_MAX field gives the index of the highest implemented\nMPAMVPM<n>_EL2 register. VPMR_MAX can be as large as 7 (8 registers) or 32\nvirtual PARTIDs. If MPAMIDR_EL1.VPMR_MAX == 0, there is only a single\nMPAMVPM<n>_EL2 register, MPAMVPM0_EL2.\n\nVirtual PARTID mapping is enabled by MPAMHCR_EL2.EL1_VPMEN for PARTIDs in\nMPAM1_EL1 and by MPAMHCR_EL2.EL0_VPMEN for PARTIDs in MPAM0_EL1.\n\nA virtual-to-physical PARTID mapping entry, PhyPARTID<n>, is only valid when the\nMPAMVPMV_EL2.VPM_V bit in bit position n is set to 1.\n\nPhyPARTID3, bits [48:63] - Virtual PARTID Mapping Entry for virtual PARTID 3.\n                           PhyPARTID3 gives the mapping of virtual PARTID 3 to a\n                           physical PARTID.\nPhyPARTID2, bits [32:47] - Virtual PARTID Mapping Entry for virtual PARTID 2.\n                           PhyPARTID2 gives the mapping of virtual PARTID 2 to a\n                           physical PARTID.\nPhyPARTID1, bits [16:31] - Virtual PARTID Mapping Entry for virtual PARTID 1.\n                           PhyPARTID1 gives the mapping of virtual PARTID 1 to a\n                           physical PARTID.\nPhyPARTID0, bits [0:15]  - Virtual PARTID Mapping Entry for virtual PARTID 0.\n                           PhyPARTID0 gives the mapping of virtual PARTID 0 to a\n                           physical PARTID."
      },
      "MPAMVPM1_EL2": {
        "long_name": "MPAM Virtual PARTID Mapping Register 1",
        "purpose": "MPAMVPM1_EL2 provides mappings from virtual PARTIDs 4 - 7 to physical PARTIDs.\n\nMPAMIDR_EL1.VPMR_MAX field gives the index of the highest implemented\nMPAMVPM0_EL2 to MPAMVPM7_EL2 registers. VPMR_MAX can be as large as 7 (8\nregisters) or 32 virtual PARTIDs. If MPAMIDR_EL1.VPMR_MAX == 0, there is only a\nsingle MPAMVPM<n>_EL2 register, MPAMVPM0_EL2.\n\nVirtual PARTID mapping is enabled by MPAMHCR_EL2.EL1_VPMEN for PARTIDs in\nMPAM1_EL1 and by MPAMHCR_EL2.EL0_VPMEN for PARTIDs in MPAM0_EL1.\n\nA virtual-to-physical PARTID mapping entry, PhyPARTID<n>, is only valid when the\nMPAMVPMV_EL2.VPM_V bit in bit position n is set to 1.\n\nPhyPARTID7, bits [48:63] - Virtual PARTID Mapping Entry for virtual PARTID 7.\n                           PhyPARTID7 gives the mapping of virtual PARTID 7 to a\n                           physical PARTID.\nPhyPARTID6, bits [32:47] - Virtual PARTID Mapping Entry for virtual PARTID 6.\n                           PhyPARTID6 gives the mapping of virtual PARTID 6 to a\n                           physical PARTID.\nPhyPARTID5, bits [16:31] - Virtual PARTID Mapping Entry for virtual PARTID 5.\n                           PhyPARTID5 gives the mapping of virtual PARTID 5 to a\n                           physical PARTID.\nPhyPARTID4, bits [0:15]  - Virtual PARTID Mapping Entry for virtual PARTID 4.\n                           PhyPARTID4 gives the mapping of virtual PARTID 4 to a\n                           physical PARTID."
      },
      "MPAMVPM2_EL2": {
        "long_name": "MPAM Virtual PARTID Mapping Register 2",
        "purpose": "MPAMVPM2_EL2 provides mappings from virtual PARTIDs 8 - 11 to physical PARTIDs.\n\nMPAMIDR_EL1.VPMR_MAX field gives the index of the highest implemented\nMPAMVPM0_EL2 to MPAMVPM7_EL2 registers. VPMR_MAX can be as large as 7 (8\nregisters) or 32 virtual PARTIDs. If MPAMIDR_EL1.VPMR_MAX == 0, there is only a\nsingle MPAMVPM<n>_EL2 register, MPAMVPM0_EL2.\n\nVirtual PARTID mapping is enabled by MPAMHCR_EL2.EL1_VPMEN for PARTIDs in\nMPAM1_EL1 and by MPAMHCR_EL2.EL0_VPMEN for PARTIDs in MPAM0_EL1.\n\nA virtual-to-physical PARTID mapping entry, PhyPARTID<n>, is only valid when the\nMPAMVPMV_EL2.VPM_V bit in bit position n is set to 1.\n\nPhyPARTID11, bits [48:63] - Virtual PARTID Mapping Entry for virtual PARTID 11.\n                            PhyPARTID11 gives the mapping of virtual PARTID 11\n                            to a physical PARTID.\nPhyPARTID10, bits [32:47] - Virtual PARTID Mapping Entry for virtual PARTID 10.\n                            PhyPARTID10 gives the mapping of virtual PARTID 10\n                            to a physical PARTID.\nPhyPARTID9, bits [16:31]  - Virtual PARTID Mapping Entry for virtual PARTID 9.\n                            PhyPARTID9 gives the mapping of virtual PARTID 9 to\n                            a physical PARTID.\nPhyPARTID8, bits [0:15]   - Virtual PARTID Mapping Entry for virtual PARTID 8.\n                            PhyPARTID8 gives the mapping of virtual PARTID 8 to\n                            a physical PARTID."
      },
      "MPAMVPM3_EL2": {
        "long_name": "MPAM Virtual PARTID Mapping Register 3",
        "purpose": "MPAMVPM3_EL2 provides mappings from virtual PARTIDs 12 - 15 to physical PARTIDs.\n\nMPAMIDR_EL1.VPMR_MAX field gives the index of the highest implemented\nMPAMVPM<n>_EL2 registers. VPMR_MAX can be as large as 7 (8 registers) or 32\nvirtual PARTIDs. If MPAMIDR_EL1.VPMR_MAX == 0, there is only a single\nMPAMVPM<n>_EL2 register, MPAMVPM0_EL2.\n\nVirtual PARTID mapping is enabled by MPAMHCR_EL2.EL1_VPMEN for PARTIDs in\nMPAM1_EL1 and by MPAMHCR_EL2.EL0_VPMEN for PARTIDs in MPAM0_EL1.\n\nA virtual-to-physical PARTID mapping entry, PhyPARTID<n>, is only valid when the\nMPAMVPMV_EL2.VPM_V bit in bit position n is set to 1.\n\nPhyPARTID15, bits [48:63] - Virtual PARTID Mapping Entry for virtual PARTID 15.\n                            PhyPARTID15 gives the mapping of virtual PARTID 15\n                            to a physical PARTID.\nPhyPARTID14, bits [32:47] - Virtual PARTID Mapping Entry for virtual PARTID 14.\n                            PhyPARTID14 gives the mapping of virtual PARTID 14\n                            to a physical PARTID.\nPhyPARTID13, bits [16:31] - Virtual PARTID Mapping Entry for virtual PARTID 13.\n                            PhyPARTID13 gives the mapping of virtual PARTID 13\n                            to a physical PARTID.\nPhyPARTID12, bits [0:15]  - Virtual PARTID Mapping Entry for virtual PARTID 12.\n                            PhyPARTID12 gives the mapping of virtual PARTID 12\n                            to a physical PARTID."
      },
      "MPAMVPM4_EL2": {
        "long_name": "MPAM Virtual PARTID Mapping Register 4",
        "purpose": "MPAMVPM4_EL2 provides mappings from virtual PARTIDs 16 - 19 to physical PARTIDs.\n\nMPAMIDR_EL1.VPMR_MAX field gives the index of the highest implemented\nMPAMVPM<n>_EL2 registers. VPMR_MAX can be as large as 7 (8 registers) or 32\nvirtual PARTIDs. If MPAMIDR_EL1.VPMR_MAX == 0, there is only a single\nMPAMVPM<n>_EL2 register, MPAMVPM0_EL2.\n\nVirtual PARTID mapping is enabled by MPAMHCR_EL2.EL1_VPMEN for PARTIDs in\nMPAM1_EL1 and by MPAMHCR_EL2.EL0_VPMEN for PARTIDs in MPAM0_EL1.\n\nA virtual-to-physical PARTID mapping entry, PhyPARTID<n>, is only valid when the\nMPAMVPMV_EL2.VPM_V bit in bit position n is set to 1.\n\nPhyPARTID19, bits [48:63] - Virtual PARTID Mapping Entry for virtual PARTID 19.\n                            PhyPARTID19 gives the mapping of virtual PARTID 19\n                            to a physical PARTID.\nPhyPARTID18, bits [32:47] - Virtual PARTID Mapping Entry for virtual PARTID 18.\n                            PhyPARTID18 gives the mapping of virtual PARTID 18\n                            to a physical PARTID.\nPhyPARTID17, bits [16:31] - Virtual PARTID Mapping Entry for virtual PARTID 17.\n                            PhyPARTID17 gives the mapping of virtual PARTID 17\n                            to a physical PARTID.\nPhyPARTID16, bits [0:15]  - Virtual PARTID Mapping Entry for virtual PARTID 16.\n                            PhyPARTID16 gives the mapping of virtual PARTID 16\n                            to a physical PARTID."
      },
      "MPAMVPM5_EL2": {
        "long_name": "MPAM Virtual PARTID Mapping Register 5",
        "purpose": "MPAMVPM5_EL2 provides mappings from virtual PARTIDs 20 - 23 to physical PARTIDs.\n\nMPAMIDR_EL1.VPMR_MAX field gives the index of the highest implemented\nMPAMVPM<n>_EL2 registers. VPMR_MAX can be as large as 7 (8 registers) or 32\nvirtual PARTIDs. If MPAMIDR_EL1.VPMR_MAX == 0, there is only a single\nMPAMVPM<n>_EL2 register, MPAMVPM0_EL2.\n\nVirtual PARTID mapping is enabled by MPAMHCR_EL2.EL1_VPMEN for PARTIDs in\nMPAM1_EL1 and by MPAMHCR_EL2.EL0_VPMEN for PARTIDs in MPAM0_EL1.\n\nA virtual-to-physical PARTID mapping entry, PhyPARTID<n>, is only valid when the\nMPAMVPMV_EL2.VPM_V bit in bit position n is set to 1.\n\nPhyPARTID23, bits [48:63] - Virtual PARTID Mapping Entry for virtual PARTID 23.\n                            PhyPARTID23 gives the mapping of virtual PARTID 23\n                            to a physical PARTID.\nPhyPARTID22, bits [32:47] - Virtual PARTID Mapping Entry for virtual PARTID 22.\n                            PhyPARTID22 gives the mapping of virtual PARTID 22\n                            to a physical PARTID.\nPhyPARTID21, bits [16:31] - Virtual PARTID Mapping Entry for virtual PARTID 21.\n                            PhyPARTID21 gives the mapping of virtual PARTID 21\n                            to a physical PARTID.\nPhyPARTID20, bits [0:15]  - Virtual PARTID Mapping Entry for virtual PARTID 20.\n                            PhyPARTID20 gives the mapping of virtual PARTID 20\n                            to a physical PARTID."
      },
      "MPAMVPM6_EL2": {
        "long_name": "MPAM Virtual PARTID Mapping Register 6",
        "purpose": "MPAMVPM6_EL2 provides mappings from virtual PARTIDs 24 - 27 to physical PARTIDs.\n\nMPAMIDR_EL1.VPMR_MAX field gives the index of the highest implemented\nMPAMVPM<n>_EL2 registers. VPMR_MAX can be as large as 7 (8 registers) or 32\nvirtual PARTIDs. If MPAMIDR_EL1.VPMR_MAX == 0, there is only a single\nMPAMVPM<n>_EL2 register, MPAMVPM0_EL2.\n\nVirtual PARTID mapping is enabled by MPAMHCR_EL2.EL1_VPMEN for PARTIDs in\nMPAM1_EL1 and by MPAMHCR_EL2.EL0_VPMEN for PARTIDs in MPAM0_EL1.\n\nA virtual-to-physical PARTID mapping entry, PhyPARTID<n>, is only valid when the\nMPAMVPMV_EL2.VPM_V bit in bit position n is set to 1.\n\nPhyPARTID27, bits [48:63] - Virtual PARTID Mapping Entry for virtual PARTID 27.\n                            PhyPARTID27 gives the mapping of virtual PARTID 27\n                            to a physical PARTID.\nPhyPARTID26, bits [32:47] - Virtual PARTID Mapping Entry for virtual PARTID 26.\n                            PhyPARTID26 gives the mapping of virtual PARTID 26\n                            to a physical PARTID.\nPhyPARTID25, bits [16:31] - Virtual PARTID Mapping Entry for virtual PARTID 25.\n                            PhyPARTID25 gives the mapping of virtual PARTID 25\n                            to a physical PARTID.\nPhyPARTID24, bits [0:15]  - Virtual PARTID Mapping Entry for virtual PARTID 24.\n                            PhyPARTID24 gives the mapping of virtual PARTID 24\n                            to a physical PARTID."
      },
      "MPAMVPM7_EL2": {
        "long_name": "MPAM Virtual PARTID Mapping Register 7",
        "purpose": "MPAMVPM7_EL2 provides mappings from virtual PARTIDs 28 - 31 to physical PARTIDs.\n\nMPAMIDR_EL1.VPMR_MAX field gives the index of the highest implemented\nMPAMVPM<n>_EL2 registers. VPMR_MAX can be as large as 7 (8 registers) or 32\nvirtual PARTIDs. If MPAMIDR_EL1.VPMR_MAX == 0, there is only a single\nMPAMVPM<n>_EL2 register, MPAMVPM0_EL2.\n\nVirtual PARTID mapping is enabled by MPAMHCR_EL2.EL1_VPMEN for PARTIDs in\nMPAM1_EL1 and by MPAMHCR_EL2.EL0_VPMEN for MPAM0_EL1.\n\nA virtual-to-physical PARTID mapping entry, PhyPARTID<n>, is only valid when the\nMPAMVPMV_EL2.VPM_V bit in bit position n is set to 1.\n\nPhyPARTID31, bits [48:63] - Virtual PARTID Mapping Entry for virtual PARTID 31.\n                            PhyPARTID31 gives the mapping of virtual PARTID 31\n                            to a physical PARTID.\nPhyPARTID30, bits [32:47] - Virtual PARTID Mapping Entry for virtual PARTID 30.\n                            PhyPARTID30 gives the mapping of virtual PARTID 30\n                            to a physical PARTID.\nPhyPARTID29, bits [16:31] - Virtual PARTID Mapping Entry for virtual PARTID 29.\n                            PhyPARTID29 gives the mapping of virtual PARTID 29\n                            to a physical PARTID.\nPhyPARTID28, bits [0:15]  - Virtual PARTID Mapping Entry for virtual PARTID 28.\n                            PhyPARTID28 gives the mapping of virtual PARTID 28\n                            to a physical PARTID."
      },
      "MPAMVPMV_EL2": {
        "long_name": "MPAM Virtual Partition Mapping Valid Register",
        "purpose": "Valid bits for virtual PARTID mapping entries. Each bit m corresponds to virtual\nPARTID mapping entry m in the MPAMVPM<n>_EL2 registers where n = m >> 2.\n\nVPM_V<m>, bits [0:31] - Contains valid bit for virtual PARTID mapping entry\n                        corresponding to virtual PARTID<m>."
      },
      "MPIDR_EL1": {
        "long_name": "Multiprocessor Affinity Register",
        "purpose": "In a multiprocessor system, provides an additional PE identification mechanism\nfor scheduling purposes.\n\nAff3, bits [32:39] - Affinity level 3. See the description of Aff0 for more\n                     information. Aff3 is not supported in AArch32 state.\nU, bit [30]        - Indicates a Uniprocessor system, as distinct from PE 0 in a\n                     multiprocessor system.\nMT, bit [24]       - Indicates whether the lowest level of affinity consists of\n                     logical PEs that are implemented using a multithreading\n                     type approach. See the description of Aff0 for more\n                     information about affinity levels.\nAff2, bits [16:23] - Affinity level 2. See the description of Aff0 for more\n                     information.\nAff1, bits [8:15]  - Affinity level 1. See the description of Aff0 for more\n                     information.\nAff0, bits [0:7]   - Affinity level 0. This is the affinity level that is most\n                     significant for determining PE behavior. Higher affinity\n                     levels are increasingly less significant in determining PE\n                     behavior. The assigned value of the MPIDR.{Aff2, Aff1,\n                     Aff0} or MPIDR_EL1.{Aff3, Aff2, Aff1, Aff0} set of fields\n                     of each PE must be unique within the system as a whole."
      },
      "MVFR0_EL1": {
        "long_name": "AArch32 Media and VFP Feature Register 0",
        "purpose": "Describes the features provided by the AArch32 Advanced SIMD and Floating-point\nimplementation.\n\nMust be interpreted with MVFR1_EL1 and MVFR2_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nFPRound, bits [28:31]  - Floating-Point Rounding modes.\nFPShVec, bits [24:27]  - Short Vectors.\nFPSqrt, bits [20:23]   - Square Root.\nFPDivide, bits [16:19] - Indicates whether the floating-point implementation\n                         provides support for VFP divide operations.\nFPTrap, bits [12:15]   - Floating Point Exception Trapping.\nFPDP, bits [8:11]      - Double Precision.\nFPSP, bits [4:7]       - Single Precision.\nSIMDReg, bits [0:3]    - Advanced SIMD registers."
      },
      "MVFR1_EL1": {
        "long_name": "AArch32 Media and VFP Feature Register 1",
        "purpose": "Describes the features provided by the AArch32 Advanced SIMD and Floating-point\nimplementation.\n\nMust be interpreted with MVFR0_EL1 and MVFR2_EL1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD10.4.1.\n\nSIMDFMAC, bits [28:31] - Advanced SIMD Fused Multiply-Accumulate.\nFPHP, bits [24:27]     - Floating Point Half Precision.\nSIMDHP, bits [20:23]   - Advanced SIMD Half Precision.\nSIMDSP, bits [16:19]   - Advanced SIMD Single Precision.\nSIMDInt, bits [12:15]  - Advanced SIMD Integer.\nSIMDLS, bits [8:11]    - Advanced SIMD Load/Store.\nFPDNaN, bits [4:7]     - Default NaN mode.\nFPFtZ, bits [0:3]      - Flush to Zero mode."
      },
      "MVFR2_EL1": {
        "long_name": "AArch32 Media and VFP Feature Register 2",
        "purpose": "Describes the features provided by the AArch32 Advanced SIMD and Floating-point\nimplementation.\n\nMust be interpreted with MVFR0_EL1 and MVFR1_EL1.\n\nFor general information about the interpretation of the ID registers, see\n'Principles of the ID scheme for fields in ID registers' in the Arm\u00ae\nArchitecture Reference Manual, Armv8, for Armv8-A architecture profile, section\nD7.1.3.\n\nFPMisc, bits [4:7]   - Indicates whether the floating-point implementation\n                       provides support for miscellaneous VFP features.\nSIMDMisc, bits [0:3] - Indicates whether the Advanced SIMD implementation\n                       provides support for miscellaneous Advanced SIMD\n                       features."
      },
      "NZCV": {
        "long_name": "Condition Flags",
        "purpose": "Allows access to the condition flags.\n\nN, bit [31] - Negative condition flag. Set to 1 if the result of the last flag-\n              setting instruction was negative.\nZ, bit [30] - Zero condition flag. Set to 1 if the result of the last flag-\n              setting instruction was zero, and to 0 otherwise. A result of zero\n              often indicates an equal result from a comparison.\nC, bit [29] - Carry condition flag. Set to 1 if the last flag-setting\n              instruction resulted in a carry condition, for example an unsigned\n              overflow on an addition.\nV, bit [28] - Overflow condition flag. Set to 1 if the last flag-setting\n              instruction resulted in an overflow condition, for example a\n              signed overflow on an addition."
      },
      "OSDLR_EL1": {
        "long_name": "OS Double Lock Register",
        "purpose": "Used to control the OS Double Lock.\n\nDLK, bit [0] - OS Double Lock control bit.\n                   0b0 OS Double Lock unlocked.\n                   0b1 OS Double Lock locked, if DBGPRCR_EL1.CORENPDRQ (Core no\n               powerdown request) bit is set to 0 and the PE is in Non-debug\n               state."
      },
      "OSDTRRX_EL1": {
        "long_name": "OS Lock Data Transfer Register, Receive",
        "purpose": "Used for save/restore of DBGDTRRX_EL0. It is a component of the Debug\nCommunications Channel.\n\nbits [0:31] - Update DTRRX without side-effect. Writes to this register update\n              the value in DTRRX and do not change RXfull. Reads of this\n              register return the last value written to DTRRX and do not change\n              RXfull. For the full behavior of the Debug Communications Channel,\n              see 'The Debug Communication Channel and Instruction Transfer\n              Register' in the Arm\u00ae Architecture Reference Manual, Armv8, for\n              Armv8-A architecture profile, chapter H4."
      },
      "OSDTRTX_EL1": {
        "long_name": "OS Lock Data Transfer Register, Transmit",
        "purpose": "Used for save/restore of DBGDTRTX_EL0. It is a component of the Debug\nCommunications Channel.\n\nbits [0:31] - Return DTRTX without side-effect. Reads of this register return\n              the value in DTRTX and do not change TXfull. Writes of this\n              register update the value in DTRTX and do not change TXfull. For\n              the full behavior of the Debug Communications Channel, see 'The\n              Debug Communication Channel and Instruction Transfer Register' in\n              the Arm\u00ae Architecture Reference Manual, Armv8, for Armv8-A\n              architecture profile, chapter H4."
      },
      "OSECCR_EL1": {
        "long_name": "OS Lock Exception Catch Control Register",
        "purpose": "Provides a mechanism for an operating system to access the contents of EDECCR\nthat are otherwise invisible to software, so it can save/restore the contents of\nEDECCR over powerdown on behalf of the external debugger.\n\nEDECCR, bits [0:31] - Used for save/restore to EDECCR over powerdown. Reads or\n                      writes to this field are indirect accesses to EDECCR."
      },
      "OSLAR_EL1": {
        "long_name": "OS Lock Access Register",
        "purpose": "Used to lock or unlock the OS Lock.\n\nOSLK, bit [0] - On writes to OSLAR_EL1, bit[0] is copied to the OS Lock. Use\n                OSLSR_EL1.OSLK to check the current status of the lock."
      },
      "OSLSR_EL1": {
        "long_name": "OS Lock Status Register",
        "purpose": "Provides the status of the OS Lock.\n\nOSLM[1], bit [3] - This field is bit[1] of OSLM[1:0]. OS lock model implemented.\n                   Identifies the form of OS save and restore mechanism\n                   implemented.\n                       0b00 OS Lock not implemented.\n                       0b10 OS Lock implemented.\n                   All other values are reserved. In an Armv8 implementation the\n                   value 0b00 is not permitted. The OSLM field is split as\n                   follows:\n                     - OSLM[1] is OSLSR_EL1[3].\n                     - OSLM[0] is OSLSR_EL1[0].\nnTT, bit [2]     - Not 32-bit access. This bit is always RAZ. It indicates that\n                   a 32-bit access is needed to write the key to the OS Lock\n                   Access Register.\nOSLK, bit [1]    - OS Lock Status.\n                       0b0 OS Lock unlocked.\n                       0b1 OS Lock locked.\n                   The OS Lock is locked and unlocked by writing to the OS Lock\n                   Access Register.\nOSLM[0], bit [0] - This field is bit[0] of OSLM[1:0]. See OSLM[1] for the field\n                   description."
      },
      "PAN": {
        "long_name": "Privileged Access Never",
        "purpose": "Allows access to the Privileged Access Never bit.\n\nPAN, bit [22] - Privileged Access Never.\n                    0b0 Privileged reads and write are not disabled by this\n                mechanism.\n                    0b1 Disables privileged read and write accesses to addresses\n                accessible at EL0 for an enabled stage 1 translation regime that\n                defines the EL0 permissions.\n                The value of this bit is usually preserved on taking an\n                exception, except in the following situations:\n                  - When the target of the exception is EL1, and the value of\n                the SCTLR_EL1.SPAN bit is 0, this bit is set to 1.\n                  - When the target of the exception is EL2, HCR_EL2.{E2H, TGE}\n                is {1, 1}, and the value of the SCTLR_EL2.SPAN bit is 0, this\n                bit is set to 1."
      },
      "PAR_EL1": {
        "long_name": "Physical Address Register",
        "purpose": "Returns the output address (OA) from an Address translation instruction that\nexecuted successfully, or fault information if the instruction did not execute\nsuccessfully.\n\nATTR, bits [56:63]      - Memory attributes for the returned output address.\nPA[51:48], bits [48:51] - Extension to PA[47:12].\nPA[47:12], bits [12:47] - Output address.\nNS, bit [9]             - Non-secure.\nSH, bits [7:8]          - Shareability attribute, for the returned output\n                          address.\nF, bit [0]              - Indicates whether the instruction performed a\n                          successful address translation."
      },
      "PMBIDR_EL1": {
        "long_name": "Profiling Buffer ID Register",
        "purpose": "Provides information to software as to whether the buffer can be programmed at\nthe current Exception level.\n\nF, bit [5]        - Flag updates. Defines whether the address translation\n                    performed by the Profiling Buffer manages the Access Flag\n                    and dirty state.\nP, bit [4]        - Programming not allowed. The Profiling Buffer is owned by a\n                    higher Exception level or the other Security state.\nAlign, bits [0:3] - Defines the minimum alignment constraint for PMBPTR_EL1. If\n                    this field is non-zero, then the PE must pad every record up\n                    to a multiple of this size."
      },
      "PMBLIMITR_EL1": {
        "long_name": "Profiling Buffer Limit Address Register",
        "purpose": "Defines the upper limit for the profiling buffer, and enables the profiling\nbuffer\n\nLIMIT, bits [12:63] - Limit address. PMBLIMITR_EL1.LIMIT:Zeros(12) is the\n                      address of the first byte in memory after the last byte in\n                      the profiling buffer. If the smallest implemented\n                      translation granule is not 4KB, then bits[N-1:12] are\n                      res0, where N is the implementation defined value,\n                      Log_2(smallest implemented translation granule).\nFM, bits [1:2]      - Fill mode\n                          0b00 Stop collection and raise maintenance interrupt\n                      on buffer fill.\n                      All other values are reserved. If this field is programmed\n                      with a reserved value, the PE behaves as if this field has\n                      a defined value, other than for a direct read of the\n                      register. Software must not rely on the behavior of\n                      reserved values, as they might change in a future version\n                      of the architecture.\nE, bit [0]          - Profiling Buffer enable\n                          0b0 All output is discarded.\n                          0b1 Profiling buffer enabled."
      },
      "PMBPTR_EL1": {
        "long_name": "Profiling Buffer Write Pointer Register",
        "purpose": "Defines the current write pointer for the profiling buffer.\n\nPTR, bits [0:63] - Current write address. Defines the virtual address of the\n                   next entry to be written to the buffer. The architecture\n                   places restrictions on the values software can write to the\n                   pointer. For more information see 'Restrictions on the\n                   current write pointer' in the Arm\u00ae Architecture Reference\n                   Manual, Armv8, for Armv8-A architecture profile, section\n                   D6.3.5. As a result, an implementation might treat some of\n                   bits[M:0], where M is defined by PMBIDR_EL1.Align, as res0.\n                   On a management interrupt, PMBPTR_EL1 is frozen."
      },
      "PMBSR_EL1": {
        "long_name": "Profiling Buffer Status/syndrome Register",
        "purpose": "Provides syndrome information to software when the buffer is disabled because\nthe management interrupt has been raised.\n\nEC, bits [26:31] - Exception class Top-level description of the cause of the\n                   buffer management event\nDL, bit [19]     - Partial record lost. Following a buffer management event\n                   other than an asynchronous External abort, indicates whether\n                   the last record written to the Profiling Buffer is complete.\nEA, bit [18]     - External abort.\nS, bit [17]      - Service\nCOLL, bit [16]   - Collision detected.\nMSS, bits [0:15] - Management Event Specific Syndrome. Contains syndrome\n                   specific to the management event."
      },
      "PMCCFILTR_EL0": {
        "long_name": "Performance Monitors Cycle Count Filter Register",
        "purpose": "Determines the modes in which the Cycle Counter, PMCCNTR_EL0, increments.\n\nP, bit [31]   - Privileged filtering bit. Controls counting in EL1. If EL3 is\n                implemented, then counting in Non-secure EL1 is further\n                controlled by the PMCCFILTR_EL0.NSK bit.\nU, bit [30]   - User filtering bit. Controls counting in EL0. If EL3 is\n                implemented, then counting in Non-secure EL0 is further\n                controlled by the PMCCFILTR_EL0.NSU bit.\nNSK, bit [29] - Non-secure EL1 (kernel) modes filtering bit. Controls counting\n                in Non-secure EL1. If the value of this bit is equal to the\n                value of the PMCCFILTR_EL0.P bit, cycles in Non-secure EL1 are\n                counted. Otherwise, cycles in Non-secure EL1 are not counted.\nNSU, bit [28] - Non-secure EL0 (Unprivileged) filtering bit. Controls counting\n                in Non-secure EL0. If the value of this bit is equal to the\n                value of the PMCCFILTR_EL0.U bit, cycles in Non-secure EL0 are\n                counted. Otherwise, cycles in Non-secure EL0 are not counted.\nNSH, bit [27] - EL2 (Hypervisor) filtering bit. Controls counting in EL2. If\n                Secure EL2 is implemented, counting in Secure EL2 is further\n                controlled by the PMCCFILTR_EL0.SH bit.\nM, bit [26]   - Secure EL3 filtering bit. If the value of this bit is equal to\n                the value of the PMCCFILTR_EL0.P bit, cycles in Secure EL3 are\n                counted. Otherwise, cycles in Secure EL3 are not counted. Most\n                applications can ignore this field and set its value to 0. This\n                field is not visible in the AArch32 PMCCFILTR System register.\nSH, bit [24]  - Secure EL2 filtering. If the value of this bit is not equal to\n                the value of the PMCCFILTR_EL0.NSH bit, cycles in Secure EL2 are\n                counted. Otherwise, cycles in Secure EL2 are not counted. If\n                Secure EL2 is not implemented or is disabled, this field is\n                res0. This field is not visible in the AArch32 PMCCFILTR System\n                register."
      },
      "PMCCNTR_EL0": {
        "long_name": "Performance Monitors Cycle Count Register",
        "purpose": "Holds the value of the processor Cycle Counter, CCNT, that counts processor\nclock cycles. See 'Time as measured by the Performance Monitors cycle counter'\nin the Arm\u00ae Architecture Reference Manual, Armv8, for Armv8-A architecture\nprofile for more information.\n\nPMCCFILTR_EL0 determines the modes and states in which the PMCCNTR_EL0 can\nincrement.\n\nCCNT, bits [0:63] - Cycle count. Depending on the values of PMCR_EL0.{LC,D},\n                    this field increments in one of the following ways:\n                      - Every processor clock cycle.\n                      - Every 64th processor clock cycle. Writing 1 to\n                    PMCR_EL0.C sets this field to 0."
      },
      "PMCEID0_EL0": {
        "long_name": "Performance Monitors Common Event Identification register 0",
        "purpose": "Defines which common architectural events and common microarchitectural  events\nare implemented, or counted, using PMU events in the ranges 0x0000 to 0x001F and\n0x4000 to 0x401F.\n\nWhen the value of a bit in the register is 1 the corresponding common event is\nimplemented and counted.\n\nArm recommends that, if a common event is never counted, the value of the\ncorresponding register bit is 0.\n\nFor more information about the common events and the use of the PMCEID<n>_EL0\nregisters see The section describing 'Event numbers and common events' in\nchapter D5 'The Performance Monitors Extension' of the Arm Architecture\nReference Manual, for Armv8-A architecture profile.\n\nIDhi<n>, bits [32:63] - IDhi[n] corresponds to common event (0x4000 + n). For\n                        each bit:\n                            0b0 The common event is not implemented, or not\n                        counted.\n                            0b1 The common event is implemented.\nID<n>, bits [0:31]    - ID[n] corresponds to common event n. For each bit:\n                            0b0 The common event is not implemented, or not\n                        counted.\n                            0b1 The common event is implemented."
      },
      "PMCEID1_EL0": {
        "long_name": "Performance Monitors Common Event Identification register 1",
        "purpose": "Defines which common architectural events and common microarchitectural  events\nare implemented, or counted, using PMU events in the ranges 0x0020 to 0x003F and\n0x4020 to 0x403F.\n\nWhen the value of a bit in the register is 1 the corresponding common event is\nimplemented and counted.\n\nArm recommends that, if a common event is never counted, the value of the\ncorresponding register bit is 0.\n\nFor more information about the common events and the use of the PMCEID<n>_EL0\nregisters see The section describing 'Event numbers and common events' in\nchapter D5 'The Performance Monitors Extension' of the Arm Architecture\nReference Manual, for Armv8-A architecture profile.\n\nIDhi<n>, bits [32:63] - IDhi[n] corresponds to common event (0x4020 + n). For\n                        each bit:\n                            0b0 The common event is not implemented, or not\n                        counted.\n                            0b1 The common event is implemented.\nID<n>, bits [0:31]    - ID[n] corresponds to common event (0x0020 + n). For each\n                        bit:\n                            0b0 The common event is not implemented, or not\n                        counted.\n                            0b1 The common event is implemented."
      },
      "PMCNTENCLR_EL0": {
        "long_name": "Performance Monitors Count Enable Clear register",
        "purpose": "Disables the Cycle Count Register, PMCCNTR_EL0, and any implemented event\ncounters PMEVCNTR<n>. Reading this register shows which counters are enabled.\n\nC, bit [31]       - PMCCNTR_EL0 disable bit. Disables the cycle counter\n                    register. Possible values are:\n                        0b0 When read, means the cycle counter is disabled. When\n                    written, has no effect.\n                        0b1 When read, means the cycle counter is enabled. When\n                    written, disables the cycle counter.\nP<n>, bits [0:30] - Event counter disable bit for PMEVCNTR<n>_EL0. If N is less\n                    than 31, then bits [30:N] are RAZ/WI. When EL2 is\n                    implemented and enabled in the current Security state, in\n                    EL1 and EL0, N is the value in MDCR_EL2.HPMN. Otherwise, N\n                    is the value in PMCR_EL0.N.\n                        0b0 When read, means that PMEVCNTR<n>_EL0 is disabled.\n                    When written, has no effect.\n                        0b1 When read, means that PMEVCNTR<n>_EL0 is enabled.\n                    When written, disables PMEVCNTR<n>_EL0."
      },
      "PMCNTENSET_EL0": {
        "long_name": "Performance Monitors Count Enable Set register",
        "purpose": "Enables the Cycle Count Register, PMCCNTR_EL0, and any implemented event\ncounters PMEVCNTR<n>. Reading this register shows which counters are enabled.\n\nC, bit [31]       - PMCCNTR_EL0 enable bit. Enables the cycle counter register.\n                    Possible values are:\n                        0b0 When read, means the cycle counter is disabled. When\n                    written, has no effect.\n                        0b1 When read, means the cycle counter is enabled. When\n                    written, enables the cycle counter.\nP<n>, bits [0:30] - Event counter enable bit for PMEVCNTR<n>_EL0. If N is less\n                    than 31, then bits [30:N] are RAZ/WI. When EL2 is\n                    implemented and enabled in the current Security state, in\n                    EL1 and EL0, N is the value in MDCR_EL2.HPMN. Otherwise, N\n                    is the value in PMCR_EL0.N.\n                        0b0 When read, means that PMEVCNTR<n>_EL0 is disabled.\n                    When written, has no effect.\n                        0b1 When read, means that PMEVCNTR<n>_EL0 event counter\n                    is enabled. When written, enables PMEVCNTR<n>_EL0."
      },
      "PMCR_EL0": {
        "long_name": "Performance Monitors Control Register",
        "purpose": "Provides details of the Performance Monitors implementation, including the\nnumber of counters implemented, and configures and controls the counters.\n\nIMP, bits [24:31]    - Implementer code.\nIDCODE, bits [16:23] - Identification code.\nN, bits [11:15]      - Indicates the number of event counters implemented.\nLP, bit [7]          - Long event counter enable.\nLC, bit [6]          - Long cycle counter enable.\nDP, bit [5]          - Disable cycle counter when event counting is prohibited.\nX, bit [4]           - Enable export of events in an implementation defined PMU\n                       event export bus.\nD, bit [3]           - Clock divider.\nC, bit [2]           - Cycle counter reset.\nP, bit [1]           - Event counter reset.\nE, bit [0]           - Enable."
      },
      "PMEVCNTR<n>_EL0": {
        "long_name": "Performance Monitors Event Count Registers",
        "purpose": "Holds event counter n, which counts events, where n is 0 to 30.\n\nbits [0:63] - Event counter n. Value of event counter n, where n is the number\n              of this register and is a number from 0 to 30."
      },
      "PMEVTYPER<n>_EL0": {
        "long_name": "Performance Monitors Event Type Registers",
        "purpose": "Configures event counter n, where n is 0 to 30.\n\nP, bit [31]                   - Privileged filtering bit.\nU, bit [30]                   - User filtering bit.\nNSK, bit [29]                 - Non-secure EL1 (kernel) modes filtering bit.\nNSU, bit [28]                 - Non-secure EL0 (Unprivileged) filtering bit.\nNSH, bit [27]                 - EL2 (Hypervisor) filtering bit.\nM, bit [26]                   - Secure EL3 filtering bit.\nMT, bit [25]                  - Multithreading.\nSH, bit [24]                  - Secure EL2 filtering.\nevtCount[15:10], bits [10:15] - Extension to evtCount[9:0].\nevtCount[9:0], bits [0:9]     - Event to count."
      },
      "PMINTENCLR_EL1": {
        "long_name": "Performance Monitors Interrupt Enable Clear register",
        "purpose": "Disables the generation of interrupt requests on overflows from the Cycle Count\nRegister, PMCCNTR_EL0, and the event counters PMEVCNTR<n>_EL0. Reading the\nregister shows which overflow interrupt requests are enabled.\n\nC, bit [31]       - PMCCNTR_EL0 overflow interrupt request disable bit. Possible\n                    values are:\n                        0b0 When read, means the cycle counter overflow\n                    interrupt request is disabled. When written, has no effect.\n                        0b1 When read, means the cycle counter overflow\n                    interrupt request is enabled. When written, disables the\n                    cycle count overflow interrupt request.\nP<n>, bits [0:30] - Event counter overflow interrupt request disable bit for\n                    PMEVCNTR<n>_EL0. If N is less than 31, then bits [30:N] are\n                    RAZ/WI. When EL2 is implemented and enabled in the current\n                    Security state, in EL1, N is the value in MDCR_EL2.HPMN.\n                    Otherwise, N is the value in PMCR_EL0.N.\n                        0b0 When read, means that the PMEVCNTR<n>_EL0 event\n                    counter interrupt request is disabled. When written, has no\n                    effect.\n                        0b1 When read, means that the PMEVCNTR<n>_EL0 event\n                    counter interrupt request is enabled. When written, disables\n                    the PMEVCNTR<n>_EL0 interrupt request."
      },
      "PMINTENSET_EL1": {
        "long_name": "Performance Monitors Interrupt Enable Set register",
        "purpose": "Enables the generation of interrupt requests on overflows from the Cycle Count\nRegister, PMCCNTR_EL0, and the event counters PMEVCNTR<n>_EL0. Reading the\nregister shows which overflow interrupt requests are enabled.\n\nC, bit [31]       - PMCCNTR_EL0 overflow interrupt request enable bit. Possible\n                    values are:\n                        0b0 When read, means the cycle counter overflow\n                    interrupt request is disabled. When written, has no effect.\n                        0b1 When read, means the cycle counter overflow\n                    interrupt request is enabled. When written, enables the\n                    cycle count overflow interrupt request.\nP<n>, bits [0:30] - Event counter overflow interrupt request enable bit for\n                    PMEVCNTR<n>_EL0. If N is less than 31, then bits [30:N] are\n                    RAZ/WI. When EL2 is implemented and enabled in the current\n                    Security state, in EL1, N is the value in MDCR_EL2.HPMN.\n                    Otherwise, N is the value in PMCR_EL0.N.\n                        0b0 When read, means that the PMEVCNTR<n>_EL0 event\n                    counter interrupt request is disabled. When written, has no\n                    effect.\n                        0b1 When read, means that the PMEVCNTR<n>_EL0 event\n                    counter interrupt request is enabled. When written, enables\n                    the PMEVCNTR<n>_EL0 interrupt request."
      },
      "PMMIR_EL1": {
        "long_name": "Performance Monitors Machine Identification Register",
        "purpose": "Describes Performance Monitors parameters specific to the implementation to\nsoftware.\n\nSLOTS, bits [0:7] - Operation width. The largest value by which the STALL_SLOT\n                    event might increment by in a single cycle. If the\n                    STALL_SLOT event is not implemented, this field might read\n                    as zero."
      },
      "PMOVSCLR_EL0": {
        "long_name": "Performance Monitors Overflow Flag Status Clear Register",
        "purpose": "Contains the state of the overflow bit for the Cycle Count Register,\nPMCCNTR_EL0, and each of the implemented event counters PMEVCNTR<n>. Writing to\nthis register clears these bits.\n\nC, bit [31]       - Cycle counter overflow clear bit.\n                        0b0 When read, means the cycle counter has not\n                    overflowed since this bit was last cleared. When written,\n                    has no effect.\n                        0b1 When read, means the cycle counter has overflowed\n                    since this bit was last cleared. When written, clears the\n                    cycle counter overflow bit to 0.\n                    PMCR_EL0.LC controls whether an overflow is detected from\n                    unsigned overflow of PMCCNTR_EL0[31:0] or unsigned overflow\n                    of PMCCNTR_EL0[63:0].\nP<n>, bits [0:30] - Event counter overflow clear bit for PMEVCNTR<n>_EL0. If N\n                    is less than 31, then bits [30:N] are RAZ/WI. When EL2 is\n                    implemented and enabled in the current Security state, in\n                    EL1 and EL0, N is the value in MDCR_EL2.HPMN. Otherwise, N\n                    is the value in PMCR_EL0.N.\n                        0b0 When read, means that PMEVCNTR<n>_EL0 has not\n                    overflowed since this bit was last cleared. When written,\n                    has no effect.\n                        0b1 When read, means that PMEVCNTR<n>_EL0 has overflowed\n                    since this bit was last cleared. When written, clears the\n                    PMEVCNTR<n>_EL0 overflow bit to 0.\n                    If ARMv8.5-PMU is implemented, MDCR_EL2.HLP and PMCR_EL0.LP\n                    control whether an overflow is detected from unsigned\n                    overflow of PMEVCNTR<n>_EL0[31:0] or unsigned overflow of\n                    PMEVCNTR<n>_EL0[63:0]."
      },
      "PMOVSSET_EL0": {
        "long_name": "Performance Monitors Overflow Flag Status Set register",
        "purpose": "Sets the state of the overflow bit for the Cycle Count Register, PMCCNTR_EL0,\nand each of the implemented event counters PMEVCNTR<n>.\n\nC, bit [31]       - Cycle counter overflow set bit.\n                        0b0 When read, means the cycle counter has not\n                    overflowed since this bit was last cleared. When written,\n                    has no effect.\n                        0b1 When read, means the cycle counter has overflowed\n                    since this bit was last cleared. When written, sets the\n                    cycle counter overflow bit to 1.\n                    PMCR_EL0.LC controls whether an overflow is detected from\n                    unsigned overflow of PMCCNTR_EL0[31:0] or unsigned overflow\n                    of PMCCNTR_EL0[63:0].\nP<n>, bits [0:30] - Event counter overflow set bit for PMEVCNTR<n>_EL0. If N is\n                    less than 31, then bits [30:N] are RAZ/WI. When EL2 is\n                    implemented and enabled in the current Security state, in\n                    EL1 and EL0, N is the value in MDCR_EL2.HPMN. Otherwise, N\n                    is the value in PMCR_EL0.N.\n                        0b0 When read, means that PMEVCNTR<n>_EL0 has not\n                    overflowed since this bit was last cleared. When written,\n                    has no effect.\n                        0b1 When read, means that PMEVCNTR<n>_EL0 has overflowed\n                    since this bit was last cleared. When written, sets the\n                    PMEVCNTR<n>_EL0 overflow bit to 1.\n                    If ARMv8.5-PMU is implemented, MDCR_EL2.HLP and PMCR_EL0.LP\n                    control whether an overflow is detected from unsigned\n                    overflow of PMEVCNTR<n>_EL0[31:0] or unsigned overflow of\n                    PMEVCNTR<n>_EL0[63:0]."
      },
      "PMSCR_EL1": {
        "long_name": "Statistical Profiling Control Register (EL1)",
        "purpose": "Provides EL1 controls for Statistical Profiling\n\nPCT, bits [6:7] - Physical Timestamp. If timestamp sampling is enabled and the\n                  Profiling Buffer is owned by EL1, requests which timestamp\n                  counter value is collected. If ARMv8.6-ECV is implemented,\n                  this is a two bit field as shown. Otherwise, bit[7] is res0.\n                      0b00 Virtual counter, CNTVCT_EL0, is collected.\n                      0b01 Physical counter, CNTPCT_EL0, is collected.\n                      0b11 Physical counter, CNTPCT_EL0, minus CNTPOFF_EL2 is\n                  collected.\nPCT, bits [6:7] - Physical Timestamp. Reserved. This field reads as 0b01 and\n                  ignores writes. Software should treat this field as UNK/SBZP.\nTS, bit [5]     - Timestamp enable.\n                      0b0 Timestamp sampling disabled.\n                      0b1 Timestamp sampling enabled.\nPA, bit [4]     - Physical Address sample enable.\n                      0b0 Physical addresses are not collected.\n                      0b1 Physical addresses are collected.\nCX, bit [3]     - CONTEXTIDR_EL1 sample enable.\n                      0b0 CONTEXTIDR_EL1 is not collected.\n                      0b1 CONTEXTIDR_EL1 is collected.\nE1SPE, bit [1]  - EL1 Statistical Profiling Enable.\n                      0b0 Sampling disabled at EL1.\n                      0b1 Sampling enabled at EL1.\nE0SPE, bit [0]  - EL0 Statistical Profiling Enable. Controls sampling at EL0\n                  when HCR_EL2.TGE == 0 or if EL2 is disabled or not\n                  implemented.\n                      0b0 Sampling disabled at EL0.\n                      0b1 Sampling enabled at EL0."
      },
      "PMSCR_EL2": {
        "long_name": "Statistical Profiling Control Register (EL2)",
        "purpose": "Provides EL2 controls for Statistical Profiling\n\nPCT, bits [6:7] - Physical Timestamp. If timestamp sampling is enabled,\n                  determines which counter is collected. The behavior depends on\n                  the Profiling Buffer owning Exception level. If ARMv8.6-ECV is\n                  implemented, this is a two bit field as shown. Otherwise,\n                  bit[7] is res0.\nTS, bit [5]     - Timestamp Enable.\nPA, bit [4]     - Physical Address Sample Enable.\nCX, bit [3]     - CONTEXTIDR_EL2 Sample Enable.\nE2SPE, bit [1]  - EL2 Statistical Profiling Enable.\nE0HSPE, bit [0] - EL0 Statistical Profiling Enable."
      },
      "PMSELR_EL0": {
        "long_name": "Performance Monitors Event Counter Selection Register",
        "purpose": "Selects the current event counter PMEVCNTR<n>_EL0 or the cycle counter, CCNT.\n\nPMSELR_EL0 is used in conjunction with PMXEVTYPER_EL0 to determine the event\nthat increments a selected event counter, and the modes and states in which the\nselected counter increments.\n\nIt is also used in conjunction with PMXEVCNTR_EL0, to determine the value of a\nselected event counter.\n\nSEL, bits [0:4] - Selects event counter, PMEVCNTR<n>_EL0, where n is the value\n                  held in this field. This value identifies which event counter\n                  is accessed when a subsequent access to PMXEVTYPER_EL0 or\n                  PMXEVCNTR_EL0 occurs. This field can take any value from 0\n                  (0b00000) to (PMCR.N)-1, or 31 (0b11111). When PMSELR_EL0.SEL\n                  is 0b11111, it selects the cycle counter and:\n                    - A read of the PMXEVTYPER_EL0 returns the value of\n                  PMCCFILTR_EL0.\n                    - A write of the PMXEVTYPER_EL0 writes to PMCCFILTR_EL0.\n                    - A read or write of PMXEVCNTR_EL0 has constrained\n                  unpredictable effects. See PMXEVCNTR_EL0 for more details. For\n                  details of the results of accesses to the event counters, see\n                  PMXEVTYPER_EL0 and PMXEVCNTR_EL0. For information about the\n                  number of counters accessible at each Exception level, see\n                  MDCR_EL2.HPMN."
      },
      "PMSEVFR_EL1": {
        "long_name": "Sampling Event Filter Register",
        "purpose": "Controls sample filtering by events. The overall filter is the logical AND of\nthese filters. For example, if E[3] and E[5] are both set to 1, only samples\nthat have both event 3 (Level 1 unified or data cache refill) and event 5 set\n(TLB walk) are recorded\n\nE[<z>], bits [48:63] - E[<z>] is the event filter for event <z>. If event <z> is\n                       not implemented, or filtering on event <z> is not\n                       supported, the corresponding bit is RAZ/WI.\nE[<y>], bits [24:31] - E[<y>] is the event filter for event <y>. If event <y> is\n                       not implemented, or filtering on event <y> is not\n                       supported, the corresponding bit is RAZ/WI.\nE[18], bit [18]      - Empty predicate.\nE[17], bit [17]      - Partial predicate.\nE[<x>], bits [12:15] - E[<x>] is the event filter for event <x>. If event <x> is\n                       not implemented, or filtering on event <x> is not\n                       supported, the corresponding bit is RAZ/WI.\nE[11], bit [11]      - Alignment.\nE[7], bit [7]        - Mispredicted.\nE[5], bit [5]        - TLB walk.\nE[3], bit [3]        - Level 1 data or unified cache refill.\nE[1], bit [1]        - Architecturally retired."
      },
      "PMSFCR_EL1": {
        "long_name": "Sampling Filter Control Register",
        "purpose": "Controls sample filtering. The filter is the logical AND of the FL, FT and FE\nbits. For example, if FE == 1 and FT == 1 only samples including the selected\noperation types and the selected events will be recorded\n\nST, bit [18] - Store filter enable\n                   0b0 Do not record store operations\n                   0b1 Record all store operations, including vector stores and\n               all atomic operations\nLD, bit [17] - Load filter enable\n                   0b0 Do not record load operations\n                   0b1 Record all load operations, including vector loads and\n               atomic operations that return data\nB, bit [16]  - Branch filter enable\n                   0b0 Do not record branch and exception return operations\n                   0b1 Record all branch and exception return operations\nFL, bit [2]  - Filter by latency\n                   0b0 Latency filtering disabled\n                   0b1 Latency filtering enabled. Samples with a total latency\n               less than PMSLATFR_EL1.MINLAT will not be recorded\nFT, bit [1]  - Filter by operation type. The filter is the logical OR of the ST,\n               LD and B bits. For example, if LD and ST are both set, both load\n               and store operations are recorded\n                   0b0 Type filtering disabled\n                   0b1 Type filtering enabled. Samples not one of the selected\n               operation types will not be recorded\nFE, bit [0]  - Filter by event\n                   0b0 Event filtering disabled\n                   0b1 Event filtering enabled. Samples not including the events\n               selected by PMSEVFR_EL1 will not be recorded"
      },
      "PMSICR_EL1": {
        "long_name": "Sampling Interval Counter Register",
        "purpose": "Software must write zero to PMSICR_EL1 before enabling sample profiling for a\nsampling session. Software must then treat PMSICR_EL1 as an opaque, 64-bit,\nread/write register used for context switches only.\n\nECOUNT, bits [56:63] - Secondary sample interval counter.\nCOUNT, bits [0:31]   - Primary sample interval counter Provides the primary\n                       counter used for sampling."
      },
      "PMSIDR_EL1": {
        "long_name": "Sampling Profiling ID Register",
        "purpose": "Describes the Statistical Profiling implementation to software\n\nCountSize, bits [16:19] - Defines the size of the counters\nMaxSize, bits [12:15]   - Defines the largest size for a single record, rounded\n                          up to a power-of-two. If this is the same as the\n                          minimum alignment (PMBIDR_EL1.Align), then each record\n                          is exactly this size\nInterval, bits [8:11]   - Recommended minimum sampling interval. This provides\n                          guidance from the implementer to the smallest minimum\n                          sampling interval, N.\nERnd, bit [5]           - Defines how the random number generator is used in\n                          determining the interval between samples, when enabled\n                          by PMSIRR_EL1.RND.\nLDS, bit [4]            - Data source indicator for sampled load instructions\nArchInst, bit [3]       - Architectural instruction profiling\nFL, bit [2]             - Filtering by latency. This bit is RAO.\nFT, bit [1]             - Filtering by operation type. This bit is RAO.\nFE, bit [0]             - Filtering by events. This bit is RAO."
      },
      "PMSIRR_EL1": {
        "long_name": "Sampling Interval Reload Register",
        "purpose": "Defines the interval between samples\n\nINTERVAL, bits [8:31] - Bits [31:8] of the PMSICR_EL1 interval counter reload\n                        value. Software must set this to a non-zero value. If\n                        software sets this to zero, an unknown sampling interval\n                        is used. Software should set this to a value greater\n                        than the minimum indicated by PMSIDR_EL1.Interval\nRND, bit [0]          - Controls randomization of the sampling interval\n                            0b0 Disable randomization of sampling interval\n                            0b1 Add (pseudo-)random jitter to sampling interval\n                        The random number generator is not architected."
      },
      "PMSLATFR_EL1": {
        "long_name": "Sampling Latency Filter Register",
        "purpose": "Controls sample filtering by latency\n\nMINLAT, bits [0:11] - Minimum latency. When PMSFCR_EL1.FL == 1, defines the\n                      minimum total latency for filtered operations. Samples\n                      with a total latency less than MINLAT will not be recorded\n                      This field is ignored by the PE when PMSFCR_EL1.FL == 0."
      },
      "PMSWINC_EL0": {
        "long_name": "Performance Monitors Software Increment register",
        "purpose": "Increments a counter that is configured to count the Software increment event,\nevent 0x00. For more information, see  'SW_INCR' in the Arm\u00ae Architecture\nReference Manual, Armv8, for Armv8-A architecture profile, section D5.\n\nP<n>, bits [0:30] - Event counter software increment bit for PMEVCNTR<n>_EL0. If\n                    N is less than 31, then bits [30:N] are WI. When EL2 is\n                    implemented and enabled in the current Security state, in\n                    EL1 and EL0, N is the value in MDCR_EL2.HPMN. Otherwise, N\n                    is the value in PMCR_EL0.N.\n                        0b0 No action. The write to this bit is ignored.\n                        0b1 If PMEVCNTR<n>_EL0 is enabled and configured to\n                    count the software increment event, increments\n                    PMEVCNTR<n>_EL0 by 1. If PMEVCNTR<n>_EL0 is disabled, or not\n                    configured to count the software increment event, the write\n                    to this bit is ignored."
      },
      "PMUSERENR_EL0": {
        "long_name": "Performance Monitors User Enable Register",
        "purpose": "Enables or disables EL0 access to the Performance Monitors.\n\nER, bit [3] - Event counter Read.\nCR, bit [2] - Cycle counter Read.\nSW, bit [1] - Traps Software Increment writes to EL1, or to EL2 when it is\n              implemented and enabled for the current Security state and\n              HCR_EL2.TGE is 1.\nEN, bit [0] - Traps EL0 accesses to the Performance Monitor registers to EL1, or\n              to EL2 when it is implemented and enabled for the current Security\n              state and HCR_EL2.TGE is 1, from both Execution states as follows."
      },
      "PMXEVCNTR_EL0": {
        "long_name": "Performance Monitors Selected Event Count Register",
        "purpose": "Reads or writes the value of the selected event counter, PMEVCNTR<n>_EL0.\nPMSELR_EL0.SEL determines which event counter is selected.\n\nPMEVCNTR<n>, bits [0:63] - Value of the selected event counter, PMEVCNTR<n>_EL0,\n                           where n is the value stored in PMSELR_EL0.SEL."
      },
      "PMXEVTYPER_EL0": {
        "long_name": "Performance Monitors Selected Event Type Register",
        "purpose": "When PMSELR_EL0.SEL selects an event counter, this accesses a PMEVTYPER<n>_EL0\nregister. When PMSELR_EL0.SEL selects the cycle counter, this accesses\nPMCCFILTR_EL0.\n\nEvent type register or PMCCFILTR_EL0, bits [0:31] - When PMSELR_EL0.SEL == 31,\n                                                    this register accesses\n                                                    PMCCFILTR_EL0. Otherwise,\n                                                    this register accesses\n                                                    PMEVTYPER<n>_EL0 where n is\n                                                    the value in PMSELR_EL0.SEL."
      },
      "REVIDR_EL1": {
        "long_name": "Revision ID Register",
        "purpose": "Provides implementation-specific minor revision information."
      },
      "RGSR_EL1": {
        "long_name": "Random Allocation Tag Seed Register.",
        "purpose": "Random Allocation Tag Seed Register.\n\nSEED, bits [8:23] - Seed register used for generating values returned by\n                    RandomAllocationTag().\nTAG, bits [0:3]   - Tag generated by the most recent IRG instruction."
      },
      "RMR_EL1": {
        "long_name": "Reset Management Register (EL1)",
        "purpose": "If EL1 is the highest implemented Exception level and this register is\nimplemented:\n\n  - A write to the register at EL1 can request a Warm reset.\n  - If EL1 can use AArch32 and AArch64, this register specifies the Execution\nstate that the PE boots into on a Warm reset.\n\nRR, bit [1]   - Reset Request. Setting this bit to 1 requests a Warm reset.\nAA64, bit [0] - When EL1 can use AArch32, determines which Execution state the\n                PE boots into after a Warm reset:\n                    0b0 AArch32.\n                    0b1 AArch64.\n                On coming out of the Warm reset, execution starts at the\n                implementation defined reset vector address of the specified\n                Execution state. If EL1 cannot use AArch32 this bit is RAO/WI."
      },
      "RMR_EL2": {
        "long_name": "Reset Management Register (EL2)",
        "purpose": "If EL2 is the highest implemented Exception level and this register is\nimplemented:\n\n  - A write to the register at EL2 can request a Warm reset.\n  - If EL2 can use AArch32 and AArch64, this register specifies the Execution\nstate that the PE boots into on a Warm reset.\n\nRR, bit [1]   - Reset Request. Setting this bit to 1 requests a Warm reset.\nAA64, bit [0] - When EL2 can use AArch32, determines which Execution state the\n                PE boots into after a Warm reset:\n                    0b0 AArch32.\n                    0b1 AArch64.\n                On coming out of the Warm reset, execution starts at the\n                implementation defined reset vector address of the specified\n                Execution state. If EL2 cannot use AArch32 this bit is RAO/WI."
      },
      "RMR_EL3": {
        "long_name": "Reset Management Register (EL3)",
        "purpose": "If EL3 is the implemented and this register is implemented:\n\n  - A write to the register at EL3 can request a Warm reset.\n  - If EL3 can use AArch32 and AArch64, this register specifies the Execution\nstate that the PE boots into on a Warm reset.\n\nRR, bit [1]   - Reset Request. Setting this bit to 1 requests a Warm reset.\nAA64, bit [0] - When EL3 can use AArch32, determines which Execution state the\n                PE boots into after a Warm reset:\n                    0b0 AArch32.\n                    0b1 AArch64.\n                On coming out of the Warm reset, execution starts at the\n                implementation defined reset vector address of the specified\n                Execution state. If EL3 cannot use AArch32 this bit is RAO/WI."
      },
      "RNDR": {
        "long_name": "Random Number",
        "purpose": "Random Number. Returns a 64-bit random number which is reseeded from the True\nRandom Number source at an implementation defined rate.\n\nIf the hardware returns a genuine random number, PSTATE.NZCV is set to 0b0000.\n\nIf the instruction cannot return a genuine random number in a reasonable period\nof time, PSTATE.NZCV is set to 0b0100 and the data value returned in unknown.\n\nRNDR is a read-only register.\n\nRNDR, bits [0:63] - Random Number. Returns a 64-bit Random Number which is\n                    reseeded from the True Random Number source at an\n                    implementation defined rate."
      },
      "RNDRRS": {
        "long_name": "Reseeded Random Number",
        "purpose": "Reseeded Random Number. Returns a 64-bit random number which is reseeded from\nthe True Random Number source at an implementation defined rate.\n\nIf the hardware returns a genuine random number, PSTATE.NZCV is set to 0b0000.\n\nIf the instruction cannot return a genuine random number in a reasonable period\nof time, PSTATE.NZCV is set to 0b0100 and the data value returned in unknown.\n\nRNDRRS is a read-only register.\n\nRNDRRS, bits [0:63] - Reseeded Random Number. Returns a 64-bit Random Number\n                      which is reseeded from the True Random Number source\n                      immediately before this read."
      },
      "RVBAR_EL1": {
        "long_name": "Reset Vector Base Address Register (if EL2 and EL3 not implemented)",
        "purpose": "If EL1 is the highest Exception level implemented, contains the implementation\ndefined address that execution starts from after reset when executing in AArch64\nstate.\n\nbits [0:63] - Reset Address. The implementation defined address that execution\n              starts from after reset when executing in 64-bit state. Bits[1:0]\n              of this register are 00, as this address must be aligned, and the\n              address must be within the physical address size supported by the\n              PE."
      },
      "RVBAR_EL2": {
        "long_name": "Reset Vector Base Address Register (if EL3 not implemented)",
        "purpose": "If EL2 is the highest Exception level implemented, contains the implementation\ndefined address that execution starts from after reset when executing in AArch64\nstate.\n\nbits [0:63] - Reset Address. The implementation defined address that execution\n              starts from after reset when executing in 64-bit state. Bits[1:0]\n              of this register are 00, as this address must be aligned, and the\n              address must be within the physical address size supported by the\n              PE."
      },
      "RVBAR_EL3": {
        "long_name": "Reset Vector Base Address Register (if EL3 implemented)",
        "purpose": "If EL3 is the highest Exception level implemented, contains the implementation\ndefined address that execution starts from after reset when executing in AArch64\nstate.\n\nbits [0:63] - Reset Address. The implementation defined address that execution\n              starts from after reset when executing in 64-bit state. Bits[1:0]\n              of this register are 00, as this address must be aligned, and the\n              address must be within the physical address size supported by the\n              PE."
      },
      "S3_<op1>_<Cn>_<Cm>_<op2>": {
        "long_name": "IMPLEMENTATION DEFINED registers",
        "purpose": "This area of the instruction set space is reserved for implementation defined\nregisters."
      },
      "SCR_EL3": {
        "long_name": "Secure Configuration Register",
        "purpose": "Defines the configuration of the current Security state. It specifies:\n\n  - The Security state of EL0, EL1, and EL2. The Security state is either Secure\nor Non-secure.\n  - The Execution state at lower Exception levels.\n  - Whether IRQ, FIQ, SError interrupts, and External abort exceptions are taken\nto EL3.\n  - Whether various operations are trapped to EL3.\n\nAMVOFFEN, bit [35]   - Activity Monitors Virtual Offsets Enable.\nTWEDEL, bits [30:33] - TWE Delay.\nTWEDEn, bit [29]     - TWE Delay Enable.\nECVEn, bit [28]      - ECV Enable.\nFGTEn, bit [27]      - Enables access to the Fine-Grained Traps registers:\n                       HAFGRTR_EL2, HDFGRTR_EL2, HDFGWTR_EL2, HFGRTR_EL2,\n                       HFGITR_EL2 and HFGWTR_EL2.\nATA, bit [26]        - Allocation Tag Access.\nEnSCXT, bit [25]     - Enable access to the SCXTNUM_EL2, SCXTNUM_EL1, and\n                       SCXTNUM_EL0 registers.\nFIEN, bit [21]       - Fault Injection enable.\nNMEA, bit [20]       - Non-maskable External Aborts.\nEASE, bit [19]       - External aborts to SError interrupt vector.\nEEL2, bit [18]       - Secure EL2 Enable.\nAPI, bit [17]        - Controls the use of the following instructions related to\n                       Pointer Authentication.\nAPI, bit [17]        - Controls the use of instructions related to Pointer\n                       Authentication.\nAPK, bit [16]        - Trap registers holding \"key\" values for Pointer\n                       Authentication.\nTERR, bit [15]       - Trap Error record accesses.\nTLOR, bit [14]       - Trap LOR registers.\nTWE, bit [13]        - Traps EL2, EL1, and EL0 execution of WFE instructions to\n                       EL3, from both Security states and both Execution states,\n                       reported using EC syndrome value 0x01.\nTWI, bit [12]        - Traps EL2, EL1, and EL0 execution of WFI instructions to\n                       EL3, from both Security states and both Execution states,\n                       reported using EC syndrome value 0x01.\nST, bit [11]         - Traps Secure EL1 accesses to the Counter-timer Physical\n                       Secure timer registers to EL3, from AArch64 state only,\n                       reported using EC syndrome value 0x18.\nRW, bit [10]         - Execution state control for lower Exception levels.\nSIF, bit [9]         - Secure instruction fetch.\nSIF, bit [9]         - Secure instruction fetch.\nHCE, bit [8]         - Hypervisor Call instruction enable.\nSMD, bit [7]         - Secure Monitor Call disable.\nEA, bit [3]          - External Abort and SError interrupt routing.\nFIQ, bit [2]         - Physical FIQ Routing.\nIRQ, bit [1]         - Physical IRQ Routing.\nNS, bit [0]          - Non-secure bit."
      },
      "SCTLR_EL1": {
        "long_name": "System Control Register (EL1)",
        "purpose": "Provides top level control of the system, including its memory system, at EL1\nand EL0.\n\nTWEDEL, bits [46:49] - TWE Delay.\nTWEDEn, bit [45]     - TWE Delay Enable.\nDSSBS, bit [44]      - Default PSTATE.SSBS value on Exception Entry.\nATA, bit [43]        - Allocation Tag Access in EL1.\nATA0, bit [42]       - Allocation Tag Access in EL0.\nTCF, bits [40:41]    - Tag Check Fail in EL1.\nTCF0, bits [38:39]   - Tag Check Fail in EL0.\nITFSB, bit [37]      - When synchronous exceptions are not being generated by\n                       Tag Check fails which are generated for Loads and Stores\n                       in EL0 or EL1, controls the auto-synchronization of Tag\n                       Check fails into TFSRE0_EL1 and TFSR_EL1.\nBT1, bit [36]        - PAC Branch Type compatibility at EL1.\nBT0, bit [35]        - PAC Branch Type compatibility at EL0.\nEnIA, bit [31]       - Controls enabling of pointer authentication (using the\n                       APIAKey_EL1 key) of instruction addresses in the EL1&0\n                       translation regime.\nEnIB, bit [30]       - Controls enabling of pointer authentication (using the\n                       APIBKey_EL1 key) of instruction addresses in the EL1&0\n                       translation regime.\nLSMAOE, bit [29]     - Load Multiple and Store Multiple Atomicity and Ordering\n                       Enable.\nnTLSMD, bit [28]     - No Trap Load Multiple and Store Multiple to Device-nGRE\n                       /Device-nGnRE/Device-nGnRnE memory.\nEnDA, bit [27]       - Controls enabling of pointer authentication (using the\n                       APDAKey_EL1 key) of instruction addresses in the EL1&0\n                       translation regime.\nUCI, bit [26]        - Traps EL0 execution of cache maintenance instructions, to\n                       EL1, or to EL2 when it is implemented and enabled for the\n                       current Security state and HCR_EL2.TGE is 1, from AArch64\n                       state only, reported using EC syndrome value 0x18.\nEE, bit [25]         - Endianness of data accesses at EL1, and stage 1\n                       translation table walks in the EL1&0 translation regime.\nE0E, bit [24]        - Endianness of data accesses at EL0.\nSPAN, bit [23]       - Set Privileged Access Never, on taking an exception to\n                       EL1.\nEIS, bit [22]        - Exception Entry is Context Synchronizing.\nIESB, bit [21]       - Implicit Error Synchronization event enable.\nTSCXT, bit [20]      - Trap EL0 Access to the SCXTNUM_EL0 register, when EL0 is\n                       using AArch64.\nWXN, bit [19]        - Write permission implies XN (Execute-never).\nnTWE, bit [18]       - Traps EL0 execution of WFE instructions to EL1, or to EL2\n                       when it is implemented and enabled for the current\n                       Security state and HCR_EL2.TGE is 1, from both Execution\n                       states, reported using EC syndrome value 0x01.\nnTWI, bit [16]       - Traps EL0 execution of WFI instructions to EL1, or to EL2\n                       when it is implemented and enabled for the current\n                       Security state and HCR_EL2.TGE is 1, from both Execution\n                       states, reported using EC syndrome value 0x01.\nUCT, bit [15]        - Traps EL0 accesses to the CTR_EL0 to EL1, or to EL2 when\n                       it is implemented and enabled for the current Security\n                       state and HCR_EL2.TGE is 1, from AArch64 state only,\n                       reported using EC value 0x18.\nDZE, bit [14]        - Traps EL0 execution of DC ZVA instructions to EL1, or to\n                       EL2 when it is implemented and enabled for the current\n                       Security state and HCR_EL2.TGE is 1, from AArch64 state\n                       only, reported using EC syndrome value 0x18.\nEnDB, bit [13]       - Controls enabling of pointer authentication (using the\n                       APDBKey_EL1 key) of instruction addresses in the EL1&0\n                       translation regime.\nI, bit [12]          - Instruction access Cacheability control, for accesses at\n                       EL0 and EL1:\nEOS, bit [11]        - Exception Exit is Context Synchronizing.\nEnRCTX, bit [10]     - Enable EL0 Access to the AArch32 CFPRCTX, DVPRCTX and\n                       CPPRCTX instructions, and the AArch64 CFP RCTX, DVP RCT\n                       and CPP RCTX instructions.\nUMA, bit [9]         - User Mask Access.\nSED, bit [8]         - SETEND instruction disable.\nITD, bit [7]         - IT Disable.\nnAA, bit [6]         - Non-aligned access.\nCP15BEN, bit [5]     - System instruction memory barrier enable.\nSA0, bit [4]         - SP Alignment check enable for EL0.\nSA, bit [3]          - SP Alignment check enable.\nC, bit [2]           - Cacheability control, for data accesses.\nA, bit [1]           - Alignment check enable.\nM, bit [0]           - MMU enable for EL1 and EL0 stage 1 address translation."
      },
      "SCTLR_EL2": {
        "long_name": "System Control Register (EL2)",
        "purpose": "Provides top level control of the system, including its memory system, at EL2.\n\nWhen ARMv8.1-VHE is implemented, and the value of HCR_EL2.{E2H, TGE} is {1, 1},\nthese controls apply also to execution at EL0.\n\nDSSBS, bit [44]   - Default PSTATE.SSBS value on Exception Entry.\nATA, bit [43]     - Allocation Tag Access.\nTCF, bits [40:41] - Tack Check Fail in EL2.\nITFSB, bit [37]   - When synchronous exceptions are not being generated by Tag\n                    Check fails which are generated for Loads and Stores in EL0,\n                    EL1 or EL2, controls the auto-synchronisaton of Tag Check\n                    fails into TFSRE0_EL1, TFSR_EL1 and TFSR_EL2.\nBT, bit [36]      - PAC Branch Type compatibility at EL2.\nEnIA, bit [31]    - Controls enabling of pointer authentication (using the\n                    APIAKey_EL1 key) of instruction addresses in the EL2&0\n                    translation regime.\nEnIB, bit [30]    - Controls enabling of pointer authentication (using the\n                    APIBKey_EL1 key) of instruction addresses in the EL2&0\n                    translation regime.\nEnDA, bit [27]    - Controls enabling of pointer authentication (using the\n                    APDAKey_EL1 key) of instruction addresses in the EL2&0\n                    translation regime.\nEE, bit [25]      - Endianness of data accesses at EL2, stage 1 translation\n                    table walks in the EL2 or EL2&0 translation regime, and\n                    stage 2 translation table walks in the EL1&0 translation\n                    regime.\nEIS, bit [22]     - Exception entry is a context synchronization event.\nIESB, bit [21]    - Implicit Error Synchronization event enable.\nWXN, bit [19]     - Write permission implies XN (Execute-never).\nEnDB, bit [13]    - Controls enabling of pointer authentication (using the\n                    APDBKey_EL1 key) of instruction addresses in the EL2&0\n                    translation regime.\nI, bit [12]       - Instruction access Cacheability control, for accesses at\n                    EL2:\nEOS, bit [11]     - Exception exit is a context synchronization Event.\nnAA, bit [6]      - Non-aligned access.\nSA, bit [3]       - SP Alignment check enable.\nC, bit [2]        - Cacheability control, for data accesses.\nA, bit [1]        - Alignment check enable.\nM, bit [0]        - MMU enable for EL2 stage 1 address translation."
      },
      "SCTLR_EL3": {
        "long_name": "System Control Register (EL3)",
        "purpose": "Provides top level control of the system, including its memory system, at EL3.\n\nDSSBS, bit [44]   - Default PSTATE.SSBS value on Exception Entry.\nATA, bit [43]     - Allocation Tag Access in EL3.\nTCF, bits [40:41] - Tag Check Fail in EL3.\nITFSB, bit [37]   - When asynchronous exceptions are being generated by Tag\n                    Check fails which are generated for Loads and Stores at any\n                    exception level, controls the auto-synchronisaton of Tag\n                    Check fails into TFSRE0_EL1 and TFSR_ELx.\nBT, bit [36]      - PAC Branch Type compatibility at EL3.\nEnIA, bit [31]    - Controls enabling of pointer authentication (using the\n                    APIAKey_EL1 key) of instruction addresses in the EL3\n                    translation regime.\nEnIB, bit [30]    - Controls enabling of pointer authentication (using the\n                    APIBKey_EL1 key) of instruction addresses in the EL3\n                    translation regime.\nEnDA, bit [27]    - Controls enabling of pointer authentication (using the\n                    APDAKey_EL1 key) of instruction addresses in the EL3\n                    translation regime.\nEE, bit [25]      - Endianness of data accesses at EL3, and stage 1 translation\n                    table walks in the EL3 translation regime.\nEIS, bit [22]     - Exception Entry is Context Synchronizing.\nIESB, bit [21]    - Implicit Error Synchronization event enable.\nWXN, bit [19]     - Write permission implies XN (Execute-never).\nEnDB, bit [13]    - Controls enabling of pointer authentication (using the\n                    APDBKey_EL1 key) of instruction addresses in the EL3\n                    translation regime.\nI, bit [12]       - Instruction access Cacheability control, for accesses at\n                    EL3:\nEOS, bit [11]     - Exception Exit is Context Synchronizing.\nnAA, bit [6]      - Non-aligned access.\nSA, bit [3]       - SP Alignment check enable.\nC, bit [2]        - Cacheability control, for data accesses.\nA, bit [1]        - Alignment check enable.\nM, bit [0]        - MMU enable for EL3 stage 1 address translation."
      },
      "SCXTNUM_EL0": {
        "long_name": "EL0 Read/Write Software Context Number",
        "purpose": "Provides a number that can be used to separate out different context numbers\nwith the EL0 exception level, for the purpose of protecting against side-\nchannels using branch prediction and similar resources.\n\nbits [0:63] - Software Context Number. A number to identify the context within\n              the EL0 exception level."
      },
      "SCXTNUM_EL1": {
        "long_name": "EL1 Read/Write Software Context Number",
        "purpose": "Provides a number that can be used to separate out different context numbers\nwith the EL1 exception level, for the purpose of protecting against side-\nchannels using branch prediction and similar resources.\n\nbits [0:63] - Software Context Number. A number to identify the context within\n              the EL1 exception level."
      },
      "SCXTNUM_EL2": {
        "long_name": "EL2 Read/Write Software Context Number",
        "purpose": "Provides a number that can be used to separate out different context numbers\nwith the EL2 exception level, for the purpose of protecting against side-\nchannels using branch prediction and similar resources.\n\nbits [0:63] - Software Context Number. A number to identify the context within\n              the EL2 exception level."
      },
      "SCXTNUM_EL3": {
        "long_name": "EL3 Read/Write Software Context Number",
        "purpose": "Provides a number that can be used to separate out different context numbers\nwith the EL3 exception level, for the purpose of protecting against side-\nchannels using branch prediction and similar resources.\n\nbits [0:63] - Software Context Number. A number to identify the context within\n              the EL3 exception level."
      },
      "SDER32_EL2": {
        "long_name": "AArch32 Secure Debug Enable Register",
        "purpose": "Allows access to the AArch32 register SDER from Secure EL2 and EL3 only.\n\nSUNIDEN, bit [1] - Secure User Non-Invasive Debug Enable.\n                       0b0 This bit does not affect Performance Monitors event\n                   counting at Secure EL0.\n                       0b1 If EL1 is using AArch32, Performance Monitors event\n                   counting is allowed in Secure EL0.\nSUIDEN, bit [0]  - Secure User Invasive Debug Enable.\n                       0b0 This bit does not affect the generation of debug\n                   exceptions at Secure EL0.\n                       0b1 If EL1 is using AArch32, debug exceptions from Secure\n                   EL0 are enabled."
      },
      "SDER32_EL3": {
        "long_name": "AArch32 Secure Debug Enable Register",
        "purpose": "Allows access to the AArch32 register SDER from AArch64 state only. Its value\nhas no effect on execution in AArch64 state.\n\nSUNIDEN, bit [1] - Secure User Non-Invasive Debug Enable.\n                       0b0 This bit does not affect Performance Monitors event\n                   counting at Secure EL0.\n                       0b1 If EL1 is using AArch32, Performance Monitors event\n                   counting is allowed in Secure EL0.\nSUIDEN, bit [0]  - Secure User Invasive Debug Enable.\n                       0b0 This bit does not affect the generation of debug\n                   exceptions at Secure EL0.\n                       0b1 If EL1 is using AArch32, debug exceptions from Secure\n                   EL0 are enabled."
      },
      "SPSR_EL1": {
        "long_name": "Saved Program Status Register (EL1)",
        "purpose": "Holds the saved process state when an exception is taken to EL1.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT[1:0], bits [25:26] - If-Then.\nDIT, bit [24]         - Data Independent Timing.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nSS, bit [21]          - Software Step.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - If-Then.\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4], bit [4]         - Execution state.\nM[3:0], bits [0:3]    - AArch32 Mode."
      },
      "SPSR_EL2": {
        "long_name": "Saved Program Status Register (EL2)",
        "purpose": "Holds the saved process state when an exception is taken to EL2.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT[1:0], bits [25:26] - If-Then.\nDIT, bit [24]         - Data Independent Timing.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nSS, bit [21]          - Software Step.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - If-Then.\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4], bit [4]         - Execution state.\nM[3:0], bits [0:3]    - AArch32 Mode."
      },
      "SPSR_EL3": {
        "long_name": "Saved Program Status Register (EL3)",
        "purpose": "Holds the saved process state when an exception is taken to EL3.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT[1:0], bits [25:26] - If-Then.\nDIT, bit [24]         - Data Independent Timing.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nSS, bit [21]          - Software Step.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - If-Then.\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4], bit [4]         - Execution state.\nM[3:0], bits [0:3]    - AArch32 Mode."
      },
      "SPSR_abt": {
        "long_name": "Saved Program Status Register (Abort mode)",
        "purpose": "Holds the saved process state when an exception is taken to Abort mode.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT[1:0], bits [25:26] - If-Then.\nJ, bit [24]           - res0.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - If-Then.\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "SPSR_fiq": {
        "long_name": "Saved Program Status Register (FIQ mode)",
        "purpose": "Holds the saved process state when an exception is taken to FIQ mode.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT[1:0], bits [25:26] - If-Then.\nJ, bit [24]           - res0.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - If-Then.\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "SPSR_irq": {
        "long_name": "Saved Program Status Register (IRQ mode)",
        "purpose": "Holds the saved process state when an exception is taken to IRQ mode.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT[1:0], bits [25:26] - If-Then.\nJ, bit [24]           - res0.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - If-Then.\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "SPSR_und": {
        "long_name": "Saved Program Status Register (Undefined mode)",
        "purpose": "Holds the saved process state when an exception is taken to Undefined mode.\n\nN, bit [31]           - Negative Condition flag.\nZ, bit [30]           - Zero Condition flag.\nC, bit [29]           - Carry Condition flag.\nV, bit [28]           - Overflow Condition flag.\nQ, bit [27]           - Overflow or saturation flag.\nIT[1:0], bits [25:26] - If-Then.\nJ, bit [24]           - res0.\nSSBS, bit [23]        - Speculative Store Bypass.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state.\nGE, bits [16:19]      - Greater than or Equal flags.\nIT[7:2], bits [10:15] - If-Then.\nE, bit [9]            - Endianness.\nA, bit [8]            - SError interrupt mask.\nI, bit [7]            - IRQ interrupt mask.\nF, bit [6]            - FIQ interrupt mask.\nT, bit [5]            - T32 Instruction set state.\nM[4:0], bits [0:4]    - Mode."
      },
      "SPSel": {
        "long_name": "Stack Pointer Select",
        "purpose": "Allows the Stack Pointer to be selected between SP_EL0 and SP_ELx.\n\nSP, bit [0] - Stack pointer to use. Possible values of this bit are:\n                  0b0 Use SP_EL0 at all Exception levels.\n                  0b1 Use SP_ELx for Exception level ELx."
      },
      "SP_EL0": {
        "long_name": "Stack Pointer (EL0)",
        "purpose": "Holds the stack pointer associated with EL0. At higher Exception levels, this is\nused as the current stack pointer when the value of SPSel.SP is 0.\n\nbits [0:63] - Stack pointer."
      },
      "SP_EL1": {
        "long_name": "Stack Pointer (EL1)",
        "purpose": "Holds the stack pointer associated with EL1. When executing at EL1, the value of\nSPSel.SP determines the current stack pointer:\n\n SPSel.SP | Current stack pointer\n ---------+----------------------\n 0b0      | SP_EL0               \n 0b1      | SP_EL1               \n\nbits [0:63] - Stack pointer."
      },
      "SP_EL2": {
        "long_name": "Stack Pointer (EL2)",
        "purpose": "Holds the stack pointer associated with EL2. When executing at EL2, the value of\nSPSel. SP determines the current stack pointer:\n\n SPSel.SP | Current stack pointer\n ---------+----------------------\n 0b0      | SP_EL0               \n 0b1      | SP_EL2               \n\nbits [0:63] - Stack pointer."
      },
      "SP_EL3": {
        "long_name": "Stack Pointer (EL3)",
        "purpose": "Holds the stack pointer associated with EL3. When executing at EL3, the value of\nSPSel.SP determines the current stack pointer:\n\n SPSel.SP | Current stack pointer\n ---------+----------------------\n 0b0      | SP_EL0               \n 0b1      | SP_EL3               \n\nbits [0:63] - Stack pointer."
      },
      "SSBS": {
        "long_name": "Speculative Store Bypass Safe",
        "purpose": "Allows access to the Speculative Store Bypass Safe bit.\n\nSSBS, bit [12] - Speculative Store Bypass Safe. Prohibits speculative loads or\n                 stores which might practically allow a cache timing side\n                 channel. A cache timing side channel might be exploited where a\n                 load or store uses an address that is derived from a register\n                 that is being loaded from memory using a load instruction\n                 speculatively read from a memory location. If PSTATE.SSBS is\n                 enabled, the address derived from the load instruction might be\n                 from earlier in the coherence order than the latest store to\n                 that memory location with the same virtual address.\n                     0b0 Hardware is not permitted to load or store\n                 speculatively, in a manner that could practically give rise to\n                 a cache timing side channel, using an address derived from a\n                 register value that has been loaded from memory using a load\n                 instruction (L) that speculatively reads an entry from earlier\n                 in the coherence order from that location being loaded from\n                 than the entry generated by the latest store (S) to that\n                 location using the same virtual address as L.\n                     0b1 Hardware is permitted to load or store speculatively,\n                 in a manner that could practically give rise to a cache timing\n                 side channel, using an address derived from a register value\n                 that has been loaded from memory using a load instruction (L)\n                 that speculatively reads an entry from earlier in the coherence\n                 order fro that location being loaded from than the entry\n                 generated by the latest store (S) to that location using the\n                 same virtual address as L.\n                 The value of this bit is set to the value in the\n                 SCTLR_ELx.DSSBS field on taking an exception to ELx."
      },
      "TCO": {
        "long_name": "Tag Check Override",
        "purpose": "When ARMv8.5-MemTag is implemented, this register allows tag checks to be\ndisabled globally.\n\nTCO, bit [25] - Allows memory tag checks to be globally disabled.\n                    0b0 Loads and Stores are not affected by this control.\n                    0b1 Loads and Stores are unchecked."
      },
      "TCR_EL1": {
        "long_name": "Translation Control Register (EL1)",
        "purpose": "The control register for stage 1 of the EL1&0 translation regime.\n\nTCMA1, bit [58]     - Controls the generation of Unchecked accesses at EL1, and\n                      at EL0 if HCR_EL2.{E2H,TGE}!={1,1}, when address[59:55] =\n                      0b11111.\nTCMA0, bit [57]     - Controls the generation of Unchecked accesses at EL1, and\n                      at EL0 if HCR_EL2.{E2H,TGE}!={1,1}, when address[59:55] =\n                      0b00000.\nE0PD1, bit [56]     - Faulting control for EL0 access to any address translated\n                      by TTBR1_EL1.\nE0PD0, bit [55]     - Faulting control for EL0 access to any address translated\n                      by TTBR0_EL1.\nNFD1, bit [54]      - Non-fault translation table walk disable for stage 1\n                      translations using TTBR1_EL1.\nNFD0, bit [53]      - Non-fault translation table walk disable for stage 1\n                      translations using TTBR0_EL1.\nTBID1, bit [52]     - Controls the use of the top byte of instruction addresses\n                      for address matching.\nTBID0, bit [51]     - Controls the use of the top byte of instruction addresses\n                      for address matching.\nHWU162, bit [50]    - Hardware Use.\nHWU161, bit [49]    - Hardware Use.\nHWU160, bit [48]    - Hardware Use.\nHWU159, bit [47]    - Hardware Use.\nHWU062, bit [46]    - Hardware Use.\nHWU061, bit [45]    - Hardware Use.\nHWU060, bit [44]    - Hardware Use.\nHWU059, bit [43]    - Hardware Use.\nHPD1, bit [42]      - Hierarchical Permission Disables.\nHPD0, bit [41]      - Hierarchical Permission Disables.\nHD, bit [40]        - Hardware management of dirty state in stage 1 translations\n                      from EL0 and EL1.\nHA, bit [39]        - Hardware Access flag update in stage 1 translations from\n                      EL0 and EL1.\nTBI1, bit [38]      - Top Byte ignored - indicates whether the top byte of an\n                      address is used for address match for the TTBR1_EL1\n                      region, or ignored and used for tagged addresses.\nTBI0, bit [37]      - Top Byte ignored - indicates whether the top byte of an\n                      address is used for address match for the TTBR0_EL1\n                      region, or ignored and used for tagged addresses.\nAS, bit [36]        - ASID Size.\nIPS, bits [32:34]   - Intermediate Physical Address Size.\nTG1, bits [30:31]   - Granule size for the TTBR1_EL1.\nSH1, bits [28:29]   - Shareability attribute for memory associated with\n                      translation table walks using TTBR1_EL1.\nORGN1, bits [26:27] - Outer cacheability attribute for memory associated with\n                      translation table walks using TTBR1_EL1.\nIRGN1, bits [24:25] - Inner cacheability attribute for memory associated with\n                      translation table walks using TTBR1_EL1.\nEPD1, bit [23]      - Translation table walk disable for translations using\n                      TTBR1_EL1.\nA1, bit [22]        - Selects whether TTBR0_EL1 or TTBR1_EL1 defines the ASID.\nT1SZ, bits [16:21]  - The size offset of the memory region addressed by\n                      TTBR1_EL1.\nTG0, bits [14:15]   - Granule size for the TTBR0_EL1.\nSH0, bits [12:13]   - Shareability attribute for memory associated with\n                      translation table walks using TTBR0_EL1.\nORGN0, bits [10:11] - Outer cacheability attribute for memory associated with\n                      translation table walks using TTBR0_EL1.\nIRGN0, bits [8:9]   - Inner cacheability attribute for memory associated with\n                      translation table walks using TTBR0_EL1.\nEPD0, bit [7]       - Translation table walk disable for translations using\n                      TTBR0_EL1.\nT0SZ, bits [0:5]    - The size offset of the memory region addressed by\n                      TTBR0_EL1."
      },
      "TCR_EL2": {
        "long_name": "Translation Control Register (EL2)",
        "purpose": "The control register for stage 1 of the EL2, or EL2&0, translation regime:\n\n  - When the Effective value of HCR_EL2.E2H is 0, this register controls stage 1\nof the EL2 translation regime, that supports a single VA range, translated using\nTTBR0_EL2.\n  - When the value of HCR_EL2.E2H is 1, this register controls stage 1 of the\nEL2&0 translation regime, that supports both:\n    - A lower VA range, translated using TTBR0_EL2.\n    - A higher VA range, translated using TTBR1_EL2.\n\nTCMA, bit [30]      - Controls the generation of Unchecked accesses at EL2 when\n                      address [59:56] = 0b0000.\nTBID, bit [29]      - Controls the use of the top byte of instruction addresses\n                      for address matching.\nHWU62, bit [28]     - Hardware Use.\nHWU61, bit [27]     - Hardware Use.\nHWU60, bit [26]     - Hardware Use.\nHWU59, bit [25]     - Hardware Use.\nHPD, bit [24]       - Hierarchical Permission Disables.\nHD, bit [22]        - Hardware management of dirty state in stage 1 translations\n                      from EL2.\nHA, bit [21]        - Hardware Access flag update in stage 1 translations from\n                      EL2.\nTBI, bit [20]       - Top Byte Ignored.\nPS, bits [16:18]    - Physical Address Size.\nTG0, bits [14:15]   - Granule size for the TTBR0_EL2.\nSH0, bits [12:13]   - Shareability attribute for memory associated with\n                      translation table walks using TTBR0_EL2.\nORGN0, bits [10:11] - Outer cacheability attribute for memory associated with\n                      translation table walks using TTBR0_EL2.\nIRGN0, bits [8:9]   - Inner cacheability attribute for memory associated with\n                      translation table walks using TTBR0_EL2.\nT0SZ, bits [0:5]    - The size offset of the memory region addressed by\n                      TTBR0_EL2."
      },
      "TCR_EL3": {
        "long_name": "Translation Control Register (EL3)",
        "purpose": "The control register for stage 1 of the EL3 translation regime.\n\nTCMA, bit [30]      - Controls the generation of Unchecked accesses at EL3 when\n                      address [59:56] = 0b0000.\nTBID, bit [29]      - Controls the use of the top byte of instruction addresses\n                      for address matching.\nHWU62, bit [28]     - Hardware Use.\nHWU61, bit [27]     - Hardware Use.\nHWU60, bit [26]     - Hardware Use.\nHWU59, bit [25]     - Hardware Use.\nHPD, bit [24]       - Hierarchical Permission Disables.\nHD, bit [22]        - Hardware management of dirty state in stage 1 translations\n                      from EL3.\nHA, bit [21]        - Hardware Access flag update in stage 1 translations from\n                      EL3.\nTBI, bit [20]       - Top Byte Ignored.\nPS, bits [16:18]    - Physical Address Size.\nTG0, bits [14:15]   - Granule size for the TTBR0_EL3.\nSH0, bits [12:13]   - Shareability attribute for memory associated with\n                      translation table walks using TTBR0_EL3.\nORGN0, bits [10:11] - Outer cacheability attribute for memory associated with\n                      translation table walks using TTBR0_EL3.\nIRGN0, bits [8:9]   - Inner cacheability attribute for memory associated with\n                      translation table walks using TTBR0_EL3.\nT0SZ, bits [0:5]    - The size offset of the memory region addressed by\n                      TTBR0_EL3."
      },
      "TFSRE0_EL1": {
        "long_name": "Tag Fail Status Register (EL0).",
        "purpose": "Holds accumulated Tag Check Fails occurring in EL0 which are not taken\nprecisely.\n\nTF1, bit [1] - Tag Check Fail. Asynchronously set to 1 when a Tag Check fail\n               using a virtual address with bit<55>==0b1 occurs.\nTF0, bit [0] - Tag Check Fail. Asynchronously set to 1 when a Tag Check fail\n               using a virtual address with bit<55>==0b0 occurs."
      },
      "TFSR_EL1": {
        "long_name": "Tag Fail Status Register (EL1)",
        "purpose": "Holds accumulated Tag Check Fails occurring in EL1 which are not taken\nprecisely.\n\nTF1, bit [1] - Tag Check Fail. Asynchronously set to 1 when a Tag Check fail\n               using a virtual address with bit<55>==0b1 occurs.\nTF0, bit [0] - Tag Check Fail. Asynchronously set to 1 when a Tag Check fail\n               using a virtual address with bit<55>==0b0 occurs."
      },
      "TFSR_EL2": {
        "long_name": "Tag Fail Status Register (EL2)",
        "purpose": "Holds accumulated Tag Check Fails occurring in EL2 which are not taken\nprecisely.\n\nTF1, bit [1] - Tag Check Fail. Asynchronously set to 1 when a Tag Check fail\n               using a virtual address with bit<55>==0b1 occurs.\n               When HCR_EL2.E2H==0b0, this field is res0.\nTF0, bit [0] - Tag Check Fail. Asynchronously set to 1 when a Tag Check fail\n               using a virtual address with bit<55>==0b0 occurs."
      },
      "TFSR_EL3": {
        "long_name": "Tag Fail Status Register (EL3)",
        "purpose": "Holds accumulated Tag Check Fails occurring in EL3 which are not taken\nprecisely.\n\nTF0, bit [0] - Tag Check Fail. Asynchronously set to 1 when a Tag Check fail\n               using a virtual address with bit<55>==0b0 occurs."
      },
      "TPIDRRO_EL0": {
        "long_name": "EL0 Read-Only Software Thread ID Register",
        "purpose": "Provides a location where software executing at EL1 or higher can store thread\nidentifying information that is visible to software executing at EL0, for OS\nmanagement purposes.\n\nThe PE makes no use of this register.\n\nbits [0:63] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "TPIDR_EL0": {
        "long_name": "EL0 Read/Write Software Thread ID Register",
        "purpose": "Provides a location where software executing at EL0 can store thread identifying\ninformation, for OS management purposes.\n\nThe PE makes no use of this register.\n\nbits [0:63] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "TPIDR_EL1": {
        "long_name": "EL1 Software Thread ID Register",
        "purpose": "Provides a location where software executing at EL1 can store thread identifying\ninformation, for OS management purposes.\n\nThe PE makes no use of this register.\n\nbits [0:63] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "TPIDR_EL2": {
        "long_name": "EL2 Software Thread ID Register",
        "purpose": "Provides a location where software executing at EL2 can store thread identifying\ninformation, for OS management purposes.\n\nThe PE makes no use of this register.\n\nbits [0:63] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "TPIDR_EL3": {
        "long_name": "EL3 Software Thread ID Register",
        "purpose": "Provides a location where software executing at EL3 can store thread identifying\ninformation, for OS management purposes.\n\nThe PE makes no use of this register.\n\nbits [0:63] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "TRFCR_EL1": {
        "long_name": "Trace Filter Control Register (EL1)",
        "purpose": "Provides EL1 controls for Trace.\n\nTS, bits [5:6] - Timestamp Control\n                     0b01 Virtual timestamp. The traced timestamp is the\n                 physical counter value, minus the value of CNTVOFF_EL2.\n                     0b10 Guest Physical timestamp. The traced timestamp is the\n                 physical counter value, minus the value of CNTPOFF_EL2.\n                     0b11 Physical timestamp. The traced timestamp is the\n                 physical counter value.\n                 All other values are reserved This field is ignored if any of\n                 the following are true:\n                   - SelfHostedTraceEnabled() == FALSE.\n                   - EL2 is implemented and TRFCR_EL2.TS != 0b00. When EL2 is\n                 implemented and enabled in the current Security state, the\n                 physical counter uses a fixed physical offset of zero if either\n                 of the following are true:\n                   - CNTHCTL_EL2.ECV is 0.\n                   - SCR_EL3.ECVEn is 0.\n                   - HCR_EL2.{E2H, TGE} is {1, 1}.\nE1TRE, bit [1] - EL1 Trace Enable.\n                     0b0 Trace is prohibited at EL1.\n                     0b1 Trace is allowed at EL1.\n                 This field is ignored if SelfHostedTraceEnabled() == FALSE.\nE0TRE, bit [0] - EL0 Trace Enable.\n                     0b0 Trace is prohibited at EL0.\n                     0b1 Trace is allowed at EL0.\n                 This field is ignored if any of the following are true:\n                   - SelfHostedTraceEnabled() == FALSE.\n                   - EL2 is implemented and enabled in the current Security\n                 state and HCR_EL2.TGE == 1."
      },
      "TRFCR_EL2": {
        "long_name": "Trace Filter Control Register (EL2)",
        "purpose": "Provides EL2 controls for Trace.\n\nTS, bits [5:6]  - Timestamp Control. Controls which timebase is used for trace\n                  timestamps.\n                      0b00 Timestamp controlled by TRFCR_EL1.TS or TRFCR.TS.\n                      0b01 Virtual timestamp. The traced timestamp is the\n                  physical counter value, minus the value of CNTVOFF_EL2.\n                      0b10 Guest Physical timestamp. The traced timestamp is the\n                  physical counter value, minus the value of CNTPOFF_EL2.\n                      0b11 Physical timestamp. The traced timestamp is the\n                  physical counter value.\nCX, bit [3]     - CONTEXTIDR_EL2 and VMID trace enable.\n                      0b0 CONTEXTIDR_EL2 and VMID trace prohibited.\n                      0b1 CONTEXTIDR_EL2 and VMID trace allowed.\nE2TRE, bit [1]  - EL2 Trace Enable.\n                      0b0 Trace is prohibited at EL2.\n                      0b1 Trace is allowed at EL2.\nE0HTRE, bit [0] - EL0 Trace Enable.\n                      0b0 Trace is prohibited at EL0 when HCR_EL2.TGE == 1.\n                      0b1 Trace is allowed at EL0 when HCR_EL2.TGE == 1."
      },
      "TTBR0_EL1": {
        "long_name": "Translation Table Base Register 0 (EL1)",
        "purpose": "Holds the base address of the translation table for the initial lookup for stage\n1 of the translation of an address from the lower VA range in the EL1&0\ntranslation regime, and other information for this translation regime.\n\nASID, bits [48:63] - An ASID for the translation table base address.\nBADDR, bits [1:47] - Translation table base address, A[47:x] or A[51:x],\n                     bits[47:1].\nCnP, bit [0]       - Common not Private."
      },
      "TTBR0_EL2": {
        "long_name": "Translation Table Base Register 0 (EL2)",
        "purpose": "When HCR_EL2.E2H is 0, holds the base address of the translation table for the\ninitial lookup for stage 1 of an address translation in the EL2 translation\nregime, and other information for this translation regime.\n\nWhen HCR_EL2.E2H is 1, holds the base address of the translation table for the\ninitial lookup for stage 1 of the translation of an address from the lower VA\nrange in the EL2&0 translation regime, and other information for this\ntranslation regime.\n\nASID, bits [48:63] - When HCR_EL2.E2H is 0, this field is res0.\nBADDR, bits [1:47] - Translation table base address, A[47:x] or A[51:x],\n                     bits[47:1].\nCnP, bit [0]       - Common not Private."
      },
      "TTBR0_EL3": {
        "long_name": "Translation Table Base Register 0 (EL3)",
        "purpose": "Holds the base address of the translation table for the initial lookup for stage\n1 of an address translation in the EL3 translation regime, and other information\nfor this translation regime.\n\nBADDR, bits [1:47] - Translation table base address, A[47:x] or A[51:x].\nCnP, bit [0]       - Common not Private."
      },
      "TTBR1_EL1": {
        "long_name": "Translation Table Base Register 1 (EL1)",
        "purpose": "Holds the base address of the translation table for the initial lookup for stage\n1 of the translation of an address from the higher VA range in the EL1&0 stage 1\ntranslation regime, and other information for this translation regime.\n\nASID, bits [48:63] - An ASID for the translation table base address.\nBADDR, bits [1:47] - Translation table base address, A[47:x] or A[51:x],\n                     bits[47:1].\nCnP, bit [0]       - Common not Private."
      },
      "TTBR1_EL2": {
        "long_name": "Translation Table Base Register 1 (EL2)",
        "purpose": "When HCR_EL2.E2H is 1, holds the base address of the translation table for the\ninitial lookup for stage 1 of the translation of an address from the higher VA\nrange in the EL2&0 translation regime, and other information for this\ntranslation regime.\n\nWhen HCR_EL2.E2H is 0, the contents of this register are ignored by the PE,\nexcept for a direct read or write of the register.\n\nASID, bits [48:63] - An ASID for the translation table base address.\nBADDR, bits [1:47] - Translation table base address, A[47:x] or A[51:x],\n                     bits[47:1].\nCnP, bit [0]       - Common not Private."
      },
      "UAO": {
        "long_name": "User Access Override",
        "purpose": "Allows access to the User Access Override bit.\n\nUAO, bit [23] - User Access Override.\n                    0b0 The behavior of LDTR* and STTR* instructions is as\n                defined in the base Armv8 architecture.\n                    0b1 When executed at EL1, or at EL2 with HCR_EL2.{E2H, TGE}\n                == {1, 1}, LDTR* and STTR* instructions behave as the equivalent\n                LDR* and STR* instructions.\n                When executed at EL3, or at EL2 with HCR_EL2.E2H == 0 or\n                HCR_EL2.TGE == 0, the LDTR* and STTR* instructions behave as the\n                equivalent LDR* and STR* instructions, regardless of the setting\n                of the PSTATE.UAO bit."
      },
      "VBAR_EL1": {
        "long_name": "Vector Base Address Register (EL1)",
        "purpose": "Holds the vector base address for any exception that is taken to EL1.\n\nbits [11:63] - Vector Base Address. Base address of the exception vectors for\n               exceptions taken to EL1. If the implementation does not support\n               ARMv8.2-LVA, then:\n                 - If tagged addresses are being used, bits [55:48] of VBAR_EL1\n               must be the same or else the use of the vector address will\n               result in a recursive exception.\n                 - If tagged addresses are not being used, bits [63:48] of\n               VBAR_EL1 must be the same or else the use of the vector address\n               will result in a recursive exception. If the implementation\n               supports ARMv8.2-LVA, then:\n                 - If tagged addresses are being used, bits [55:52] of VBAR_EL1\n               must be the same or else the use of the vector address will\n               result in a recursive exception.\n                 - If tagged addresses are not being used, bits [63:52] of\n               VBAR_EL1 must be the same or else the use of the vector address\n               will result in a recursive exception."
      },
      "VBAR_EL2": {
        "long_name": "Vector Base Address Register (EL2)",
        "purpose": "Holds the vector base address for any exception that is taken to EL2.\n\nbits [11:63] - Vector Base Address. Base address of the exception vectors for\n               exceptions taken to EL2. If the implementation does not support\n               ARMv8.2-LVA, then:\n                 - If tagged addresses are being used, bits [55:48] of VBAR_EL2\n               must be 0 or else the use of the vector address will result in a\n               recursive exception.\n                 - If tagged addresses are not being used, bits [63:48] of\n               VBAR_EL2 must be 0 or else the use of the vector address will\n               result in a recursive exception. If the implementation supports\n               ARMv8.2-LVA, then:\n                 - If tagged addresses are being used, bits [55:52] of VBAR_EL2\n               must be the same or else the use of the vector address will\n               result in a recursive exception.\n                 - If tagged addresses are not being used, bits [63:52] of\n               VBAR_EL2 must be the same or else the use of the vector address\n               will result in a recursive exception."
      },
      "VBAR_EL3": {
        "long_name": "Vector Base Address Register (EL3)",
        "purpose": "Holds the vector base address for any exception that is taken to EL3.\n\nbits [11:63] - Vector Base Address. Base address of the exception vectors for\n               exceptions taken to EL3. If the implementation does not support\n               ARMv8.2-LVA, then:\n                 - If tagged addresses are being used, bits [55:48] of VBAR_EL3\n               must be 0 or else the use of the vector address will result in a\n               recursive exception.\n                 - If tagged addresses are not being used, bits [63:48] of\n               VBAR_EL3 must be 0 or else the use of the vector address will\n               result in a recursive exception. If the implementation supports\n               ARMv8.2-LVA, then:\n                 - If tagged addresses are being used, bits [55:52] of VBAR_EL3\n               must be the same or else the use of the vector address will\n               result in a recursive exception.\n                 - If tagged addresses are not being used, bits [63:52] of\n               VBAR_EL3 must be the same or else the use of the vector address\n               will result in a recursive exception."
      },
      "VDISR_EL2": {
        "long_name": "Virtual Deferred Interrupt Status Register",
        "purpose": "Records that a virtual SError interrupt has been consumed by an ESB instruction\nexecuted at EL1.\n\nAn indirect write to VDISR_EL2 made by an ESB instruction does not require an\nexplicit synchronization operation for the value written to be observed by a\ndirect read of DISR_EL1 or DISR occurring in program order after the ESB\ninstruction.\n\nA, bit [31]      - Set to 1 when an ESB instruction defers a virtual SError\n                   interrupt.\nIDS, bit [24]    - The value copied from VSESR_EL2.IDS.\nISS, bits [0:23] - The value copied from VSESR_EL2.ISS."
      },
      "VMPIDR_EL2": {
        "long_name": "Virtualization Multiprocessor ID Register",
        "purpose": "Holds the value of the Virtualization Multiprocessor ID. This is the value\nreturned by EL1 reads of MPIDR_EL1.\n\nAff3, bits [32:39] - Affinity level 3. See the description of Aff0 for more\n                     information. Aff3 is not supported in AArch32 state.\nU, bit [30]        - Indicates a Uniprocessor system, as distinct from PE 0 in a\n                     multiprocessor system. The possible values of this bit are:\n                         0b0 Processor is part of a multiprocessor system.\n                         0b1 Processor is part of a uniprocessor system.\nMT, bit [24]       - Indicates whether the lowest level of affinity consists of\n                     logical PEs that are implemented using a multithreading\n                     type approach. See the description of Aff0 for more\n                     information about affinity levels. The possible values of\n                     this bit are:\n                         0b0 Performance of PEs at the lowest affinity level is\n                     largely independent.\n                         0b1 Performance of PEs at the lowest affinity level is\n                     very interdependent.\nAff2, bits [16:23] - Affinity level 2. See the description of Aff0 for more\n                     information.\nAff1, bits [8:15]  - Affinity level 1. See the description of Aff0 for more\n                     information.\nAff0, bits [0:7]   - Affinity level 0. This is the affinity level that is most\n                     significant for determining PE behavior. Higher affinity\n                     levels are increasingly less significant in determining PE\n                     behavior. The assigned value of the MPIDR.{Aff2, Aff1,\n                     Aff0} or MPIDR_EL1.{Aff3, Aff2, Aff1, Aff0} set of fields\n                     of each PE must be unique within the system as a whole."
      },
      "VNCR_EL2": {
        "long_name": "Virtual Nested Control Register",
        "purpose": "When ARMv8.4-NV is implemented, holds the base address that is used to define\nthe memory location that is accessed by transformed reads and writes of System\nregisters.\n\nBADDR, bits [12:52] - Base Address. If the virtual address space for EL2 does\n                      not support more than 48 bits, then bits [52:49] are RESS.\n                      When a register read/write is transformed to be a Load or\n                      Store, the address of the load/store is to\n                      SignOffset(VNCR.BADDR:Offset<11:0>, 64)."
      },
      "VPIDR_EL2": {
        "long_name": "Virtualization Processor ID Register",
        "purpose": "Holds the value of the Virtualization Processor ID. This is the value returned\nby EL1 reads of MIDR_EL1.\n\nImplementer, bits [24:31]  - The Implementer code. This field must hold an\n                             implementer code that has been assigned by Arm.\n                             Assigned codes include the following: Arm can\n                             assign codes that are not published in this manual.\n                             All values not assigned by Arm are reserved and\n                             must not be used.\nVariant, bits [20:23]      - An implementation defined variant number.\n                             Typically, this field is used to distinguish\n                             between different product variants, or major\n                             revisions of a product.\nArchitecture, bits [16:19] - The permitted values of this field are:\nPartNum, bits [4:15]       - An implementation defined primary part number for\n                             the device. On processors implemented by Arm, if\n                             the top four bits of the primary part number are\n                             0x0 or 0x7, the variant and architecture are\n                             encoded differently.\nRevision, bits [0:3]       - An implementation defined revision number for the\n                             device."
      },
      "VSESR_EL2": {
        "long_name": "Virtual SError Exception Syndrome Register",
        "purpose": "Provides the syndrome value reported to software on taking a virtual SError\ninterrupt exception to EL1, or on executing an ESB instruction at EL1.\n\nWhen the virtual SError interrupt is taken to EL1 using AArch64, then the\nsyndrome value is reported in ESR_EL1.\n\nWhen the virtual SError interrupt is taken to EL1 using AArch32, then the\nsyndrome value is reported in DFSR.{AET, ExT} and the remainder of DFSR is set\nas defined by VMSAv8-32. For more information, see The AArch32 Virtual Memory\nSystem Architecture.\n\nWhen the virtual SError interrupt is deferred by an ESB instruction, then the\nsyndrome value is written to VDISR_EL2.\n\nAET, bits [14:15] - When a virtual SError interrupt is taken to EL1 using\n                    AArch32, DFSR[15:4] is set to VSESR_EL2.AET. When a virtual\n                    SError interrupt is deferred by an ESB instruction,\n                    VDISR_EL2[15:4] is set to VSESR_EL2.AET.\nExT, bit [12]     - When a virtual SError interrupt is taken to EL1 using\n                    AArch32, DFSR[12] is set to VSESR_EL2.ExT. When a virtual\n                    SError interrupt is deferred by an ESB instruction,\n                    VDISR_EL2[12] is set to VSESR_EL2.ExT."
      },
      "VSTCR_EL2": {
        "long_name": "Virtualization Secure Translation Control Register",
        "purpose": "The control register for stage 2 of the Secure EL1&0 translation regime.\n\nSA, bit [30]      - Secure stage 2 translation output address space.\nSW, bit [29]      - Secure stage 2 translation address space.\nTG0, bits [14:15] - Secure stage 2 granule size for VSTTBR_EL2.\nSL0, bits [6:7]   - Starting level of the Secure stage 2 translation lookup,\n                    controlled by VSTCR_EL2. The meaning of this field depends\n                    on the value of VSTCR_EL2.TG0.\nSL0, bits [6:7]   - Starting level of the Secure stage 2 translation lookup,\n                    controlled by VSTCR_EL2. The meaning of this field depends\n                    on the value of VSTCR_EL2.TG0.\nT0SZ, bits [0:5]  - The size offset of the memory region addressed by\n                    VSTTBR_EL2. The region size is 2^(64-VSTCR_EL2.T0SZ) bytes.\n                    The maximum and minimum possible values for this field\n                    depend on the level of translation table and the memory\n                    translation granule size, as described in the AArch64\n                    Virtual Memory System Architecture chapter. If this field is\n                    programmed to a value that is not consistent with the\n                    programming of SL0, then a stage 2 level 0 Translation fault\n                    is generated."
      },
      "VSTTBR_EL2": {
        "long_name": "Virtualization Secure Translation Table Base Register",
        "purpose": "The base register for stage 2 of the Secure EL1&0 translation regime. Holds the\nbase address of the translation table for the initial lookup for stage 2 of an\naddress translation in the Secure EL1&0 translation regime, and other\ninformation for this translation stage.\n\nBADDR, bits [1:47] - Translation table base address, A[47:x] or A[51:x].\nCnP, bit [0]       - Common not Private, for stage 2 of the Secure EL1&0\n                     translation regime."
      },
      "VTCR_EL2": {
        "long_name": "Virtualization Translation Control Register",
        "purpose": "The control register for stage 2 of the EL1&0 translation regime.\n\nNSA, bit [30]       - Non-secure stage 2 translation output address space.\nNSW, bit [29]       - Non-secure stage 2 translation table address space.\nHWU62, bit [28]     - Hardware Use.\nHWU61, bit [27]     - Hardware Use.\nHWU60, bit [26]     - Hardware Use.\nHWU59, bit [25]     - Hardware Use.\nHD, bit [22]        - Hardware management of dirty state in stage 2 translations\n                      when EL2 is enabled in the current Security state.\nHA, bit [21]        - Hardware Access flag update in Non-secure and Secure stage\n                      2 translations when EL2 is enabled in the current Security\n                      state.\nVS, bit [19]        - VMID Size.\nPS, bits [16:18]    - Physical address Size for the Second Stage of translation.\nTG0, bits [14:15]   - Granule size for the VTTBR_EL2.\nSH0, bits [12:13]   - Shareability attribute for memory associated with\n                      translation table walks using VTTBR_EL2 or VSTTBR_EL2.\nORGN0, bits [10:11] - Outer cacheability attribute for memory associated with\n                      translation table walks using VTTBR_EL2 or VSTTBR_EL2.\nIRGN0, bits [8:9]   - Inner cacheability attribute for memory associated with\n                      translation table walks using VTTBR_EL2 or VSTTBR_EL2.\nSL0, bits [6:7]     - Starting level of the Secure stage 2 translation lookup,\n                      controlled by VTCR_EL2.\nSL0, bits [6:7]     - Starting level of the Secure stage 2 translation lookup,\n                      controlled by VTCR_EL2.\nT0SZ, bits [0:5]    - The size offset of the memory region addressed by\n                      VTTBR_EL2."
      },
      "VTTBR_EL2": {
        "long_name": "Virtualization Translation Table Base Register",
        "purpose": "Holds the base address of the translation table for the initial lookup for stage\n2 of an address translation in the EL1&0 translation regime, and other\ninformation for this translation regime.\n\nVMID[15:8], bits [56:63] - Extension to VMID[7:0].\nVMID[7:0], bits [48:55]  - The VMID for the translation table.\nBADDR, bits [1:47]       - Translation table base address, A[47:x] or A[51:x],\n                           bits[47:1].\nCnP, bit [0]             - Common not Private."
      },
      "ZCR_EL1": {
        "long_name": "SVE Control Register for EL1",
        "purpose": "The SVE Control Register for EL1 is used to control aspects of SVE visible at\nException levels EL1 and EL0.\n\nLEN, bits [0:3] - Constrains the scalable vector register length for EL1 and EL0\n                  to (LEN+1)x128 bits. For all purposes other than returning the\n                  result of a direct read of ZCR_EL1 then this field behaves as\n                  if it is set to the minimum of the stored value and the\n                  constrained length inherited from more privileged Exception\n                  levels in the current Security state, rounded down to the\n                  nearest implemented vector length. An indirect read of\n                  ZCR_EL1.LEN appears to occur in program order relative to a\n                  direct write of the same register, without the need for\n                  explicit synchronization."
      },
      "ZCR_EL2": {
        "long_name": "SVE Control Register for EL2",
        "purpose": "The SVE Control Register for EL2 is used to control aspects of SVE visible at\nException levels EL2, EL1, and EL0, when EL2 is enabled in the current Security\nstate.\n\nLEN, bits [0:3] - Constrains the scalable vector register length for EL2, EL1,\n                  and EL0 to (LEN+1)x128 bits, when EL2 is enabled in the\n                  current Security state. For all purposes other than returning\n                  the result of a direct read of ZCR_EL2 then this field behaves\n                  as if it is set to the minimum of the stored value and the\n                  constrained length inherited from more privileged Exception\n                  levels in the current Security state, rounded down to the\n                  nearest implemented vector length. An indirect read of\n                  ZCR_EL2.LEN appears to occur in program order relative to a\n                  direct write of the same register, without the need for\n                  explicit synchronization."
      },
      "ZCR_EL3": {
        "long_name": "SVE Control Register for EL3",
        "purpose": "The SVE Control Register for EL3 is used to control aspects of SVE visible at\nall Exception levels.\n\nLEN, bits [0:3] - Constrains the scalable vector register length for all\n                  Exception levels to (LEN+1)x128 bits. For all purposes other\n                  than returning the result of a direct read of ZCR_EL3 then\n                  this field behaves as if rounded down to the nearest\n                  implemented vector length. An indirect read of ZCR_EL3.LEN\n                  appears to occur in program order relative to a direct write\n                  of the same register, without the need for explicit\n                  synchronization."
      },
      "HID0_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 0",
        "purpose": ""
      },
      "EHID0_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 0 (E-core)",
        "purpose": ""
      },
      "HID1_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 1",
        "purpose": ""
      },
      "EHID1_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 1 (E-core)",
        "purpose": ""
      },
      "HID2_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 2",
        "purpose": ""
      },
      "EHID2_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 2 (E-core)",
        "purpose": ""
      },
      "HID3_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 3",
        "purpose": ""
      },
      "EHID3_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 3 (E-core)",
        "purpose": ""
      },
      "HID4_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 4",
        "purpose": ""
      },
      "EHID4_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 4 (E-core)",
        "purpose": ""
      },
      "HID5_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 5",
        "purpose": ""
      },
      "EHID5_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 5 (E-core)",
        "purpose": ""
      },
      "HID6_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 6",
        "purpose": ""
      },
      "HID7_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 7",
        "purpose": ""
      },
      "EHID7_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 7 (E-core)",
        "purpose": ""
      },
      "HID8_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 8",
        "purpose": ""
      },
      "HID9_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 9",
        "purpose": ""
      },
      "EHID9_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 9 (E-core)",
        "purpose": ""
      },
      "HID10_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 10",
        "purpose": ""
      },
      "EHID10_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 10 (E-core)",
        "purpose": ""
      },
      "HID11_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 11",
        "purpose": ""
      },
      "EHID11_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 11 (E-core)",
        "purpose": ""
      },
      "HID13_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 13",
        "purpose": ""
      },
      "HID14_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 14",
        "purpose": ""
      },
      "HID16_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 16",
        "purpose": ""
      },
      "HID17_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 17",
        "purpose": ""
      },
      "HID18_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 18",
        "purpose": ""
      },
      "EHID20_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 20 (E-core)",
        "purpose": ""
      },
      "HID21_EL1": {
        "long_name": "Hardware Implementation-Dependent Register 21",
        "purpose": ""
      },
      "PMCR0_EL1": {
        "long_name": "Performance Monitor Control Register 0",
        "purpose": ""
      },
      "PMCR1_EL1": {
        "long_name": "Performance Monitor Control Register 1",
        "purpose": ""
      },
      "PMCR2_EL1": {
        "long_name": "Performance Monitor Control Register 2",
        "purpose": ""
      },
      "PMCR3_EL1": {
        "long_name": "Performance Monitor Control Register 3",
        "purpose": ""
      },
      "PMCR4_EL1": {
        "long_name": "Performance Monitor Control Register 4",
        "purpose": ""
      },
      "PMESR0_EL1": {
        "long_name": "Performance Monitor Event Selection Register 0",
        "purpose": ""
      },
      "PMESR1_EL1": {
        "long_name": "Performance Monitor Event Selection Register 1",
        "purpose": ""
      },
      "PMSR_EL1": {
        "long_name": "Performance Monitor Status Register",
        "purpose": ""
      },
      "PMC0_EL1": {
        "long_name": "Performance Monitor Counter 0",
        "purpose": ""
      },
      "PMC1_EL1": {
        "long_name": "Performance Monitor Counter 1",
        "purpose": ""
      },
      "PMC2_EL1": {
        "long_name": "Performance Monitor Counter 2",
        "purpose": ""
      },
      "PMC3_EL1": {
        "long_name": "Performance Monitor Counter 3",
        "purpose": ""
      },
      "PMC4_EL1": {
        "long_name": "Performance Monitor Counter 4",
        "purpose": ""
      },
      "PMC5_EL1": {
        "long_name": "Performance Monitor Counter 5",
        "purpose": ""
      },
      "PMC6_EL1": {
        "long_name": "Performance Monitor Counter 6",
        "purpose": ""
      },
      "PMC7_EL1": {
        "long_name": "Performance Monitor Counter 7",
        "purpose": ""
      },
      "PMC8_EL1": {
        "long_name": "Performance Monitor Counter 8",
        "purpose": ""
      },
      "PMC9_EL1": {
        "long_name": "Performance Monitor Counter 9",
        "purpose": ""
      },
      "LSU_ERR_STS_EL1": {
        "long_name": "Load-Store Unit Error Status",
        "purpose": ""
      },
      "E_LSU_ERR_STS_EL1": {
        "long_name": "Load-Store Unit Error Status (E-core)",
        "purpose": ""
      },
      "LSU_ERR_CTL_EL1": {
        "long_name": "Load-Store Unit Error Control",
        "purpose": ""
      },
      "L2C_ERR_STS_EL1": {
        "long_name": "L2 Cache Error Status",
        "purpose": ""
      },
      "L2C_ERR_ADR_EL1": {
        "long_name": "L2 Cache Address",
        "purpose": ""
      },
      "L2C_ERR_INF_EL1": {
        "long_name": "L2 Cache Error Information",
        "purpose": ""
      },
      "FED_ERR_STS_EL1": {
        "long_name": "FED Error Status",
        "purpose": ""
      },
      "E_FED_ERR_STS_EL1": {
        "long_name": "FED Error Status (E-Core)",
        "purpose": ""
      },
      "APCTL_EL1": {
        "long_name": "Pointer Authentication Control",
        "purpose": ""
      },
      "KERNELKEYLO_EL1": {
        "long_name": "Pointer Authentication Kernel Key Low",
        "purpose": ""
      },
      "KERNELKEYHI_EL1": {
        "long_name": "Pointer Authentication Kernel Key High",
        "purpose": ""
      },
      "VMSA_LOCK_EL1": {
        "long_name": "Virtual Memory System Architecture Lock",
        "purpose": ""
      },
      "AMX_CTL_EL1": {
        "long_name": "AMX Control (EL1)",
        "purpose": ""
      },
      "APRR_EL0": {
        "long_name": "APRR EL0",
        "purpose": ""
      },
      "APRR_EL1": {
        "long_name": "APRR EL1",
        "purpose": ""
      },
      "CTRR_LOCK_EL1": {
        "long_name": "CTRR Lock",
        "purpose": ""
      },
      "CTRR_A_LWR_EL1": {
        "long_name": "CTRR A Lower Address (EL1)",
        "purpose": ""
      },
      "CTRR_A_UPR_EL1": {
        "long_name": "CTRR A Upper Address (EL1)",
        "purpose": ""
      },
      "CTRR_CTL_EL1": {
        "long_name": "CTRR Control (EL1)",
        "purpose": ""
      },
      "APRR_JIT_ENABLE_EL2": {
        "long_name": "APRR JIT Enable",
        "purpose": ""
      },
      "APRR_JIT_MASK_EL2": {
        "long_name": "APRR JIT Mask",
        "purpose": ""
      },
      "AMX_CTL_EL12": {
        "long_name": "AMX Control (EL12)",
        "purpose": ""
      },
      "AMX_CTL_EL2": {
        "long_name": "AMX Control (EL2)",
        "purpose": ""
      },
      "SPRR_PERM_EL20_SILLY_THING": {
        "long_name": "SPRR Permission Configuration Register (EL20, useless)",
        "purpose": ""
      },
      "SPRR_PERM_EL02": {
        "long_name": "SPRR Permission Configuration Register (EL02)",
        "purpose": ""
      },
      "SPRR_KMASK0_EL12": {
        "long_name": "SPRR Kernel Permission Unlock Mask 0 (EL12)",
        "purpose": ""
      },
      "SPRR_UMASK0_EL2": {
        "long_name": "SPRR Permission Unlock Mask 0 (EL2)",
        "purpose": ""
      },
      "SPRR_UMASK1_EL2": {
        "long_name": "SPRR Permission Unlock Mask 1 (EL2)",
        "purpose": ""
      },
      "SPRR_UMASK2_EL2": {
        "long_name": "SPRR Permission Unlock Mask 2 (EL2)",
        "purpose": ""
      },
      "SPRR_UMASK3_EL2": {
        "long_name": "SPRR Permission Unlock Mask 3 (EL2)",
        "purpose": ""
      },
      "SPRR_UMASK0_EL12": {
        "long_name": "SPRR Permission Unlock Mask 0 (EL12)",
        "purpose": ""
      },
      "SPRR_UMASK1_EL12": {
        "long_name": "SPRR Permission Unlock Mask 1 (EL12)",
        "purpose": ""
      },
      "SPRR_UMASK2_EL12": {
        "long_name": "SPRR Permission Unlock Mask 2 (EL12)",
        "purpose": ""
      },
      "SPRR_UMASK3_EL12": {
        "long_name": "SPRR Permission Unlock Mask 3 (EL12)",
        "purpose": ""
      },
      "CNTPCT_ALIAS_EL0": {
        "long_name": "Physical timer counter register",
        "purpose": ""
      },
      "CNTVCT_ALIAS_EL0": {
        "long_name": "Virtual timer counter register",
        "purpose": ""
      },
      "CTRR_A_LWR_EL2": {
        "long_name": "CTRR A Lower Address (EL2)",
        "purpose": ""
      },
      "CTRR_A_UPR_EL2": {
        "long_name": "CTRR A Upper Address (EL2)",
        "purpose": ""
      },
      "CTRR_CTL_EL2": {
        "long_name": "CTRR Control (EL2)",
        "purpose": ""
      },
      "CTRR_LOCK_EL2": {
        "long_name": "CTRR Lock",
        "purpose": ""
      },
      "IPI_RR_LOCAL_EL1": {
        "long_name": "IPI Request Register (Local)",
        "purpose": ""
      },
      "IPI_RR_GLOBAL_EL1": {
        "long_name": "IPI Request Register (Global)",
        "purpose": ""
      },
      "DPC_ERR_STS_EL1": {
        "long_name": "DPC Error Status",
        "purpose": ""
      },
      "IPI_SR_EL1": {
        "long_name": "IPI Status Register",
        "purpose": ""
      },
      "VM_TMR_LR_EL2": {
        "long_name": "VM Timer Link Register",
        "purpose": ""
      },
      "VM_TMR_FIQ_ENA_EL2": {
        "long_name": "VM Timer FIQ Enable",
        "purpose": ""
      },
      "IPI_CR_EL1": {
        "long_name": "IPI Control Register",
        "purpose": ""
      },
      "ACC_CFG_EL1": {
        "long_name": "Apple Core Cluster Configuration",
        "purpose": ""
      },
      "CYC_OVRD_EL1": {
        "long_name": "Cyclone Override",
        "purpose": ""
      },
      "ACC_OVRD_EL1": {
        "long_name": "Apple Core Cluster Override",
        "purpose": ""
      },
      "ACC_EBLK_OVRD_EL1": {
        "long_name": "Apple Core Cluster E-Block Override",
        "purpose": ""
      },
      "MMU_ERR_STS_EL1": {
        "long_name": "MMU Error Status",
        "purpose": ""
      },
      "AFSR1_GL1": {
        "long_name": "Auxiliary Fault Status Register 1 (GL1)",
        "purpose": ""
      },
      "AFSR1_GL2": {
        "long_name": "Auxiliary Fault Status Register 1 (GL2)",
        "purpose": ""
      },
      "AFSR1_GL12": {
        "long_name": "Auxiliary Fault Status Register 1 (GL12)",
        "purpose": ""
      },
      "SPRR_CONFIG_EL1": {
        "long_name": "SPRR Configuration Register (EL1)",
        "purpose": ""
      },
      "GXF_CONFIG_EL1": {
        "long_name": "GXF Configuration Register (EL1)",
        "purpose": ""
      },
      "SPRR_UNK1_EL1": {
        "long_name": "SPRR Unknown (EL1)",
        "purpose": ""
      },
      "GXF_CONFIG_EL2": {
        "long_name": "GXF Configuration Register (EL2)",
        "purpose": ""
      },
      "SPRR_PERM_EL0": {
        "long_name": "SPRR Permission Configuration Register (EL0)",
        "purpose": ""
      },
      "SPRR_PERM_EL1": {
        "long_name": "SPRR Permission Configuration Register (EL1)",
        "purpose": ""
      },
      "SPRR_PERM_EL2": {
        "long_name": "SPRR Permission Configuration Register (EL2)",
        "purpose": ""
      },
      "E_MMU_ERR_STS_EL1": {
        "long_name": "MMU Error Status (E-Core)",
        "purpose": ""
      },
      "APGAKeyLo_EL12": {
        "long_name": "Pointer Authentication Key A for Code Low (EL12)",
        "purpose": ""
      },
      "APGAKeyHi_EL12": {
        "long_name": "Pointer Authentication Key A for Code High (EL12)",
        "purpose": ""
      },
      "KERNELKEYLO_EL12": {
        "long_name": "Pointer Authentication Kernel Key Low (EL12)",
        "purpose": ""
      },
      "KERNELKEYHI_EL12": {
        "long_name": "Pointer Authentication Kernel Key High (EL12)",
        "purpose": ""
      },
      "AFPCR_EL0": {
        "long_name": "Apple Floating-Point Control Register",
        "purpose": ""
      },
      "AIDR2_EL1": {
        "long_name": "Apple ID Register 2",
        "purpose": ""
      },
      "SPRR_UMASK0_EL1": {
        "long_name": "SPRR Permission Unlock Mask 0 (EL1)",
        "purpose": ""
      },
      "SPRR_KMASK0_EL1": {
        "long_name": "SPRR Kernel Permission Unlock Mask 0 (EL1)",
        "purpose": ""
      },
      "SPRR_KMASK0_EL2": {
        "long_name": "SPRR Kernel Permission Unlock Mask 0 (EL2)",
        "purpose": ""
      },
      "SPRR_UMASK1_EL1": {
        "long_name": "SPRR Permission Unlock Mask 1 (EL1)",
        "purpose": ""
      },
      "SPRR_UMASK2_EL1": {
        "long_name": "SPRR Permission Unlock Mask 2 (EL1)",
        "purpose": ""
      },
      "SPRR_UMASK3_EL1": {
        "long_name": "SPRR Permission Unlock Mask 3 (EL1)",
        "purpose": ""
      },
      "SPRR_KMASK1_EL1": {
        "long_name": "SPRR Kernel Permission Unlock Mask 1 (EL12)",
        "purpose": ""
      },
      "SPRR_KMASK2_EL1": {
        "long_name": "SPRR Kernel Permission Unlock Mask 2 (EL12)",
        "purpose": ""
      },
      "SPRR_KMASK3_EL1": {
        "long_name": "SPRR Kernel Permission Unlock Mask 3 (EL12)",
        "purpose": ""
      },
      "SPRR_KMASK1_EL2": {
        "long_name": "SPRR Kernel Permission Unlock Mask 1 (EL12)",
        "purpose": ""
      },
      "SPRR_KMASK2_EL2": {
        "long_name": "SPRR Kernel Permission Unlock Mask 2 (EL12)",
        "purpose": ""
      },
      "SPRR_KMASK3_EL2": {
        "long_name": "SPRR Kernel Permission Unlock Mask 3 (EL12)",
        "purpose": ""
      },
      "SPRR_KMASK1_EL12": {
        "long_name": "SPRR Kernel Permission Unlock Mask 1 (EL12)",
        "purpose": ""
      },
      "SPRR_KMASK2_EL12": {
        "long_name": "SPRR Kernel Permission Unlock Mask 2 (EL12)",
        "purpose": ""
      },
      "SPRR_KMASK3_EL12": {
        "long_name": "SPRR Kernel Permission Unlock Mask 3 (EL12)",
        "purpose": ""
      },
      "APIAKeyLo_EL12": {
        "long_name": "Pointer Authentication Key A for Instruction Low (EL12)",
        "purpose": ""
      },
      "APIAKeyHi_EL12": {
        "long_name": "Pointer Authentication Key A for Instruction High (EL12)",
        "purpose": ""
      },
      "APIBKeyLo_EL12": {
        "long_name": "Pointer Authentication Key A for Instruction Low (EL12)",
        "purpose": ""
      },
      "APIBKeyHi_EL12": {
        "long_name": "Pointer Authentication Key A for Instruction High (EL12)",
        "purpose": ""
      },
      "APDAKeyLo_EL12": {
        "long_name": "Pointer Authentication Key A for Data Low (EL12)",
        "purpose": ""
      },
      "APDAKeyHi_EL12": {
        "long_name": "Pointer Authentication Key A for Data High (EL12)",
        "purpose": ""
      },
      "APDBKeyLo_EL12": {
        "long_name": "Pointer Authentication Key A for Data Low (EL12)",
        "purpose": ""
      },
      "APDBKeyHi_EL12": {
        "long_name": "Pointer Authentication Key A for Data High (EL12)",
        "purpose": ""
      },
      "GXF_STATUS_EL1": {
        "long_name": "GXF Status Register",
        "purpose": ""
      },
      "GXF_ENTER_EL1": {
        "long_name": "GXF genter Entry Vector Register (EL1)",
        "purpose": ""
      },
      "GXF_ABORT_EL1": {
        "long_name": "GXF Abort Vector Register (EL1)",
        "purpose": ""
      },
      "VBAR_GL12": {
        "long_name": "Vector Base Address Register (GL12)",
        "purpose": ""
      },
      "SPSR_GL12": {
        "long_name": "Saved Program Status Register (GL12)",
        "purpose": ""
      },
      "ASPSR_GL12": {
        "long_name": "ASPSR (GL12)",
        "purpose": ""
      },
      "ESR_GL12": {
        "long_name": "Exception Syndrome Register (GL12)",
        "purpose": ""
      },
      "ELR_GL12": {
        "long_name": "Exception Link Register (GL12)",
        "purpose": ""
      },
      "SP_GL12": {
        "long_name": "Stack Pointer Register (GL12)",
        "purpose": ""
      },
      "TPIDR_GL1": {
        "long_name": "Software Thread ID Register (GL1)",
        "purpose": ""
      },
      "VBAR_GL1": {
        "long_name": "Vector Base Address Register (GL1)",
        "purpose": ""
      },
      "SPSR_GL1": {
        "long_name": "Saved Program Status Register (GL1)",
        "purpose": ""
      },
      "ASPSR_GL1": {
        "long_name": "ASPSR (GL1)",
        "purpose": ""
      },
      "ESR_GL1": {
        "long_name": "Exception Syndrome Register (GL1)",
        "purpose": ""
      },
      "ELR_GL1": {
        "long_name": "Exception Link Register (GL1)",
        "purpose": ""
      },
      "FAR_GL1": {
        "long_name": "Fault Address Register (GL1)",
        "purpose": ""
      },
      "TPIDR_GL2": {
        "long_name": "Software Thread ID Register (GL2)",
        "purpose": ""
      },
      "VBAR_GL2": {
        "long_name": "Vector Base Address Register (GL2)",
        "purpose": ""
      },
      "SPSR_GL2": {
        "long_name": "Saved Program Status Register (GL2)",
        "purpose": ""
      },
      "ASPSR_GL2": {
        "long_name": "ASPSR (GL2)",
        "purpose": ""
      },
      "ESR_GL2": {
        "long_name": "Exception Syndrome Register (GL2)",
        "purpose": ""
      },
      "ELR_GL2": {
        "long_name": "Exception Link Register (GL2)",
        "purpose": ""
      },
      "FAR_GL2": {
        "long_name": "Fault Address Register (GL2)",
        "purpose": ""
      },
      "GXF_ENTER_EL2": {
        "long_name": "GXF genter Entry Vector Register (EL2)",
        "purpose": ""
      },
      "GXF_ABORT_EL2": {
        "long_name": "GXF Abort Vector Register (EL2)",
        "purpose": ""
      },
      "APCTL_EL2": {
        "long_name": "Pointer Authentication Control (EL2)",
        "purpose": ""
      },
      "APSTS_EL2_MAYBE": {
        "long_name": "Pointer Authentication Status (EL2, maybe)",
        "purpose": ""
      },
      "APSTS_EL1": {
        "long_name": "Pointer Authentication Status",
        "purpose": ""
      },
      "SPRR_CONFIG_EL2": {
        "long_name": "SPRR Configuration Register (EL2)",
        "purpose": ""
      },
      "SPRR_UNK1_EL2": {
        "long_name": "SPRR Unknown (EL2)",
        "purpose": ""
      },
      "APVMKEYLO_EL2": {
        "long_name": "Pointer Authentication VM Machine Key Low",
        "purpose": ""
      },
      "APVMKEYHI_EL2": {
        "long_name": "Pointer Authentication VM Machine Key High",
        "purpose": ""
      },
      "ACTLR_EL12": {
        "long_name": "Auxiliary Control Register (EL12)",
        "purpose": ""
      },
      "APSTS_EL12": {
        "long_name": "Pointer Authentication Status (EL12)",
        "purpose": ""
      },
      "APCTL_EL12": {
        "long_name": "Pointer Authentication Control (EL12)",
        "purpose": ""
      },
      "GXF_CONFIG_EL12": {
        "long_name": "GXF Configuration Register (EL12)",
        "purpose": ""
      },
      "GXF_ENTER_EL12": {
        "long_name": "GXF genter Entry Vector Register (EL12)",
        "purpose": ""
      },
      "GXF_ABORT_EL12": {
        "long_name": "GXF Abort Vector Register (EL12)",
        "purpose": ""
      },
      "SPRR_CONFIG_EL12": {
        "long_name": "SPRR Configuration Register (EL12)",
        "purpose": ""
      },
      "SPRR_UNK1_EL12": {
        "long_name": "SPRR Unknown (EL2)",
        "purpose": ""
      },
      "SPRR_PERM_EL12": {
        "long_name": "SPRR Permission Configuration Register (EL12)",
        "purpose": ""
      },
      "UPMCR0_EL1": {
        "long_name": "Uncore Performance Monitor Control Register 0",
        "purpose": ""
      },
      "UPMESR0_EL1": {
        "long_name": "Uncore Performance Monitor Event Selection Register 0",
        "purpose": ""
      },
      "UPMECM0_EL1": {
        "long_name": "Uncore Performance Monitor Event Core Mask 0",
        "purpose": ""
      },
      "UPMECM1_EL1": {
        "long_name": "Uncore Performance Monitor Event Core Mask 1",
        "purpose": ""
      },
      "UPMPCM_EL1": {
        "long_name": "Uncore Performance Monitor PMI Core Mask",
        "purpose": ""
      },
      "UPMSR_EL1": {
        "long_name": "Uncore Performance Monitor Status Register",
        "purpose": ""
      },
      "UPMECM2_EL1": {
        "long_name": "Uncore Performance Monitor Event Core Mask 2",
        "purpose": ""
      },
      "UPMECM3_EL1": {
        "long_name": "Uncore Performance Monitor Event Core Mask 3",
        "purpose": ""
      },
      "UPMESR1_EL1": {
        "long_name": "Uncore Performance Monitor Event Selection Register 1",
        "purpose": ""
      },
      "UPMC0_EL1": {
        "long_name": "Uncore Performance Monitor Counter 0",
        "purpose": ""
      },
      "UPMC1_EL1": {
        "long_name": "Uncore Performance Monitor Counter 1",
        "purpose": ""
      },
      "UPMC2_EL1": {
        "long_name": "Uncore Performance Monitor Counter 2",
        "purpose": ""
      },
      "UPMC3_EL1": {
        "long_name": "Uncore Performance Monitor Counter 3",
        "purpose": ""
      },
      "UPMC4_EL1": {
        "long_name": "Uncore Performance Monitor Counter 4",
        "purpose": ""
      },
      "UPMC5_EL1": {
        "long_name": "Uncore Performance Monitor Counter 5",
        "purpose": ""
      },
      "UPMC6_EL1": {
        "long_name": "Uncore Performance Monitor Counter 6",
        "purpose": ""
      },
      "UPMC7_EL1": {
        "long_name": "Uncore Performance Monitor Counter 7",
        "purpose": ""
      },
      "UPMC8_EL1": {
        "long_name": "Uncore Performance Monitor Counter 8",
        "purpose": ""
      },
      "UPMC9_EL1": {
        "long_name": "Uncore Performance Monitor Counter 9",
        "purpose": ""
      },
      "UPMC10_EL1": {
        "long_name": "Uncore Performance Monitor Counter 10",
        "purpose": ""
      },
      "UPMC11_EL1": {
        "long_name": "Uncore Performance Monitor Counter 11",
        "purpose": ""
      },
      "UPMC12_EL1": {
        "long_name": "Uncore Performance Monitor Counter 12",
        "purpose": ""
      },
      "UPMC13_EL1": {
        "long_name": "Uncore Performance Monitor Counter 13",
        "purpose": ""
      },
      "UPMC14_EL1": {
        "long_name": "Uncore Performance Monitor Counter 14",
        "purpose": ""
      },
      "UPMC15_EL1": {
        "long_name": "Uncore Performance Monitor Counter 15",
        "purpose": ""
      }
    }
  }
}